
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model OTP
 * 
 */
export type OTP = $Result.DefaultSelection<Prisma.$OTPPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model QuizAnswer
 * 
 */
export type QuizAnswer = $Result.DefaultSelection<Prisma.$QuizAnswerPayload>
/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model ChallengeQuestion
 * 
 */
export type ChallengeQuestion = $Result.DefaultSelection<Prisma.$ChallengeQuestionPayload>
/**
 * Model ChallengeAnswer
 * 
 */
export type ChallengeAnswer = $Result.DefaultSelection<Prisma.$ChallengeAnswerPayload>
/**
 * Model PuzzleChallenge
 * 
 */
export type PuzzleChallenge = $Result.DefaultSelection<Prisma.$PuzzleChallengePayload>
/**
 * Model OrderingChallenge
 * 
 */
export type OrderingChallenge = $Result.DefaultSelection<Prisma.$OrderingChallengePayload>
/**
 * Model OrderingItem
 * 
 */
export type OrderingItem = $Result.DefaultSelection<Prisma.$OrderingItemPayload>
/**
 * Model FillBlankChallenge
 * 
 */
export type FillBlankChallenge = $Result.DefaultSelection<Prisma.$FillBlankChallengePayload>
/**
 * Model FillBlankQuestion
 * 
 */
export type FillBlankQuestion = $Result.DefaultSelection<Prisma.$FillBlankQuestionPayload>
/**
 * Model UserLessonProgress
 * 
 */
export type UserLessonProgress = $Result.DefaultSelection<Prisma.$UserLessonProgressPayload>
/**
 * Model ChallengeScore
 * 
 */
export type ChallengeScore = $Result.DefaultSelection<Prisma.$ChallengeScorePayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model UserLessonScore
 * 
 */
export type UserLessonScore = $Result.DefaultSelection<Prisma.$UserLessonScorePayload>
/**
 * Model UserCourseProgress
 * 
 */
export type UserCourseProgress = $Result.DefaultSelection<Prisma.$UserCourseProgressPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CategoryStatus: {
  draft: 'draft',
  published: 'published',
  archived: 'archived'
};

export type CategoryStatus = (typeof CategoryStatus)[keyof typeof CategoryStatus]


export const ProductLabel: {
  new: 'new',
  hot: 'hot',
  featured: 'featured',
  best_seller: 'best_seller'
};

export type ProductLabel = (typeof ProductLabel)[keyof typeof ProductLabel]


export const ProductStatus: {
  draft: 'draft',
  published: 'published',
  archived: 'archived'
};

export type ProductStatus = (typeof ProductStatus)[keyof typeof ProductStatus]


export const ModuleStatus: {
  draft: 'draft',
  published: 'published',
  archived: 'archived'
};

export type ModuleStatus = (typeof ModuleStatus)[keyof typeof ModuleStatus]


export const LessonType: {
  video: 'video',
  content: 'content',
  quiz: 'quiz'
};

export type LessonType = (typeof LessonType)[keyof typeof LessonType]


export const LessonStatus: {
  draft: 'draft',
  published: 'published',
  archived: 'archived'
};

export type LessonStatus = (typeof LessonStatus)[keyof typeof LessonStatus]


export const ChallengeType: {
  quiz: 'quiz',
  puzzle: 'puzzle',
  ordering: 'ordering',
  fillBlank: 'fillBlank'
};

export type ChallengeType = (typeof ChallengeType)[keyof typeof ChallengeType]


export const ChallengeStatus: {
  draft: 'draft',
  published: 'published',
  archived: 'archived'
};

export type ChallengeStatus = (typeof ChallengeStatus)[keyof typeof ChallengeStatus]


export const Grade: {
  G1: 'G1',
  G2: 'G2',
  G3: 'G3',
  G4: 'G4',
  G5: 'G5',
  G6: 'G6',
  G7: 'G7',
  G8: 'G8',
  G9: 'G9',
  G10: 'G10',
  G11: 'G11',
  G12: 'G12'
};

export type Grade = (typeof Grade)[keyof typeof Grade]

}

export type CategoryStatus = $Enums.CategoryStatus

export const CategoryStatus: typeof $Enums.CategoryStatus

export type ProductLabel = $Enums.ProductLabel

export const ProductLabel: typeof $Enums.ProductLabel

export type ProductStatus = $Enums.ProductStatus

export const ProductStatus: typeof $Enums.ProductStatus

export type ModuleStatus = $Enums.ModuleStatus

export const ModuleStatus: typeof $Enums.ModuleStatus

export type LessonType = $Enums.LessonType

export const LessonType: typeof $Enums.LessonType

export type LessonStatus = $Enums.LessonStatus

export const LessonStatus: typeof $Enums.LessonStatus

export type ChallengeType = $Enums.ChallengeType

export const ChallengeType: typeof $Enums.ChallengeType

export type ChallengeStatus = $Enums.ChallengeStatus

export const ChallengeStatus: typeof $Enums.ChallengeStatus

export type Grade = $Enums.Grade

export const Grade: typeof $Enums.Grade

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oTP`: Exposes CRUD operations for the **OTP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTPS
    * const oTPS = await prisma.oTP.findMany()
    * ```
    */
  get oTP(): Prisma.OTPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAnswer`: Exposes CRUD operations for the **QuizAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAnswers
    * const quizAnswers = await prisma.quizAnswer.findMany()
    * ```
    */
  get quizAnswer(): Prisma.QuizAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeQuestion`: Exposes CRUD operations for the **ChallengeQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeQuestions
    * const challengeQuestions = await prisma.challengeQuestion.findMany()
    * ```
    */
  get challengeQuestion(): Prisma.ChallengeQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeAnswer`: Exposes CRUD operations for the **ChallengeAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeAnswers
    * const challengeAnswers = await prisma.challengeAnswer.findMany()
    * ```
    */
  get challengeAnswer(): Prisma.ChallengeAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.puzzleChallenge`: Exposes CRUD operations for the **PuzzleChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PuzzleChallenges
    * const puzzleChallenges = await prisma.puzzleChallenge.findMany()
    * ```
    */
  get puzzleChallenge(): Prisma.PuzzleChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderingChallenge`: Exposes CRUD operations for the **OrderingChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderingChallenges
    * const orderingChallenges = await prisma.orderingChallenge.findMany()
    * ```
    */
  get orderingChallenge(): Prisma.OrderingChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderingItem`: Exposes CRUD operations for the **OrderingItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderingItems
    * const orderingItems = await prisma.orderingItem.findMany()
    * ```
    */
  get orderingItem(): Prisma.OrderingItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fillBlankChallenge`: Exposes CRUD operations for the **FillBlankChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FillBlankChallenges
    * const fillBlankChallenges = await prisma.fillBlankChallenge.findMany()
    * ```
    */
  get fillBlankChallenge(): Prisma.FillBlankChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fillBlankQuestion`: Exposes CRUD operations for the **FillBlankQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FillBlankQuestions
    * const fillBlankQuestions = await prisma.fillBlankQuestion.findMany()
    * ```
    */
  get fillBlankQuestion(): Prisma.FillBlankQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLessonProgress`: Exposes CRUD operations for the **UserLessonProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLessonProgresses
    * const userLessonProgresses = await prisma.userLessonProgress.findMany()
    * ```
    */
  get userLessonProgress(): Prisma.UserLessonProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeScore`: Exposes CRUD operations for the **ChallengeScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeScores
    * const challengeScores = await prisma.challengeScore.findMany()
    * ```
    */
  get challengeScore(): Prisma.ChallengeScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLessonScore`: Exposes CRUD operations for the **UserLessonScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLessonScores
    * const userLessonScores = await prisma.userLessonScore.findMany()
    * ```
    */
  get userLessonScore(): Prisma.UserLessonScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCourseProgress`: Exposes CRUD operations for the **UserCourseProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCourseProgresses
    * const userCourseProgresses = await prisma.userCourseProgress.findMany()
    * ```
    */
  get userCourseProgress(): Prisma.UserCourseProgressDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    OTP: 'OTP',
    Category: 'Category',
    Product: 'Product',
    Module: 'Module',
    Lesson: 'Lesson',
    Enrollment: 'Enrollment',
    Review: 'Review',
    QuizQuestion: 'QuizQuestion',
    QuizAnswer: 'QuizAnswer',
    Challenge: 'Challenge',
    ChallengeQuestion: 'ChallengeQuestion',
    ChallengeAnswer: 'ChallengeAnswer',
    PuzzleChallenge: 'PuzzleChallenge',
    OrderingChallenge: 'OrderingChallenge',
    OrderingItem: 'OrderingItem',
    FillBlankChallenge: 'FillBlankChallenge',
    FillBlankQuestion: 'FillBlankQuestion',
    UserLessonProgress: 'UserLessonProgress',
    ChallengeScore: 'ChallengeScore',
    SystemSetting: 'SystemSetting',
    UserLessonScore: 'UserLessonScore',
    UserCourseProgress: 'UserCourseProgress'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "oTP" | "category" | "product" | "module" | "lesson" | "enrollment" | "review" | "quizQuestion" | "quizAnswer" | "challenge" | "challengeQuestion" | "challengeAnswer" | "puzzleChallenge" | "orderingChallenge" | "orderingItem" | "fillBlankChallenge" | "fillBlankQuestion" | "userLessonProgress" | "challengeScore" | "systemSetting" | "userLessonScore" | "userCourseProgress"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      OTP: {
        payload: Prisma.$OTPPayload<ExtArgs>
        fields: Prisma.OTPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OTPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OTPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findFirst: {
            args: Prisma.OTPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OTPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findMany: {
            args: Prisma.OTPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          create: {
            args: Prisma.OTPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          createMany: {
            args: Prisma.OTPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OTPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          delete: {
            args: Prisma.OTPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          update: {
            args: Prisma.OTPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          deleteMany: {
            args: Prisma.OTPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OTPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OTPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          upsert: {
            args: Prisma.OTPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          aggregate: {
            args: Prisma.OTPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOTP>
          }
          groupBy: {
            args: Prisma.OTPGroupByArgs<ExtArgs>
            result: $Utils.Optional<OTPGroupByOutputType>[]
          }
          count: {
            args: Prisma.OTPCountArgs<ExtArgs>
            result: $Utils.Optional<OTPCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      QuizAnswer: {
        payload: Prisma.$QuizAnswerPayload<ExtArgs>
        fields: Prisma.QuizAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          findFirst: {
            args: Prisma.QuizAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          findMany: {
            args: Prisma.QuizAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          create: {
            args: Prisma.QuizAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          createMany: {
            args: Prisma.QuizAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          delete: {
            args: Prisma.QuizAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          update: {
            args: Prisma.QuizAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          deleteMany: {
            args: Prisma.QuizAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          upsert: {
            args: Prisma.QuizAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          aggregate: {
            args: Prisma.QuizAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAnswer>
          }
          groupBy: {
            args: Prisma.QuizAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAnswerCountAggregateOutputType> | number
          }
        }
      }
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeQuestion: {
        payload: Prisma.$ChallengeQuestionPayload<ExtArgs>
        fields: Prisma.ChallengeQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload>
          }
          findFirst: {
            args: Prisma.ChallengeQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload>
          }
          findMany: {
            args: Prisma.ChallengeQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload>[]
          }
          create: {
            args: Prisma.ChallengeQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload>
          }
          createMany: {
            args: Prisma.ChallengeQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload>[]
          }
          delete: {
            args: Prisma.ChallengeQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload>
          }
          update: {
            args: Prisma.ChallengeQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeQuestionPayload>
          }
          aggregate: {
            args: Prisma.ChallengeQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeQuestion>
          }
          groupBy: {
            args: Prisma.ChallengeQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeQuestionCountAggregateOutputType> | number
          }
        }
      }
      ChallengeAnswer: {
        payload: Prisma.$ChallengeAnswerPayload<ExtArgs>
        fields: Prisma.ChallengeAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload>
          }
          findFirst: {
            args: Prisma.ChallengeAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload>
          }
          findMany: {
            args: Prisma.ChallengeAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload>[]
          }
          create: {
            args: Prisma.ChallengeAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload>
          }
          createMany: {
            args: Prisma.ChallengeAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload>[]
          }
          delete: {
            args: Prisma.ChallengeAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload>
          }
          update: {
            args: Prisma.ChallengeAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAnswerPayload>
          }
          aggregate: {
            args: Prisma.ChallengeAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeAnswer>
          }
          groupBy: {
            args: Prisma.ChallengeAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeAnswerCountAggregateOutputType> | number
          }
        }
      }
      PuzzleChallenge: {
        payload: Prisma.$PuzzleChallengePayload<ExtArgs>
        fields: Prisma.PuzzleChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PuzzleChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PuzzleChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload>
          }
          findFirst: {
            args: Prisma.PuzzleChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PuzzleChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload>
          }
          findMany: {
            args: Prisma.PuzzleChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload>[]
          }
          create: {
            args: Prisma.PuzzleChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload>
          }
          createMany: {
            args: Prisma.PuzzleChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PuzzleChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload>[]
          }
          delete: {
            args: Prisma.PuzzleChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload>
          }
          update: {
            args: Prisma.PuzzleChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload>
          }
          deleteMany: {
            args: Prisma.PuzzleChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PuzzleChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PuzzleChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload>[]
          }
          upsert: {
            args: Prisma.PuzzleChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PuzzleChallengePayload>
          }
          aggregate: {
            args: Prisma.PuzzleChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePuzzleChallenge>
          }
          groupBy: {
            args: Prisma.PuzzleChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PuzzleChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PuzzleChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<PuzzleChallengeCountAggregateOutputType> | number
          }
        }
      }
      OrderingChallenge: {
        payload: Prisma.$OrderingChallengePayload<ExtArgs>
        fields: Prisma.OrderingChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderingChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderingChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload>
          }
          findFirst: {
            args: Prisma.OrderingChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderingChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload>
          }
          findMany: {
            args: Prisma.OrderingChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload>[]
          }
          create: {
            args: Prisma.OrderingChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload>
          }
          createMany: {
            args: Prisma.OrderingChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderingChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload>[]
          }
          delete: {
            args: Prisma.OrderingChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload>
          }
          update: {
            args: Prisma.OrderingChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload>
          }
          deleteMany: {
            args: Prisma.OrderingChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderingChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderingChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload>[]
          }
          upsert: {
            args: Prisma.OrderingChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingChallengePayload>
          }
          aggregate: {
            args: Prisma.OrderingChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderingChallenge>
          }
          groupBy: {
            args: Prisma.OrderingChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderingChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderingChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<OrderingChallengeCountAggregateOutputType> | number
          }
        }
      }
      OrderingItem: {
        payload: Prisma.$OrderingItemPayload<ExtArgs>
        fields: Prisma.OrderingItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderingItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderingItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload>
          }
          findFirst: {
            args: Prisma.OrderingItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderingItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload>
          }
          findMany: {
            args: Prisma.OrderingItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload>[]
          }
          create: {
            args: Prisma.OrderingItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload>
          }
          createMany: {
            args: Prisma.OrderingItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderingItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload>[]
          }
          delete: {
            args: Prisma.OrderingItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload>
          }
          update: {
            args: Prisma.OrderingItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderingItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderingItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderingItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderingItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderingItemPayload>
          }
          aggregate: {
            args: Prisma.OrderingItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderingItem>
          }
          groupBy: {
            args: Prisma.OrderingItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderingItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderingItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderingItemCountAggregateOutputType> | number
          }
        }
      }
      FillBlankChallenge: {
        payload: Prisma.$FillBlankChallengePayload<ExtArgs>
        fields: Prisma.FillBlankChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FillBlankChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FillBlankChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload>
          }
          findFirst: {
            args: Prisma.FillBlankChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FillBlankChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload>
          }
          findMany: {
            args: Prisma.FillBlankChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload>[]
          }
          create: {
            args: Prisma.FillBlankChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload>
          }
          createMany: {
            args: Prisma.FillBlankChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FillBlankChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload>[]
          }
          delete: {
            args: Prisma.FillBlankChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload>
          }
          update: {
            args: Prisma.FillBlankChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload>
          }
          deleteMany: {
            args: Prisma.FillBlankChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FillBlankChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FillBlankChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload>[]
          }
          upsert: {
            args: Prisma.FillBlankChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankChallengePayload>
          }
          aggregate: {
            args: Prisma.FillBlankChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFillBlankChallenge>
          }
          groupBy: {
            args: Prisma.FillBlankChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FillBlankChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FillBlankChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<FillBlankChallengeCountAggregateOutputType> | number
          }
        }
      }
      FillBlankQuestion: {
        payload: Prisma.$FillBlankQuestionPayload<ExtArgs>
        fields: Prisma.FillBlankQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FillBlankQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FillBlankQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload>
          }
          findFirst: {
            args: Prisma.FillBlankQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FillBlankQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload>
          }
          findMany: {
            args: Prisma.FillBlankQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload>[]
          }
          create: {
            args: Prisma.FillBlankQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload>
          }
          createMany: {
            args: Prisma.FillBlankQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FillBlankQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload>[]
          }
          delete: {
            args: Prisma.FillBlankQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload>
          }
          update: {
            args: Prisma.FillBlankQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload>
          }
          deleteMany: {
            args: Prisma.FillBlankQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FillBlankQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FillBlankQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload>[]
          }
          upsert: {
            args: Prisma.FillBlankQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FillBlankQuestionPayload>
          }
          aggregate: {
            args: Prisma.FillBlankQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFillBlankQuestion>
          }
          groupBy: {
            args: Prisma.FillBlankQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FillBlankQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FillBlankQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<FillBlankQuestionCountAggregateOutputType> | number
          }
        }
      }
      UserLessonProgress: {
        payload: Prisma.$UserLessonProgressPayload<ExtArgs>
        fields: Prisma.UserLessonProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLessonProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLessonProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          findFirst: {
            args: Prisma.UserLessonProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLessonProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          findMany: {
            args: Prisma.UserLessonProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>[]
          }
          create: {
            args: Prisma.UserLessonProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          createMany: {
            args: Prisma.UserLessonProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLessonProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>[]
          }
          delete: {
            args: Prisma.UserLessonProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          update: {
            args: Prisma.UserLessonProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserLessonProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLessonProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLessonProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserLessonProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          aggregate: {
            args: Prisma.UserLessonProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLessonProgress>
          }
          groupBy: {
            args: Prisma.UserLessonProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLessonProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLessonProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserLessonProgressCountAggregateOutputType> | number
          }
        }
      }
      ChallengeScore: {
        payload: Prisma.$ChallengeScorePayload<ExtArgs>
        fields: Prisma.ChallengeScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          findFirst: {
            args: Prisma.ChallengeScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          findMany: {
            args: Prisma.ChallengeScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]
          }
          create: {
            args: Prisma.ChallengeScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          createMany: {
            args: Prisma.ChallengeScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]
          }
          delete: {
            args: Prisma.ChallengeScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          update: {
            args: Prisma.ChallengeScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          aggregate: {
            args: Prisma.ChallengeScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeScore>
          }
          groupBy: {
            args: Prisma.ChallengeScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeScoreCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeScoreCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      UserLessonScore: {
        payload: Prisma.$UserLessonScorePayload<ExtArgs>
        fields: Prisma.UserLessonScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLessonScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLessonScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload>
          }
          findFirst: {
            args: Prisma.UserLessonScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLessonScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload>
          }
          findMany: {
            args: Prisma.UserLessonScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload>[]
          }
          create: {
            args: Prisma.UserLessonScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload>
          }
          createMany: {
            args: Prisma.UserLessonScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLessonScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload>[]
          }
          delete: {
            args: Prisma.UserLessonScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload>
          }
          update: {
            args: Prisma.UserLessonScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload>
          }
          deleteMany: {
            args: Prisma.UserLessonScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLessonScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLessonScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload>[]
          }
          upsert: {
            args: Prisma.UserLessonScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonScorePayload>
          }
          aggregate: {
            args: Prisma.UserLessonScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLessonScore>
          }
          groupBy: {
            args: Prisma.UserLessonScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLessonScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLessonScoreCountArgs<ExtArgs>
            result: $Utils.Optional<UserLessonScoreCountAggregateOutputType> | number
          }
        }
      }
      UserCourseProgress: {
        payload: Prisma.$UserCourseProgressPayload<ExtArgs>
        fields: Prisma.UserCourseProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCourseProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCourseProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          findFirst: {
            args: Prisma.UserCourseProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCourseProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          findMany: {
            args: Prisma.UserCourseProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>[]
          }
          create: {
            args: Prisma.UserCourseProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          createMany: {
            args: Prisma.UserCourseProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCourseProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>[]
          }
          delete: {
            args: Prisma.UserCourseProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          update: {
            args: Prisma.UserCourseProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserCourseProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCourseProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCourseProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserCourseProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          aggregate: {
            args: Prisma.UserCourseProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCourseProgress>
          }
          groupBy: {
            args: Prisma.UserCourseProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCourseProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCourseProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserCourseProgressCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    oTP?: OTPOmit
    category?: CategoryOmit
    product?: ProductOmit
    module?: ModuleOmit
    lesson?: LessonOmit
    enrollment?: EnrollmentOmit
    review?: ReviewOmit
    quizQuestion?: QuizQuestionOmit
    quizAnswer?: QuizAnswerOmit
    challenge?: ChallengeOmit
    challengeQuestion?: ChallengeQuestionOmit
    challengeAnswer?: ChallengeAnswerOmit
    puzzleChallenge?: PuzzleChallengeOmit
    orderingChallenge?: OrderingChallengeOmit
    orderingItem?: OrderingItemOmit
    fillBlankChallenge?: FillBlankChallengeOmit
    fillBlankQuestion?: FillBlankQuestionOmit
    userLessonProgress?: UserLessonProgressOmit
    challengeScore?: ChallengeScoreOmit
    systemSetting?: SystemSettingOmit
    userLessonScore?: UserLessonScoreOmit
    userCourseProgress?: UserCourseProgressOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    otps: number
    enrollments: number
    reviews: number
    userLessonProgress: number
    challengeScore: number
    userLessonScore: number
    userCourseProgress: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otps?: boolean | UserCountOutputTypeCountOtpsArgs
    enrollments?: boolean | UserCountOutputTypeCountEnrollmentsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    userLessonProgress?: boolean | UserCountOutputTypeCountUserLessonProgressArgs
    challengeScore?: boolean | UserCountOutputTypeCountChallengeScoreArgs
    userLessonScore?: boolean | UserCountOutputTypeCountUserLessonScoreArgs
    userCourseProgress?: boolean | UserCountOutputTypeCountUserCourseProgressArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLessonProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengeScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeScoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserLessonScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLessonScoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCourseProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseProgressWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    modules: number
    enrollments: number
    reviews: number
    userCourseProgress: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | ProductCountOutputTypeCountModulesArgs
    enrollments?: boolean | ProductCountOutputTypeCountEnrollmentsArgs
    reviews?: boolean | ProductCountOutputTypeCountReviewsArgs
    userCourseProgress?: boolean | ProductCountOutputTypeCountUserCourseProgressArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountUserCourseProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseProgressWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    lessons: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | ModuleCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    question: number
    userProgress: number
    userLessonScore: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | LessonCountOutputTypeCountQuestionArgs
    userProgress?: boolean | LessonCountOutputTypeCountUserProgressArgs
    userLessonScore?: boolean | LessonCountOutputTypeCountUserLessonScoreArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLessonProgressWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountUserLessonScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLessonScoreWhereInput
  }


  /**
   * Count Type QuizQuestionCountOutputType
   */

  export type QuizQuestionCountOutputType = {
    answers: number
  }

  export type QuizQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuizQuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionCountOutputType
     */
    select?: QuizQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
  }


  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    questions: number
    challengeScore: number
  }

  export type ChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ChallengeCountOutputTypeCountQuestionsArgs
    challengeScore?: boolean | ChallengeCountOutputTypeCountChallengeScoreArgs
  }

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeQuestionWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountChallengeScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeScoreWhereInput
  }


  /**
   * Count Type ChallengeQuestionCountOutputType
   */

  export type ChallengeQuestionCountOutputType = {
    answers: number
  }

  export type ChallengeQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | ChallengeQuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * ChallengeQuestionCountOutputType without action
   */
  export type ChallengeQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestionCountOutputType
     */
    select?: ChallengeQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeQuestionCountOutputType without action
   */
  export type ChallengeQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeAnswerWhereInput
  }


  /**
   * Count Type OrderingChallengeCountOutputType
   */

  export type OrderingChallengeCountOutputType = {
    items: number
  }

  export type OrderingChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderingChallengeCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderingChallengeCountOutputType without action
   */
  export type OrderingChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallengeCountOutputType
     */
    select?: OrderingChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderingChallengeCountOutputType without action
   */
  export type OrderingChallengeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderingItemWhereInput
  }


  /**
   * Count Type FillBlankChallengeCountOutputType
   */

  export type FillBlankChallengeCountOutputType = {
    questions: number
  }

  export type FillBlankChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | FillBlankChallengeCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * FillBlankChallengeCountOutputType without action
   */
  export type FillBlankChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallengeCountOutputType
     */
    select?: FillBlankChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FillBlankChallengeCountOutputType without action
   */
  export type FillBlankChallengeCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FillBlankQuestionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    age: number | null
  }

  export type UserSumAggregateOutputType = {
    age: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    fullName: string | null
    password: string | null
    avatar: string | null
    isVerified: boolean | null
    role: string | null
    age: number | null
    grade: $Enums.Grade | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    fullName: string | null
    password: string | null
    avatar: string | null
    isVerified: boolean | null
    role: string | null
    age: number | null
    grade: $Enums.Grade | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    fullName: number
    password: number
    avatar: number
    isVerified: number
    role: number
    age: number
    grade: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    age?: true
  }

  export type UserSumAggregateInputType = {
    age?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    fullName?: true
    password?: true
    avatar?: true
    isVerified?: true
    role?: true
    age?: true
    grade?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    fullName?: true
    password?: true
    avatar?: true
    isVerified?: true
    role?: true
    age?: true
    grade?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    fullName?: true
    password?: true
    avatar?: true
    isVerified?: true
    role?: true
    age?: true
    grade?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    email: string
    fullName: string
    password: string
    avatar: string | null
    isVerified: boolean
    role: string
    age: number | null
    grade: $Enums.Grade | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    fullName?: boolean
    password?: boolean
    avatar?: boolean
    isVerified?: boolean
    role?: boolean
    age?: boolean
    grade?: boolean
    otps?: boolean | User$otpsArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    userLessonProgress?: boolean | User$userLessonProgressArgs<ExtArgs>
    challengeScore?: boolean | User$challengeScoreArgs<ExtArgs>
    userLessonScore?: boolean | User$userLessonScoreArgs<ExtArgs>
    userCourseProgress?: boolean | User$userCourseProgressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    fullName?: boolean
    password?: boolean
    avatar?: boolean
    isVerified?: boolean
    role?: boolean
    age?: boolean
    grade?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    fullName?: boolean
    password?: boolean
    avatar?: boolean
    isVerified?: boolean
    role?: boolean
    age?: boolean
    grade?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    fullName?: boolean
    password?: boolean
    avatar?: boolean
    isVerified?: boolean
    role?: boolean
    age?: boolean
    grade?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "email" | "fullName" | "password" | "avatar" | "isVerified" | "role" | "age" | "grade", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otps?: boolean | User$otpsArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    userLessonProgress?: boolean | User$userLessonProgressArgs<ExtArgs>
    challengeScore?: boolean | User$challengeScoreArgs<ExtArgs>
    userLessonScore?: boolean | User$userLessonScoreArgs<ExtArgs>
    userCourseProgress?: boolean | User$userCourseProgressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      otps: Prisma.$OTPPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      userLessonProgress: Prisma.$UserLessonProgressPayload<ExtArgs>[]
      challengeScore: Prisma.$ChallengeScorePayload<ExtArgs>[]
      userLessonScore: Prisma.$UserLessonScorePayload<ExtArgs>[]
      userCourseProgress: Prisma.$UserCourseProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      email: string
      fullName: string
      password: string
      avatar: string | null
      isVerified: boolean
      role: string
      age: number | null
      grade: $Enums.Grade | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    otps<T extends User$otpsArgs<ExtArgs> = {}>(args?: Subset<T, User$otpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends User$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userLessonProgress<T extends User$userLessonProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$userLessonProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challengeScore<T extends User$challengeScoreArgs<ExtArgs> = {}>(args?: Subset<T, User$challengeScoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userLessonScore<T extends User$userLessonScoreArgs<ExtArgs> = {}>(args?: Subset<T, User$userLessonScoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userCourseProgress<T extends User$userCourseProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$userCourseProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly age: FieldRef<"User", 'Int'>
    readonly grade: FieldRef<"User", 'Grade'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.otps
   */
  export type User$otpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    where?: OTPWhereInput
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    cursor?: OTPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * User.enrollments
   */
  export type User$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.userLessonProgress
   */
  export type User$userLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    where?: UserLessonProgressWhereInput
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    cursor?: UserLessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * User.challengeScore
   */
  export type User$challengeScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    where?: ChallengeScoreWhereInput
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    cursor?: ChallengeScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScoreScalarFieldEnum | ChallengeScoreScalarFieldEnum[]
  }

  /**
   * User.userLessonScore
   */
  export type User$userLessonScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    where?: UserLessonScoreWhereInput
    orderBy?: UserLessonScoreOrderByWithRelationInput | UserLessonScoreOrderByWithRelationInput[]
    cursor?: UserLessonScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLessonScoreScalarFieldEnum | UserLessonScoreScalarFieldEnum[]
  }

  /**
   * User.userCourseProgress
   */
  export type User$userCourseProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    where?: UserCourseProgressWhereInput
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    cursor?: UserCourseProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model OTP
   */

  export type AggregateOTP = {
    _count: OTPCountAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  export type OTPMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    expiresAt: Date | null
    code: string | null
    isUsed: boolean | null
    userId: string | null
  }

  export type OTPMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    expiresAt: Date | null
    code: string | null
    isUsed: boolean | null
    userId: string | null
  }

  export type OTPCountAggregateOutputType = {
    id: number
    createdAt: number
    expiresAt: number
    code: number
    isUsed: number
    userId: number
    _all: number
  }


  export type OTPMinAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    code?: true
    isUsed?: true
    userId?: true
  }

  export type OTPMaxAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    code?: true
    isUsed?: true
    userId?: true
  }

  export type OTPCountAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    code?: true
    isUsed?: true
    userId?: true
    _all?: true
  }

  export type OTPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTP to aggregate.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTPS
    **/
    _count?: true | OTPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTPMaxAggregateInputType
  }

  export type GetOTPAggregateType<T extends OTPAggregateArgs> = {
        [P in keyof T & keyof AggregateOTP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOTP[P]>
      : GetScalarType<T[P], AggregateOTP[P]>
  }




  export type OTPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPWhereInput
    orderBy?: OTPOrderByWithAggregationInput | OTPOrderByWithAggregationInput[]
    by: OTPScalarFieldEnum[] | OTPScalarFieldEnum
    having?: OTPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTPCountAggregateInputType | true
    _min?: OTPMinAggregateInputType
    _max?: OTPMaxAggregateInputType
  }

  export type OTPGroupByOutputType = {
    id: string
    createdAt: Date
    expiresAt: Date
    code: string
    isUsed: boolean
    userId: string
    _count: OTPCountAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  type GetOTPGroupByPayload<T extends OTPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OTPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OTPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OTPGroupByOutputType[P]>
            : GetScalarType<T[P], OTPGroupByOutputType[P]>
        }
      >
    >


  export type OTPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    code?: boolean
    isUsed?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    code?: boolean
    isUsed?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    code?: boolean
    isUsed?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectScalar = {
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    code?: boolean
    isUsed?: boolean
    userId?: boolean
  }

  export type OTPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "expiresAt" | "code" | "isUsed" | "userId", ExtArgs["result"]["oTP"]>
  export type OTPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OTPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OTPIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OTPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OTP"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      expiresAt: Date
      code: string
      isUsed: boolean
      userId: string
    }, ExtArgs["result"]["oTP"]>
    composites: {}
  }

  type OTPGetPayload<S extends boolean | null | undefined | OTPDefaultArgs> = $Result.GetResult<Prisma.$OTPPayload, S>

  type OTPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OTPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OTPCountAggregateInputType | true
    }

  export interface OTPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OTP'], meta: { name: 'OTP' } }
    /**
     * Find zero or one OTP that matches the filter.
     * @param {OTPFindUniqueArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OTPFindUniqueArgs>(args: SelectSubset<T, OTPFindUniqueArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OTP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OTPFindUniqueOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OTPFindUniqueOrThrowArgs>(args: SelectSubset<T, OTPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OTPFindFirstArgs>(args?: SelectSubset<T, OTPFindFirstArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OTPFindFirstOrThrowArgs>(args?: SelectSubset<T, OTPFindFirstOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OTPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTPS
     * const oTPS = await prisma.oTP.findMany()
     * 
     * // Get first 10 OTPS
     * const oTPS = await prisma.oTP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTPWithIdOnly = await prisma.oTP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OTPFindManyArgs>(args?: SelectSubset<T, OTPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OTP.
     * @param {OTPCreateArgs} args - Arguments to create a OTP.
     * @example
     * // Create one OTP
     * const OTP = await prisma.oTP.create({
     *   data: {
     *     // ... data to create a OTP
     *   }
     * })
     * 
     */
    create<T extends OTPCreateArgs>(args: SelectSubset<T, OTPCreateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OTPS.
     * @param {OTPCreateManyArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OTPCreateManyArgs>(args?: SelectSubset<T, OTPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OTPS and returns the data saved in the database.
     * @param {OTPCreateManyAndReturnArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OTPS and only return the `id`
     * const oTPWithIdOnly = await prisma.oTP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OTPCreateManyAndReturnArgs>(args?: SelectSubset<T, OTPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OTP.
     * @param {OTPDeleteArgs} args - Arguments to delete one OTP.
     * @example
     * // Delete one OTP
     * const OTP = await prisma.oTP.delete({
     *   where: {
     *     // ... filter to delete one OTP
     *   }
     * })
     * 
     */
    delete<T extends OTPDeleteArgs>(args: SelectSubset<T, OTPDeleteArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OTP.
     * @param {OTPUpdateArgs} args - Arguments to update one OTP.
     * @example
     * // Update one OTP
     * const oTP = await prisma.oTP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OTPUpdateArgs>(args: SelectSubset<T, OTPUpdateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OTPS.
     * @param {OTPDeleteManyArgs} args - Arguments to filter OTPS to delete.
     * @example
     * // Delete a few OTPS
     * const { count } = await prisma.oTP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OTPDeleteManyArgs>(args?: SelectSubset<T, OTPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OTPUpdateManyArgs>(args: SelectSubset<T, OTPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS and returns the data updated in the database.
     * @param {OTPUpdateManyAndReturnArgs} args - Arguments to update many OTPS.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OTPS and only return the `id`
     * const oTPWithIdOnly = await prisma.oTP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OTPUpdateManyAndReturnArgs>(args: SelectSubset<T, OTPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OTP.
     * @param {OTPUpsertArgs} args - Arguments to update or create a OTP.
     * @example
     * // Update or create a OTP
     * const oTP = await prisma.oTP.upsert({
     *   create: {
     *     // ... data to create a OTP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OTP we want to update
     *   }
     * })
     */
    upsert<T extends OTPUpsertArgs>(args: SelectSubset<T, OTPUpsertArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCountArgs} args - Arguments to filter OTPS to count.
     * @example
     * // Count the number of OTPS
     * const count = await prisma.oTP.count({
     *   where: {
     *     // ... the filter for the OTPS we want to count
     *   }
     * })
    **/
    count<T extends OTPCountArgs>(
      args?: Subset<T, OTPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTPAggregateArgs>(args: Subset<T, OTPAggregateArgs>): Prisma.PrismaPromise<GetOTPAggregateType<T>>

    /**
     * Group by OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTPGroupByArgs['orderBy'] }
        : { orderBy?: OTPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OTP model
   */
  readonly fields: OTPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OTP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OTPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OTP model
   */
  interface OTPFieldRefs {
    readonly id: FieldRef<"OTP", 'String'>
    readonly createdAt: FieldRef<"OTP", 'DateTime'>
    readonly expiresAt: FieldRef<"OTP", 'DateTime'>
    readonly code: FieldRef<"OTP", 'String'>
    readonly isUsed: FieldRef<"OTP", 'Boolean'>
    readonly userId: FieldRef<"OTP", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OTP findUnique
   */
  export type OTPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findUniqueOrThrow
   */
  export type OTPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findFirst
   */
  export type OTPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findFirstOrThrow
   */
  export type OTPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findMany
   */
  export type OTPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTPS to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP create
   */
  export type OTPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * The data needed to create a OTP.
     */
    data: XOR<OTPCreateInput, OTPUncheckedCreateInput>
  }

  /**
   * OTP createMany
   */
  export type OTPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTP createManyAndReturn
   */
  export type OTPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OTP update
   */
  export type OTPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * The data needed to update a OTP.
     */
    data: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
    /**
     * Choose, which OTP to update.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP updateMany
   */
  export type OTPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OTPS.
     */
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    /**
     * Filter which OTPS to update
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to update.
     */
    limit?: number
  }

  /**
   * OTP updateManyAndReturn
   */
  export type OTPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data used to update OTPS.
     */
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    /**
     * Filter which OTPS to update
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OTP upsert
   */
  export type OTPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * The filter to search for the OTP to update in case it exists.
     */
    where: OTPWhereUniqueInput
    /**
     * In case the OTP found by the `where` argument doesn't exist, create a new OTP with this data.
     */
    create: XOR<OTPCreateInput, OTPUncheckedCreateInput>
    /**
     * In case the OTP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
  }

  /**
   * OTP delete
   */
  export type OTPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter which OTP to delete.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP deleteMany
   */
  export type OTPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTPS to delete
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to delete.
     */
    limit?: number
  }

  /**
   * OTP without action
   */
  export type OTPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    short_description: string | null
    status: $Enums.CategoryStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    short_description: string | null
    status: $Enums.CategoryStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    short_description: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    short_description?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    short_description?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    short_description?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    title: string
    slug: string
    short_description: string
    status: $Enums.CategoryStatus
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    short_description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    short_description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    short_description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    short_description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "short_description" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      short_description: string
      status: $Enums.CategoryStatus
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly title: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly short_description: FieldRef<"Category", 'String'>
    readonly status: FieldRef<"Category", 'CategoryStatus'>
    readonly created_at: FieldRef<"Category", 'DateTime'>
    readonly updated_at: FieldRef<"Category", 'DateTime'>
    readonly deleted_at: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    short_description: string | null
    description: string | null
    category_id: string | null
    thumbnail: string | null
    label: $Enums.ProductLabel | null
    status: $Enums.ProductStatus | null
    requirements: string | null
    learning_outcomes: string | null
    preview_video: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    short_description: string | null
    description: string | null
    category_id: string | null
    thumbnail: string | null
    label: $Enums.ProductLabel | null
    status: $Enums.ProductStatus | null
    requirements: string | null
    learning_outcomes: string | null
    preview_video: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    short_description: number
    description: number
    category_id: number
    thumbnail: number
    label: number
    status: number
    requirements: number
    learning_outcomes: number
    preview_video: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    short_description?: true
    description?: true
    category_id?: true
    thumbnail?: true
    label?: true
    status?: true
    requirements?: true
    learning_outcomes?: true
    preview_video?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    short_description?: true
    description?: true
    category_id?: true
    thumbnail?: true
    label?: true
    status?: true
    requirements?: true
    learning_outcomes?: true
    preview_video?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    short_description?: true
    description?: true
    category_id?: true
    thumbnail?: true
    label?: true
    status?: true
    requirements?: true
    learning_outcomes?: true
    preview_video?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    title: string
    slug: string
    short_description: string
    description: string | null
    category_id: string
    thumbnail: string
    label: $Enums.ProductLabel
    status: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    short_description?: boolean
    description?: boolean
    category_id?: boolean
    thumbnail?: boolean
    label?: boolean
    status?: boolean
    requirements?: boolean
    learning_outcomes?: boolean
    preview_video?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    modules?: boolean | Product$modulesArgs<ExtArgs>
    enrollments?: boolean | Product$enrollmentsArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    userCourseProgress?: boolean | Product$userCourseProgressArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    short_description?: boolean
    description?: boolean
    category_id?: boolean
    thumbnail?: boolean
    label?: boolean
    status?: boolean
    requirements?: boolean
    learning_outcomes?: boolean
    preview_video?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    short_description?: boolean
    description?: boolean
    category_id?: boolean
    thumbnail?: boolean
    label?: boolean
    status?: boolean
    requirements?: boolean
    learning_outcomes?: boolean
    preview_video?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    short_description?: boolean
    description?: boolean
    category_id?: boolean
    thumbnail?: boolean
    label?: boolean
    status?: boolean
    requirements?: boolean
    learning_outcomes?: boolean
    preview_video?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "short_description" | "description" | "category_id" | "thumbnail" | "label" | "status" | "requirements" | "learning_outcomes" | "preview_video" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    modules?: boolean | Product$modulesArgs<ExtArgs>
    enrollments?: boolean | Product$enrollmentsArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    userCourseProgress?: boolean | Product$userCourseProgressArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      modules: Prisma.$ModulePayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      userCourseProgress: Prisma.$UserCourseProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      short_description: string
      description: string | null
      category_id: string
      thumbnail: string
      label: $Enums.ProductLabel
      status: $Enums.ProductStatus
      requirements: string
      learning_outcomes: string
      preview_video: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    modules<T extends Product$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Product$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Product$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Product$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Product$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userCourseProgress<T extends Product$userCourseProgressArgs<ExtArgs> = {}>(args?: Subset<T, Product$userCourseProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly short_description: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly category_id: FieldRef<"Product", 'String'>
    readonly thumbnail: FieldRef<"Product", 'String'>
    readonly label: FieldRef<"Product", 'ProductLabel'>
    readonly status: FieldRef<"Product", 'ProductStatus'>
    readonly requirements: FieldRef<"Product", 'String'>
    readonly learning_outcomes: FieldRef<"Product", 'String'>
    readonly preview_video: FieldRef<"Product", 'String'>
    readonly created_at: FieldRef<"Product", 'DateTime'>
    readonly updated_at: FieldRef<"Product", 'DateTime'>
    readonly deleted_at: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.modules
   */
  export type Product$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Product.enrollments
   */
  export type Product$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Product.reviews
   */
  export type Product$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Product.userCourseProgress
   */
  export type Product$userCourseProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    where?: UserCourseProgressWhereInput
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    cursor?: UserCourseProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    order: number | null
  }

  export type ModuleSumAggregateOutputType = {
    order: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    course_id: string | null
    title: string | null
    short_description: string | null
    order: number | null
    status: $Enums.ModuleStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    course_id: string | null
    title: string | null
    short_description: string | null
    order: number | null
    status: $Enums.ModuleStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    course_id: number
    title: number
    short_description: number
    order: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    order?: true
  }

  export type ModuleSumAggregateInputType = {
    order?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    course_id?: true
    title?: true
    short_description?: true
    order?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    course_id?: true
    title?: true
    short_description?: true
    order?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    course_id?: true
    title?: true
    short_description?: true
    order?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    course_id: string
    title: string
    short_description: string
    order: number
    status: $Enums.ModuleStatus
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    title?: boolean
    short_description?: boolean
    order?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    course?: boolean | ProductDefaultArgs<ExtArgs>
    lessons?: boolean | Module$lessonsArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    title?: boolean
    short_description?: boolean
    order?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    title?: boolean
    short_description?: boolean
    order?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    course_id?: boolean
    title?: boolean
    short_description?: boolean
    order?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "course_id" | "title" | "short_description" | "order" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | ProductDefaultArgs<ExtArgs>
    lessons?: boolean | Module$lessonsArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      course: Prisma.$ProductPayload<ExtArgs>
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      course_id: string
      title: string
      short_description: string
      order: number
      status: $Enums.ModuleStatus
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lessons<T extends Module$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Module$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly course_id: FieldRef<"Module", 'String'>
    readonly title: FieldRef<"Module", 'String'>
    readonly short_description: FieldRef<"Module", 'String'>
    readonly order: FieldRef<"Module", 'Int'>
    readonly status: FieldRef<"Module", 'ModuleStatus'>
    readonly created_at: FieldRef<"Module", 'DateTime'>
    readonly updated_at: FieldRef<"Module", 'DateTime'>
    readonly deleted_at: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.lessons
   */
  export type Module$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    order: number | null
  }

  export type LessonSumAggregateOutputType = {
    order: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    module_id: string | null
    title: string | null
    description: string | null
    type: $Enums.LessonType | null
    is_previewable: boolean | null
    status: $Enums.LessonStatus | null
    order: number | null
    attachment: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    module_id: string | null
    title: string | null
    description: string | null
    type: $Enums.LessonType | null
    is_previewable: boolean | null
    status: $Enums.LessonStatus | null
    order: number | null
    attachment: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    module_id: number
    title: number
    description: number
    type: number
    is_previewable: number
    status: number
    order: number
    attachment: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    order?: true
  }

  export type LessonSumAggregateInputType = {
    order?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    module_id?: true
    title?: true
    description?: true
    type?: true
    is_previewable?: true
    status?: true
    order?: true
    attachment?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    module_id?: true
    title?: true
    description?: true
    type?: true
    is_previewable?: true
    status?: true
    order?: true
    attachment?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    module_id?: true
    title?: true
    description?: true
    type?: true
    is_previewable?: true
    status?: true
    order?: true
    attachment?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    module_id: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable: boolean
    status: $Enums.LessonStatus
    order: number
    attachment: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    module_id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    is_previewable?: boolean
    status?: boolean
    order?: boolean
    attachment?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    question?: boolean | Lesson$questionArgs<ExtArgs>
    userProgress?: boolean | Lesson$userProgressArgs<ExtArgs>
    userLessonScore?: boolean | Lesson$userLessonScoreArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    module_id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    is_previewable?: boolean
    status?: boolean
    order?: boolean
    attachment?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    module_id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    is_previewable?: boolean
    status?: boolean
    order?: boolean
    attachment?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    module_id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    is_previewable?: boolean
    status?: boolean
    order?: boolean
    attachment?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "module_id" | "title" | "description" | "type" | "is_previewable" | "status" | "order" | "attachment" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    question?: boolean | Lesson$questionArgs<ExtArgs>
    userProgress?: boolean | Lesson$userProgressArgs<ExtArgs>
    userLessonScore?: boolean | Lesson$userLessonScoreArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      question: Prisma.$QuizQuestionPayload<ExtArgs>[]
      userProgress: Prisma.$UserLessonProgressPayload<ExtArgs>[]
      userLessonScore: Prisma.$UserLessonScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      module_id: string
      title: string
      description: string
      type: $Enums.LessonType
      is_previewable: boolean
      status: $Enums.LessonStatus
      order: number
      attachment: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends Lesson$questionArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$questionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProgress<T extends Lesson$userProgressArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$userProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userLessonScore<T extends Lesson$userLessonScoreArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$userLessonScoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly module_id: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly description: FieldRef<"Lesson", 'String'>
    readonly type: FieldRef<"Lesson", 'LessonType'>
    readonly is_previewable: FieldRef<"Lesson", 'Boolean'>
    readonly status: FieldRef<"Lesson", 'LessonStatus'>
    readonly order: FieldRef<"Lesson", 'Int'>
    readonly attachment: FieldRef<"Lesson", 'String'>
    readonly created_at: FieldRef<"Lesson", 'DateTime'>
    readonly updated_at: FieldRef<"Lesson", 'DateTime'>
    readonly deleted_at: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.question
   */
  export type Lesson$questionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * Lesson.userProgress
   */
  export type Lesson$userProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    where?: UserLessonProgressWhereInput
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    cursor?: UserLessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * Lesson.userLessonScore
   */
  export type Lesson$userLessonScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    where?: UserLessonScoreWhereInput
    orderBy?: UserLessonScoreOrderByWithRelationInput | UserLessonScoreOrderByWithRelationInput[]
    cursor?: UserLessonScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLessonScoreScalarFieldEnum | UserLessonScoreScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    product_id: string | null
    created_at: Date | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    product_id: string | null
    created_at: Date | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    user_id: number
    product_id: number
    created_at: number
    _all: number
  }


  export type EnrollmentMinAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
    created_at?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
    created_at?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
    created_at?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    user_id: string
    product_id: string
    created_at: Date
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    created_at?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    created_at?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    created_at?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    created_at?: boolean
  }

  export type EnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "product_id" | "created_at", ExtArgs["result"]["enrollment"]>
  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      product_id: string
      created_at: Date
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {EnrollmentUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly user_id: FieldRef<"Enrollment", 'String'>
    readonly product_id: FieldRef<"Enrollment", 'String'>
    readonly created_at: FieldRef<"Enrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
  }

  /**
   * Enrollment updateManyAndReturn
   */
  export type EnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    product_id: string | null
    rating: number | null
    comment: string | null
    status: boolean | null
    created_at: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    product_id: string | null
    rating: number | null
    comment: string | null
    status: boolean | null
    created_at: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    user_id: number
    product_id: number
    rating: number
    comment: number
    status: number
    created_at: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
    rating?: true
    comment?: true
    status?: true
    created_at?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
    rating?: true
    comment?: true
    status?: true
    created_at?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
    rating?: true
    comment?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    user_id: string
    product_id: string
    rating: number
    comment: string | null
    status: boolean
    created_at: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    rating?: boolean
    comment?: boolean
    status?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    rating?: boolean
    comment?: boolean
    status?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    rating?: boolean
    comment?: boolean
    status?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    rating?: boolean
    comment?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "product_id" | "rating" | "comment" | "status" | "created_at", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      product_id: string
      rating: number
      comment: string | null
      status: boolean
      created_at: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly user_id: FieldRef<"Review", 'String'>
    readonly product_id: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly status: FieldRef<"Review", 'Boolean'>
    readonly created_at: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: string | null
    lesson_id: string | null
    question: string | null
    explanation: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: string | null
    lesson_id: string | null
    question: string | null
    explanation: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    lesson_id: number
    question: number
    explanation: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type QuizQuestionMinAggregateInputType = {
    id?: true
    lesson_id?: true
    question?: true
    explanation?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    lesson_id?: true
    question?: true
    explanation?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    lesson_id?: true
    question?: true
    explanation?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: string
    lesson_id: string
    question: string
    explanation: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: QuizQuestionCountAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    question?: boolean
    explanation?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    answers?: boolean | QuizQuestion$answersArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    question?: boolean
    explanation?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    question?: boolean
    explanation?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectScalar = {
    id?: boolean
    lesson_id?: boolean
    question?: boolean
    explanation?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lesson_id" | "question" | "explanation" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["quizQuestion"]>
  export type QuizQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    answers?: boolean | QuizQuestion$answersArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      answers: Prisma.$QuizAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lesson_id: string
      question: string
      explanation: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions and returns the data updated in the database.
     * @param {QuizQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestions.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends QuizQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'String'>
    readonly lesson_id: FieldRef<"QuizQuestion", 'String'>
    readonly question: FieldRef<"QuizQuestion", 'String'>
    readonly explanation: FieldRef<"QuizQuestion", 'String'>
    readonly created_at: FieldRef<"QuizQuestion", 'DateTime'>
    readonly updated_at: FieldRef<"QuizQuestion", 'DateTime'>
    readonly deleted_at: FieldRef<"QuizQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestion updateManyAndReturn
   */
  export type QuizQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestion.answers
   */
  export type QuizQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    cursor?: QuizAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuizAnswer
   */

  export type AggregateQuizAnswer = {
    _count: QuizAnswerCountAggregateOutputType | null
    _min: QuizAnswerMinAggregateOutputType | null
    _max: QuizAnswerMaxAggregateOutputType | null
  }

  export type QuizAnswerMinAggregateOutputType = {
    id: string | null
    quiz_question_id: string | null
    answer: string | null
    is_correct: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type QuizAnswerMaxAggregateOutputType = {
    id: string | null
    quiz_question_id: string | null
    answer: string | null
    is_correct: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type QuizAnswerCountAggregateOutputType = {
    id: number
    quiz_question_id: number
    answer: number
    is_correct: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type QuizAnswerMinAggregateInputType = {
    id?: true
    quiz_question_id?: true
    answer?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type QuizAnswerMaxAggregateInputType = {
    id?: true
    quiz_question_id?: true
    answer?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type QuizAnswerCountAggregateInputType = {
    id?: true
    quiz_question_id?: true
    answer?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type QuizAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAnswer to aggregate.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAnswers
    **/
    _count?: true | QuizAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAnswerMaxAggregateInputType
  }

  export type GetQuizAnswerAggregateType<T extends QuizAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAnswer[P]>
      : GetScalarType<T[P], AggregateQuizAnswer[P]>
  }




  export type QuizAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithAggregationInput | QuizAnswerOrderByWithAggregationInput[]
    by: QuizAnswerScalarFieldEnum[] | QuizAnswerScalarFieldEnum
    having?: QuizAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAnswerCountAggregateInputType | true
    _min?: QuizAnswerMinAggregateInputType
    _max?: QuizAnswerMaxAggregateInputType
  }

  export type QuizAnswerGroupByOutputType = {
    id: string
    quiz_question_id: string
    answer: string
    is_correct: boolean
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: QuizAnswerCountAggregateOutputType | null
    _min: QuizAnswerMinAggregateOutputType | null
    _max: QuizAnswerMaxAggregateOutputType | null
  }

  type GetQuizAnswerGroupByPayload<T extends QuizAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuizAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_question_id?: boolean
    answer?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    quiz_question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_question_id?: boolean
    answer?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    quiz_question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_question_id?: boolean
    answer?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    quiz_question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectScalar = {
    id?: boolean
    quiz_question_id?: boolean
    answer?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type QuizAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quiz_question_id" | "answer" | "is_correct" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["quizAnswer"]>
  export type QuizAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz_question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }
  export type QuizAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz_question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }
  export type QuizAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz_question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }

  export type $QuizAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAnswer"
    objects: {
      quiz_question: Prisma.$QuizQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quiz_question_id: string
      answer: string
      is_correct: boolean
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["quizAnswer"]>
    composites: {}
  }

  type QuizAnswerGetPayload<S extends boolean | null | undefined | QuizAnswerDefaultArgs> = $Result.GetResult<Prisma.$QuizAnswerPayload, S>

  type QuizAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAnswerCountAggregateInputType | true
    }

  export interface QuizAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAnswer'], meta: { name: 'QuizAnswer' } }
    /**
     * Find zero or one QuizAnswer that matches the filter.
     * @param {QuizAnswerFindUniqueArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAnswerFindUniqueArgs>(args: SelectSubset<T, QuizAnswerFindUniqueArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindFirstArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAnswerFindFirstArgs>(args?: SelectSubset<T, QuizAnswerFindFirstArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindFirstOrThrowArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAnswers
     * const quizAnswers = await prisma.quizAnswer.findMany()
     * 
     * // Get first 10 QuizAnswers
     * const quizAnswers = await prisma.quizAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAnswerWithIdOnly = await prisma.quizAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAnswerFindManyArgs>(args?: SelectSubset<T, QuizAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizAnswer.
     * @param {QuizAnswerCreateArgs} args - Arguments to create a QuizAnswer.
     * @example
     * // Create one QuizAnswer
     * const QuizAnswer = await prisma.quizAnswer.create({
     *   data: {
     *     // ... data to create a QuizAnswer
     *   }
     * })
     * 
     */
    create<T extends QuizAnswerCreateArgs>(args: SelectSubset<T, QuizAnswerCreateArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizAnswers.
     * @param {QuizAnswerCreateManyArgs} args - Arguments to create many QuizAnswers.
     * @example
     * // Create many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAnswerCreateManyArgs>(args?: SelectSubset<T, QuizAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAnswers and returns the data saved in the database.
     * @param {QuizAnswerCreateManyAndReturnArgs} args - Arguments to create many QuizAnswers.
     * @example
     * // Create many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAnswers and only return the `id`
     * const quizAnswerWithIdOnly = await prisma.quizAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizAnswer.
     * @param {QuizAnswerDeleteArgs} args - Arguments to delete one QuizAnswer.
     * @example
     * // Delete one QuizAnswer
     * const QuizAnswer = await prisma.quizAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuizAnswer
     *   }
     * })
     * 
     */
    delete<T extends QuizAnswerDeleteArgs>(args: SelectSubset<T, QuizAnswerDeleteArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizAnswer.
     * @param {QuizAnswerUpdateArgs} args - Arguments to update one QuizAnswer.
     * @example
     * // Update one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAnswerUpdateArgs>(args: SelectSubset<T, QuizAnswerUpdateArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizAnswers.
     * @param {QuizAnswerDeleteManyArgs} args - Arguments to filter QuizAnswers to delete.
     * @example
     * // Delete a few QuizAnswers
     * const { count } = await prisma.quizAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAnswerDeleteManyArgs>(args?: SelectSubset<T, QuizAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAnswerUpdateManyArgs>(args: SelectSubset<T, QuizAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAnswers and returns the data updated in the database.
     * @param {QuizAnswerUpdateManyAndReturnArgs} args - Arguments to update many QuizAnswers.
     * @example
     * // Update many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAnswers and only return the `id`
     * const quizAnswerWithIdOnly = await prisma.quizAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizAnswer.
     * @param {QuizAnswerUpsertArgs} args - Arguments to update or create a QuizAnswer.
     * @example
     * // Update or create a QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.upsert({
     *   create: {
     *     // ... data to create a QuizAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAnswer we want to update
     *   }
     * })
     */
    upsert<T extends QuizAnswerUpsertArgs>(args: SelectSubset<T, QuizAnswerUpsertArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerCountArgs} args - Arguments to filter QuizAnswers to count.
     * @example
     * // Count the number of QuizAnswers
     * const count = await prisma.quizAnswer.count({
     *   where: {
     *     // ... the filter for the QuizAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuizAnswerCountArgs>(
      args?: Subset<T, QuizAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAnswerAggregateArgs>(args: Subset<T, QuizAnswerAggregateArgs>): Prisma.PrismaPromise<GetQuizAnswerAggregateType<T>>

    /**
     * Group by QuizAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuizAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAnswer model
   */
  readonly fields: QuizAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz_question<T extends QuizQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionDefaultArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAnswer model
   */
  interface QuizAnswerFieldRefs {
    readonly id: FieldRef<"QuizAnswer", 'String'>
    readonly quiz_question_id: FieldRef<"QuizAnswer", 'String'>
    readonly answer: FieldRef<"QuizAnswer", 'String'>
    readonly is_correct: FieldRef<"QuizAnswer", 'Boolean'>
    readonly created_at: FieldRef<"QuizAnswer", 'DateTime'>
    readonly updated_at: FieldRef<"QuizAnswer", 'DateTime'>
    readonly deleted_at: FieldRef<"QuizAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizAnswer findUnique
   */
  export type QuizAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer findUniqueOrThrow
   */
  export type QuizAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer findFirst
   */
  export type QuizAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAnswers.
     */
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer findFirstOrThrow
   */
  export type QuizAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAnswers.
     */
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer findMany
   */
  export type QuizAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswers to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer create
   */
  export type QuizAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAnswer.
     */
    data: XOR<QuizAnswerCreateInput, QuizAnswerUncheckedCreateInput>
  }

  /**
   * QuizAnswer createMany
   */
  export type QuizAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAnswers.
     */
    data: QuizAnswerCreateManyInput | QuizAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAnswer createManyAndReturn
   */
  export type QuizAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAnswers.
     */
    data: QuizAnswerCreateManyInput | QuizAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAnswer update
   */
  export type QuizAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAnswer.
     */
    data: XOR<QuizAnswerUpdateInput, QuizAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuizAnswer to update.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer updateMany
   */
  export type QuizAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAnswers.
     */
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuizAnswers to update
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to update.
     */
    limit?: number
  }

  /**
   * QuizAnswer updateManyAndReturn
   */
  export type QuizAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * The data used to update QuizAnswers.
     */
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuizAnswers to update
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAnswer upsert
   */
  export type QuizAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAnswer to update in case it exists.
     */
    where: QuizAnswerWhereUniqueInput
    /**
     * In case the QuizAnswer found by the `where` argument doesn't exist, create a new QuizAnswer with this data.
     */
    create: XOR<QuizAnswerCreateInput, QuizAnswerUncheckedCreateInput>
    /**
     * In case the QuizAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAnswerUpdateInput, QuizAnswerUncheckedUpdateInput>
  }

  /**
   * QuizAnswer delete
   */
  export type QuizAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter which QuizAnswer to delete.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer deleteMany
   */
  export type QuizAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAnswers to delete
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to delete.
     */
    limit?: number
  }

  /**
   * QuizAnswer without action
   */
  export type QuizAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    order: number | null
  }

  export type ChallengeSumAggregateOutputType = {
    order: number | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    type: $Enums.ChallengeType | null
    order: number | null
    status: $Enums.ChallengeStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    type: $Enums.ChallengeType | null
    order: number | null
    status: $Enums.ChallengeStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    type: number
    order: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    order?: true
  }

  export type ChallengeSumAggregateInputType = {
    order?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    type?: true
    order?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    type?: true
    order?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    type?: true
    order?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string | null
    type: $Enums.ChallengeType
    order: number
    status: $Enums.ChallengeStatus
    created_at: Date
    updated_at: Date
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    order?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    questions?: boolean | Challenge$questionsArgs<ExtArgs>
    challengeScore?: boolean | Challenge$challengeScoreArgs<ExtArgs>
    puzzleChallenge?: boolean | Challenge$puzzleChallengeArgs<ExtArgs>
    orderingChallenge?: boolean | Challenge$orderingChallengeArgs<ExtArgs>
    fillBlankChallenge?: boolean | Challenge$fillBlankChallengeArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    order?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    order?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    order?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "type" | "order" | "status" | "created_at" | "updated_at", ExtArgs["result"]["challenge"]>
  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Challenge$questionsArgs<ExtArgs>
    challengeScore?: boolean | Challenge$challengeScoreArgs<ExtArgs>
    puzzleChallenge?: boolean | Challenge$puzzleChallengeArgs<ExtArgs>
    orderingChallenge?: boolean | Challenge$orderingChallengeArgs<ExtArgs>
    fillBlankChallenge?: boolean | Challenge$fillBlankChallengeArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      questions: Prisma.$ChallengeQuestionPayload<ExtArgs>[]
      challengeScore: Prisma.$ChallengeScorePayload<ExtArgs>[]
      puzzleChallenge: Prisma.$PuzzleChallengePayload<ExtArgs> | null
      orderingChallenge: Prisma.$OrderingChallengePayload<ExtArgs> | null
      fillBlankChallenge: Prisma.$FillBlankChallengePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string | null
      type: $Enums.ChallengeType
      order: number
      status: $Enums.ChallengeStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges and returns the data updated in the database.
     * @param {ChallengeUpdateManyAndReturnArgs} args - Arguments to update many Challenges.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends Challenge$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challengeScore<T extends Challenge$challengeScoreArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$challengeScoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    puzzleChallenge<T extends Challenge$puzzleChallengeArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$puzzleChallengeArgs<ExtArgs>>): Prisma__PuzzleChallengeClient<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderingChallenge<T extends Challenge$orderingChallengeArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$orderingChallengeArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fillBlankChallenge<T extends Challenge$fillBlankChallengeArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$fillBlankChallengeArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'String'>
    readonly title: FieldRef<"Challenge", 'String'>
    readonly slug: FieldRef<"Challenge", 'String'>
    readonly description: FieldRef<"Challenge", 'String'>
    readonly type: FieldRef<"Challenge", 'ChallengeType'>
    readonly order: FieldRef<"Challenge", 'Int'>
    readonly status: FieldRef<"Challenge", 'ChallengeStatus'>
    readonly created_at: FieldRef<"Challenge", 'DateTime'>
    readonly updated_at: FieldRef<"Challenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
  }

  /**
   * Challenge updateManyAndReturn
   */
  export type ChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to delete.
     */
    limit?: number
  }

  /**
   * Challenge.questions
   */
  export type Challenge$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    where?: ChallengeQuestionWhereInput
    orderBy?: ChallengeQuestionOrderByWithRelationInput | ChallengeQuestionOrderByWithRelationInput[]
    cursor?: ChallengeQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeQuestionScalarFieldEnum | ChallengeQuestionScalarFieldEnum[]
  }

  /**
   * Challenge.challengeScore
   */
  export type Challenge$challengeScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    where?: ChallengeScoreWhereInput
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    cursor?: ChallengeScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScoreScalarFieldEnum | ChallengeScoreScalarFieldEnum[]
  }

  /**
   * Challenge.puzzleChallenge
   */
  export type Challenge$puzzleChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    where?: PuzzleChallengeWhereInput
  }

  /**
   * Challenge.orderingChallenge
   */
  export type Challenge$orderingChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    where?: OrderingChallengeWhereInput
  }

  /**
   * Challenge.fillBlankChallenge
   */
  export type Challenge$fillBlankChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    where?: FillBlankChallengeWhereInput
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeQuestion
   */

  export type AggregateChallengeQuestion = {
    _count: ChallengeQuestionCountAggregateOutputType | null
    _min: ChallengeQuestionMinAggregateOutputType | null
    _max: ChallengeQuestionMaxAggregateOutputType | null
  }

  export type ChallengeQuestionMinAggregateOutputType = {
    id: string | null
    challenge_id: string | null
    question: string | null
    explanation: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeQuestionMaxAggregateOutputType = {
    id: string | null
    challenge_id: string | null
    question: string | null
    explanation: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeQuestionCountAggregateOutputType = {
    id: number
    challenge_id: number
    question: number
    explanation: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChallengeQuestionMinAggregateInputType = {
    id?: true
    challenge_id?: true
    question?: true
    explanation?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeQuestionMaxAggregateInputType = {
    id?: true
    challenge_id?: true
    question?: true
    explanation?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeQuestionCountAggregateInputType = {
    id?: true
    challenge_id?: true
    question?: true
    explanation?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChallengeQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeQuestion to aggregate.
     */
    where?: ChallengeQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeQuestions to fetch.
     */
    orderBy?: ChallengeQuestionOrderByWithRelationInput | ChallengeQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeQuestions
    **/
    _count?: true | ChallengeQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeQuestionMaxAggregateInputType
  }

  export type GetChallengeQuestionAggregateType<T extends ChallengeQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeQuestion[P]>
      : GetScalarType<T[P], AggregateChallengeQuestion[P]>
  }




  export type ChallengeQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeQuestionWhereInput
    orderBy?: ChallengeQuestionOrderByWithAggregationInput | ChallengeQuestionOrderByWithAggregationInput[]
    by: ChallengeQuestionScalarFieldEnum[] | ChallengeQuestionScalarFieldEnum
    having?: ChallengeQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeQuestionCountAggregateInputType | true
    _min?: ChallengeQuestionMinAggregateInputType
    _max?: ChallengeQuestionMaxAggregateInputType
  }

  export type ChallengeQuestionGroupByOutputType = {
    id: string
    challenge_id: string
    question: string
    explanation: string | null
    created_at: Date
    updated_at: Date
    _count: ChallengeQuestionCountAggregateOutputType | null
    _min: ChallengeQuestionMinAggregateOutputType | null
    _max: ChallengeQuestionMaxAggregateOutputType | null
  }

  type GetChallengeQuestionGroupByPayload<T extends ChallengeQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeQuestionGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    question?: boolean
    explanation?: boolean
    created_at?: boolean
    updated_at?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    answers?: boolean | ChallengeQuestion$answersArgs<ExtArgs>
    _count?: boolean | ChallengeQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeQuestion"]>

  export type ChallengeQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    question?: boolean
    explanation?: boolean
    created_at?: boolean
    updated_at?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeQuestion"]>

  export type ChallengeQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    question?: boolean
    explanation?: boolean
    created_at?: boolean
    updated_at?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeQuestion"]>

  export type ChallengeQuestionSelectScalar = {
    id?: boolean
    challenge_id?: boolean
    question?: boolean
    explanation?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChallengeQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challenge_id" | "question" | "explanation" | "created_at" | "updated_at", ExtArgs["result"]["challengeQuestion"]>
  export type ChallengeQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    answers?: boolean | ChallengeQuestion$answersArgs<ExtArgs>
    _count?: boolean | ChallengeQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeQuestion"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
      answers: Prisma.$ChallengeAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challenge_id: string
      question: string
      explanation: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["challengeQuestion"]>
    composites: {}
  }

  type ChallengeQuestionGetPayload<S extends boolean | null | undefined | ChallengeQuestionDefaultArgs> = $Result.GetResult<Prisma.$ChallengeQuestionPayload, S>

  type ChallengeQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeQuestionCountAggregateInputType | true
    }

  export interface ChallengeQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeQuestion'], meta: { name: 'ChallengeQuestion' } }
    /**
     * Find zero or one ChallengeQuestion that matches the filter.
     * @param {ChallengeQuestionFindUniqueArgs} args - Arguments to find a ChallengeQuestion
     * @example
     * // Get one ChallengeQuestion
     * const challengeQuestion = await prisma.challengeQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeQuestionFindUniqueArgs>(args: SelectSubset<T, ChallengeQuestionFindUniqueArgs<ExtArgs>>): Prisma__ChallengeQuestionClient<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeQuestionFindUniqueOrThrowArgs} args - Arguments to find a ChallengeQuestion
     * @example
     * // Get one ChallengeQuestion
     * const challengeQuestion = await prisma.challengeQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeQuestionClient<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeQuestionFindFirstArgs} args - Arguments to find a ChallengeQuestion
     * @example
     * // Get one ChallengeQuestion
     * const challengeQuestion = await prisma.challengeQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeQuestionFindFirstArgs>(args?: SelectSubset<T, ChallengeQuestionFindFirstArgs<ExtArgs>>): Prisma__ChallengeQuestionClient<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeQuestionFindFirstOrThrowArgs} args - Arguments to find a ChallengeQuestion
     * @example
     * // Get one ChallengeQuestion
     * const challengeQuestion = await prisma.challengeQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeQuestionClient<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeQuestions
     * const challengeQuestions = await prisma.challengeQuestion.findMany()
     * 
     * // Get first 10 ChallengeQuestions
     * const challengeQuestions = await prisma.challengeQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeQuestionWithIdOnly = await prisma.challengeQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeQuestionFindManyArgs>(args?: SelectSubset<T, ChallengeQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeQuestion.
     * @param {ChallengeQuestionCreateArgs} args - Arguments to create a ChallengeQuestion.
     * @example
     * // Create one ChallengeQuestion
     * const ChallengeQuestion = await prisma.challengeQuestion.create({
     *   data: {
     *     // ... data to create a ChallengeQuestion
     *   }
     * })
     * 
     */
    create<T extends ChallengeQuestionCreateArgs>(args: SelectSubset<T, ChallengeQuestionCreateArgs<ExtArgs>>): Prisma__ChallengeQuestionClient<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeQuestions.
     * @param {ChallengeQuestionCreateManyArgs} args - Arguments to create many ChallengeQuestions.
     * @example
     * // Create many ChallengeQuestions
     * const challengeQuestion = await prisma.challengeQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeQuestionCreateManyArgs>(args?: SelectSubset<T, ChallengeQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeQuestions and returns the data saved in the database.
     * @param {ChallengeQuestionCreateManyAndReturnArgs} args - Arguments to create many ChallengeQuestions.
     * @example
     * // Create many ChallengeQuestions
     * const challengeQuestion = await prisma.challengeQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeQuestions and only return the `id`
     * const challengeQuestionWithIdOnly = await prisma.challengeQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeQuestion.
     * @param {ChallengeQuestionDeleteArgs} args - Arguments to delete one ChallengeQuestion.
     * @example
     * // Delete one ChallengeQuestion
     * const ChallengeQuestion = await prisma.challengeQuestion.delete({
     *   where: {
     *     // ... filter to delete one ChallengeQuestion
     *   }
     * })
     * 
     */
    delete<T extends ChallengeQuestionDeleteArgs>(args: SelectSubset<T, ChallengeQuestionDeleteArgs<ExtArgs>>): Prisma__ChallengeQuestionClient<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeQuestion.
     * @param {ChallengeQuestionUpdateArgs} args - Arguments to update one ChallengeQuestion.
     * @example
     * // Update one ChallengeQuestion
     * const challengeQuestion = await prisma.challengeQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeQuestionUpdateArgs>(args: SelectSubset<T, ChallengeQuestionUpdateArgs<ExtArgs>>): Prisma__ChallengeQuestionClient<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeQuestions.
     * @param {ChallengeQuestionDeleteManyArgs} args - Arguments to filter ChallengeQuestions to delete.
     * @example
     * // Delete a few ChallengeQuestions
     * const { count } = await prisma.challengeQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeQuestionDeleteManyArgs>(args?: SelectSubset<T, ChallengeQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeQuestions
     * const challengeQuestion = await prisma.challengeQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeQuestionUpdateManyArgs>(args: SelectSubset<T, ChallengeQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeQuestions and returns the data updated in the database.
     * @param {ChallengeQuestionUpdateManyAndReturnArgs} args - Arguments to update many ChallengeQuestions.
     * @example
     * // Update many ChallengeQuestions
     * const challengeQuestion = await prisma.challengeQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeQuestions and only return the `id`
     * const challengeQuestionWithIdOnly = await prisma.challengeQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeQuestion.
     * @param {ChallengeQuestionUpsertArgs} args - Arguments to update or create a ChallengeQuestion.
     * @example
     * // Update or create a ChallengeQuestion
     * const challengeQuestion = await prisma.challengeQuestion.upsert({
     *   create: {
     *     // ... data to create a ChallengeQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeQuestion we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeQuestionUpsertArgs>(args: SelectSubset<T, ChallengeQuestionUpsertArgs<ExtArgs>>): Prisma__ChallengeQuestionClient<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeQuestionCountArgs} args - Arguments to filter ChallengeQuestions to count.
     * @example
     * // Count the number of ChallengeQuestions
     * const count = await prisma.challengeQuestion.count({
     *   where: {
     *     // ... the filter for the ChallengeQuestions we want to count
     *   }
     * })
    **/
    count<T extends ChallengeQuestionCountArgs>(
      args?: Subset<T, ChallengeQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeQuestionAggregateArgs>(args: Subset<T, ChallengeQuestionAggregateArgs>): Prisma.PrismaPromise<GetChallengeQuestionAggregateType<T>>

    /**
     * Group by ChallengeQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeQuestionGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeQuestion model
   */
  readonly fields: ChallengeQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends ChallengeQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeQuestion model
   */
  interface ChallengeQuestionFieldRefs {
    readonly id: FieldRef<"ChallengeQuestion", 'String'>
    readonly challenge_id: FieldRef<"ChallengeQuestion", 'String'>
    readonly question: FieldRef<"ChallengeQuestion", 'String'>
    readonly explanation: FieldRef<"ChallengeQuestion", 'String'>
    readonly created_at: FieldRef<"ChallengeQuestion", 'DateTime'>
    readonly updated_at: FieldRef<"ChallengeQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeQuestion findUnique
   */
  export type ChallengeQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeQuestion to fetch.
     */
    where: ChallengeQuestionWhereUniqueInput
  }

  /**
   * ChallengeQuestion findUniqueOrThrow
   */
  export type ChallengeQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeQuestion to fetch.
     */
    where: ChallengeQuestionWhereUniqueInput
  }

  /**
   * ChallengeQuestion findFirst
   */
  export type ChallengeQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeQuestion to fetch.
     */
    where?: ChallengeQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeQuestions to fetch.
     */
    orderBy?: ChallengeQuestionOrderByWithRelationInput | ChallengeQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeQuestions.
     */
    cursor?: ChallengeQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeQuestions.
     */
    distinct?: ChallengeQuestionScalarFieldEnum | ChallengeQuestionScalarFieldEnum[]
  }

  /**
   * ChallengeQuestion findFirstOrThrow
   */
  export type ChallengeQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeQuestion to fetch.
     */
    where?: ChallengeQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeQuestions to fetch.
     */
    orderBy?: ChallengeQuestionOrderByWithRelationInput | ChallengeQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeQuestions.
     */
    cursor?: ChallengeQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeQuestions.
     */
    distinct?: ChallengeQuestionScalarFieldEnum | ChallengeQuestionScalarFieldEnum[]
  }

  /**
   * ChallengeQuestion findMany
   */
  export type ChallengeQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeQuestions to fetch.
     */
    where?: ChallengeQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeQuestions to fetch.
     */
    orderBy?: ChallengeQuestionOrderByWithRelationInput | ChallengeQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeQuestions.
     */
    cursor?: ChallengeQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeQuestions.
     */
    skip?: number
    distinct?: ChallengeQuestionScalarFieldEnum | ChallengeQuestionScalarFieldEnum[]
  }

  /**
   * ChallengeQuestion create
   */
  export type ChallengeQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeQuestion.
     */
    data: XOR<ChallengeQuestionCreateInput, ChallengeQuestionUncheckedCreateInput>
  }

  /**
   * ChallengeQuestion createMany
   */
  export type ChallengeQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeQuestions.
     */
    data: ChallengeQuestionCreateManyInput | ChallengeQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeQuestion createManyAndReturn
   */
  export type ChallengeQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeQuestions.
     */
    data: ChallengeQuestionCreateManyInput | ChallengeQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeQuestion update
   */
  export type ChallengeQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeQuestion.
     */
    data: XOR<ChallengeQuestionUpdateInput, ChallengeQuestionUncheckedUpdateInput>
    /**
     * Choose, which ChallengeQuestion to update.
     */
    where: ChallengeQuestionWhereUniqueInput
  }

  /**
   * ChallengeQuestion updateMany
   */
  export type ChallengeQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeQuestions.
     */
    data: XOR<ChallengeQuestionUpdateManyMutationInput, ChallengeQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeQuestions to update
     */
    where?: ChallengeQuestionWhereInput
    /**
     * Limit how many ChallengeQuestions to update.
     */
    limit?: number
  }

  /**
   * ChallengeQuestion updateManyAndReturn
   */
  export type ChallengeQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeQuestions.
     */
    data: XOR<ChallengeQuestionUpdateManyMutationInput, ChallengeQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeQuestions to update
     */
    where?: ChallengeQuestionWhereInput
    /**
     * Limit how many ChallengeQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeQuestion upsert
   */
  export type ChallengeQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeQuestion to update in case it exists.
     */
    where: ChallengeQuestionWhereUniqueInput
    /**
     * In case the ChallengeQuestion found by the `where` argument doesn't exist, create a new ChallengeQuestion with this data.
     */
    create: XOR<ChallengeQuestionCreateInput, ChallengeQuestionUncheckedCreateInput>
    /**
     * In case the ChallengeQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeQuestionUpdateInput, ChallengeQuestionUncheckedUpdateInput>
  }

  /**
   * ChallengeQuestion delete
   */
  export type ChallengeQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
    /**
     * Filter which ChallengeQuestion to delete.
     */
    where: ChallengeQuestionWhereUniqueInput
  }

  /**
   * ChallengeQuestion deleteMany
   */
  export type ChallengeQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeQuestions to delete
     */
    where?: ChallengeQuestionWhereInput
    /**
     * Limit how many ChallengeQuestions to delete.
     */
    limit?: number
  }

  /**
   * ChallengeQuestion.answers
   */
  export type ChallengeQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    where?: ChallengeAnswerWhereInput
    orderBy?: ChallengeAnswerOrderByWithRelationInput | ChallengeAnswerOrderByWithRelationInput[]
    cursor?: ChallengeAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeAnswerScalarFieldEnum | ChallengeAnswerScalarFieldEnum[]
  }

  /**
   * ChallengeQuestion without action
   */
  export type ChallengeQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeQuestion
     */
    select?: ChallengeQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeQuestion
     */
    omit?: ChallengeQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeQuestionInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeAnswer
   */

  export type AggregateChallengeAnswer = {
    _count: ChallengeAnswerCountAggregateOutputType | null
    _min: ChallengeAnswerMinAggregateOutputType | null
    _max: ChallengeAnswerMaxAggregateOutputType | null
  }

  export type ChallengeAnswerMinAggregateOutputType = {
    id: string | null
    challenge_question_id: string | null
    answer: string | null
    is_correct: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeAnswerMaxAggregateOutputType = {
    id: string | null
    challenge_question_id: string | null
    answer: string | null
    is_correct: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeAnswerCountAggregateOutputType = {
    id: number
    challenge_question_id: number
    answer: number
    is_correct: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChallengeAnswerMinAggregateInputType = {
    id?: true
    challenge_question_id?: true
    answer?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeAnswerMaxAggregateInputType = {
    id?: true
    challenge_question_id?: true
    answer?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeAnswerCountAggregateInputType = {
    id?: true
    challenge_question_id?: true
    answer?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChallengeAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeAnswer to aggregate.
     */
    where?: ChallengeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAnswers to fetch.
     */
    orderBy?: ChallengeAnswerOrderByWithRelationInput | ChallengeAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeAnswers
    **/
    _count?: true | ChallengeAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeAnswerMaxAggregateInputType
  }

  export type GetChallengeAnswerAggregateType<T extends ChallengeAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeAnswer[P]>
      : GetScalarType<T[P], AggregateChallengeAnswer[P]>
  }




  export type ChallengeAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeAnswerWhereInput
    orderBy?: ChallengeAnswerOrderByWithAggregationInput | ChallengeAnswerOrderByWithAggregationInput[]
    by: ChallengeAnswerScalarFieldEnum[] | ChallengeAnswerScalarFieldEnum
    having?: ChallengeAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeAnswerCountAggregateInputType | true
    _min?: ChallengeAnswerMinAggregateInputType
    _max?: ChallengeAnswerMaxAggregateInputType
  }

  export type ChallengeAnswerGroupByOutputType = {
    id: string
    challenge_question_id: string
    answer: string
    is_correct: boolean
    created_at: Date
    updated_at: Date
    _count: ChallengeAnswerCountAggregateOutputType | null
    _min: ChallengeAnswerMinAggregateOutputType | null
    _max: ChallengeAnswerMaxAggregateOutputType | null
  }

  type GetChallengeAnswerGroupByPayload<T extends ChallengeAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeAnswerGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_question_id?: boolean
    answer?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
    challenge_question?: boolean | ChallengeQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeAnswer"]>

  export type ChallengeAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_question_id?: boolean
    answer?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
    challenge_question?: boolean | ChallengeQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeAnswer"]>

  export type ChallengeAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_question_id?: boolean
    answer?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
    challenge_question?: boolean | ChallengeQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeAnswer"]>

  export type ChallengeAnswerSelectScalar = {
    id?: boolean
    challenge_question_id?: boolean
    answer?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChallengeAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challenge_question_id" | "answer" | "is_correct" | "created_at" | "updated_at", ExtArgs["result"]["challengeAnswer"]>
  export type ChallengeAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge_question?: boolean | ChallengeQuestionDefaultArgs<ExtArgs>
  }
  export type ChallengeAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge_question?: boolean | ChallengeQuestionDefaultArgs<ExtArgs>
  }
  export type ChallengeAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge_question?: boolean | ChallengeQuestionDefaultArgs<ExtArgs>
  }

  export type $ChallengeAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeAnswer"
    objects: {
      challenge_question: Prisma.$ChallengeQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challenge_question_id: string
      answer: string
      is_correct: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["challengeAnswer"]>
    composites: {}
  }

  type ChallengeAnswerGetPayload<S extends boolean | null | undefined | ChallengeAnswerDefaultArgs> = $Result.GetResult<Prisma.$ChallengeAnswerPayload, S>

  type ChallengeAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeAnswerCountAggregateInputType | true
    }

  export interface ChallengeAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeAnswer'], meta: { name: 'ChallengeAnswer' } }
    /**
     * Find zero or one ChallengeAnswer that matches the filter.
     * @param {ChallengeAnswerFindUniqueArgs} args - Arguments to find a ChallengeAnswer
     * @example
     * // Get one ChallengeAnswer
     * const challengeAnswer = await prisma.challengeAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeAnswerFindUniqueArgs>(args: SelectSubset<T, ChallengeAnswerFindUniqueArgs<ExtArgs>>): Prisma__ChallengeAnswerClient<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeAnswerFindUniqueOrThrowArgs} args - Arguments to find a ChallengeAnswer
     * @example
     * // Get one ChallengeAnswer
     * const challengeAnswer = await prisma.challengeAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeAnswerClient<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAnswerFindFirstArgs} args - Arguments to find a ChallengeAnswer
     * @example
     * // Get one ChallengeAnswer
     * const challengeAnswer = await prisma.challengeAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeAnswerFindFirstArgs>(args?: SelectSubset<T, ChallengeAnswerFindFirstArgs<ExtArgs>>): Prisma__ChallengeAnswerClient<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAnswerFindFirstOrThrowArgs} args - Arguments to find a ChallengeAnswer
     * @example
     * // Get one ChallengeAnswer
     * const challengeAnswer = await prisma.challengeAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeAnswerClient<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeAnswers
     * const challengeAnswers = await prisma.challengeAnswer.findMany()
     * 
     * // Get first 10 ChallengeAnswers
     * const challengeAnswers = await prisma.challengeAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeAnswerWithIdOnly = await prisma.challengeAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeAnswerFindManyArgs>(args?: SelectSubset<T, ChallengeAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeAnswer.
     * @param {ChallengeAnswerCreateArgs} args - Arguments to create a ChallengeAnswer.
     * @example
     * // Create one ChallengeAnswer
     * const ChallengeAnswer = await prisma.challengeAnswer.create({
     *   data: {
     *     // ... data to create a ChallengeAnswer
     *   }
     * })
     * 
     */
    create<T extends ChallengeAnswerCreateArgs>(args: SelectSubset<T, ChallengeAnswerCreateArgs<ExtArgs>>): Prisma__ChallengeAnswerClient<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeAnswers.
     * @param {ChallengeAnswerCreateManyArgs} args - Arguments to create many ChallengeAnswers.
     * @example
     * // Create many ChallengeAnswers
     * const challengeAnswer = await prisma.challengeAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeAnswerCreateManyArgs>(args?: SelectSubset<T, ChallengeAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeAnswers and returns the data saved in the database.
     * @param {ChallengeAnswerCreateManyAndReturnArgs} args - Arguments to create many ChallengeAnswers.
     * @example
     * // Create many ChallengeAnswers
     * const challengeAnswer = await prisma.challengeAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeAnswers and only return the `id`
     * const challengeAnswerWithIdOnly = await prisma.challengeAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeAnswer.
     * @param {ChallengeAnswerDeleteArgs} args - Arguments to delete one ChallengeAnswer.
     * @example
     * // Delete one ChallengeAnswer
     * const ChallengeAnswer = await prisma.challengeAnswer.delete({
     *   where: {
     *     // ... filter to delete one ChallengeAnswer
     *   }
     * })
     * 
     */
    delete<T extends ChallengeAnswerDeleteArgs>(args: SelectSubset<T, ChallengeAnswerDeleteArgs<ExtArgs>>): Prisma__ChallengeAnswerClient<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeAnswer.
     * @param {ChallengeAnswerUpdateArgs} args - Arguments to update one ChallengeAnswer.
     * @example
     * // Update one ChallengeAnswer
     * const challengeAnswer = await prisma.challengeAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeAnswerUpdateArgs>(args: SelectSubset<T, ChallengeAnswerUpdateArgs<ExtArgs>>): Prisma__ChallengeAnswerClient<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeAnswers.
     * @param {ChallengeAnswerDeleteManyArgs} args - Arguments to filter ChallengeAnswers to delete.
     * @example
     * // Delete a few ChallengeAnswers
     * const { count } = await prisma.challengeAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeAnswerDeleteManyArgs>(args?: SelectSubset<T, ChallengeAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeAnswers
     * const challengeAnswer = await prisma.challengeAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeAnswerUpdateManyArgs>(args: SelectSubset<T, ChallengeAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeAnswers and returns the data updated in the database.
     * @param {ChallengeAnswerUpdateManyAndReturnArgs} args - Arguments to update many ChallengeAnswers.
     * @example
     * // Update many ChallengeAnswers
     * const challengeAnswer = await prisma.challengeAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeAnswers and only return the `id`
     * const challengeAnswerWithIdOnly = await prisma.challengeAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeAnswer.
     * @param {ChallengeAnswerUpsertArgs} args - Arguments to update or create a ChallengeAnswer.
     * @example
     * // Update or create a ChallengeAnswer
     * const challengeAnswer = await prisma.challengeAnswer.upsert({
     *   create: {
     *     // ... data to create a ChallengeAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeAnswer we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeAnswerUpsertArgs>(args: SelectSubset<T, ChallengeAnswerUpsertArgs<ExtArgs>>): Prisma__ChallengeAnswerClient<$Result.GetResult<Prisma.$ChallengeAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAnswerCountArgs} args - Arguments to filter ChallengeAnswers to count.
     * @example
     * // Count the number of ChallengeAnswers
     * const count = await prisma.challengeAnswer.count({
     *   where: {
     *     // ... the filter for the ChallengeAnswers we want to count
     *   }
     * })
    **/
    count<T extends ChallengeAnswerCountArgs>(
      args?: Subset<T, ChallengeAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAnswerAggregateArgs>(args: Subset<T, ChallengeAnswerAggregateArgs>): Prisma.PrismaPromise<GetChallengeAnswerAggregateType<T>>

    /**
     * Group by ChallengeAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeAnswerGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeAnswer model
   */
  readonly fields: ChallengeAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge_question<T extends ChallengeQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeQuestionDefaultArgs<ExtArgs>>): Prisma__ChallengeQuestionClient<$Result.GetResult<Prisma.$ChallengeQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeAnswer model
   */
  interface ChallengeAnswerFieldRefs {
    readonly id: FieldRef<"ChallengeAnswer", 'String'>
    readonly challenge_question_id: FieldRef<"ChallengeAnswer", 'String'>
    readonly answer: FieldRef<"ChallengeAnswer", 'String'>
    readonly is_correct: FieldRef<"ChallengeAnswer", 'Boolean'>
    readonly created_at: FieldRef<"ChallengeAnswer", 'DateTime'>
    readonly updated_at: FieldRef<"ChallengeAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeAnswer findUnique
   */
  export type ChallengeAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAnswer to fetch.
     */
    where: ChallengeAnswerWhereUniqueInput
  }

  /**
   * ChallengeAnswer findUniqueOrThrow
   */
  export type ChallengeAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAnswer to fetch.
     */
    where: ChallengeAnswerWhereUniqueInput
  }

  /**
   * ChallengeAnswer findFirst
   */
  export type ChallengeAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAnswer to fetch.
     */
    where?: ChallengeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAnswers to fetch.
     */
    orderBy?: ChallengeAnswerOrderByWithRelationInput | ChallengeAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeAnswers.
     */
    cursor?: ChallengeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeAnswers.
     */
    distinct?: ChallengeAnswerScalarFieldEnum | ChallengeAnswerScalarFieldEnum[]
  }

  /**
   * ChallengeAnswer findFirstOrThrow
   */
  export type ChallengeAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAnswer to fetch.
     */
    where?: ChallengeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAnswers to fetch.
     */
    orderBy?: ChallengeAnswerOrderByWithRelationInput | ChallengeAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeAnswers.
     */
    cursor?: ChallengeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeAnswers.
     */
    distinct?: ChallengeAnswerScalarFieldEnum | ChallengeAnswerScalarFieldEnum[]
  }

  /**
   * ChallengeAnswer findMany
   */
  export type ChallengeAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAnswers to fetch.
     */
    where?: ChallengeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAnswers to fetch.
     */
    orderBy?: ChallengeAnswerOrderByWithRelationInput | ChallengeAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeAnswers.
     */
    cursor?: ChallengeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAnswers.
     */
    skip?: number
    distinct?: ChallengeAnswerScalarFieldEnum | ChallengeAnswerScalarFieldEnum[]
  }

  /**
   * ChallengeAnswer create
   */
  export type ChallengeAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeAnswer.
     */
    data: XOR<ChallengeAnswerCreateInput, ChallengeAnswerUncheckedCreateInput>
  }

  /**
   * ChallengeAnswer createMany
   */
  export type ChallengeAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeAnswers.
     */
    data: ChallengeAnswerCreateManyInput | ChallengeAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeAnswer createManyAndReturn
   */
  export type ChallengeAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeAnswers.
     */
    data: ChallengeAnswerCreateManyInput | ChallengeAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeAnswer update
   */
  export type ChallengeAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeAnswer.
     */
    data: XOR<ChallengeAnswerUpdateInput, ChallengeAnswerUncheckedUpdateInput>
    /**
     * Choose, which ChallengeAnswer to update.
     */
    where: ChallengeAnswerWhereUniqueInput
  }

  /**
   * ChallengeAnswer updateMany
   */
  export type ChallengeAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeAnswers.
     */
    data: XOR<ChallengeAnswerUpdateManyMutationInput, ChallengeAnswerUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeAnswers to update
     */
    where?: ChallengeAnswerWhereInput
    /**
     * Limit how many ChallengeAnswers to update.
     */
    limit?: number
  }

  /**
   * ChallengeAnswer updateManyAndReturn
   */
  export type ChallengeAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeAnswers.
     */
    data: XOR<ChallengeAnswerUpdateManyMutationInput, ChallengeAnswerUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeAnswers to update
     */
    where?: ChallengeAnswerWhereInput
    /**
     * Limit how many ChallengeAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeAnswer upsert
   */
  export type ChallengeAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeAnswer to update in case it exists.
     */
    where: ChallengeAnswerWhereUniqueInput
    /**
     * In case the ChallengeAnswer found by the `where` argument doesn't exist, create a new ChallengeAnswer with this data.
     */
    create: XOR<ChallengeAnswerCreateInput, ChallengeAnswerUncheckedCreateInput>
    /**
     * In case the ChallengeAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeAnswerUpdateInput, ChallengeAnswerUncheckedUpdateInput>
  }

  /**
   * ChallengeAnswer delete
   */
  export type ChallengeAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
    /**
     * Filter which ChallengeAnswer to delete.
     */
    where: ChallengeAnswerWhereUniqueInput
  }

  /**
   * ChallengeAnswer deleteMany
   */
  export type ChallengeAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeAnswers to delete
     */
    where?: ChallengeAnswerWhereInput
    /**
     * Limit how many ChallengeAnswers to delete.
     */
    limit?: number
  }

  /**
   * ChallengeAnswer without action
   */
  export type ChallengeAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAnswer
     */
    select?: ChallengeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAnswer
     */
    omit?: ChallengeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAnswerInclude<ExtArgs> | null
  }


  /**
   * Model PuzzleChallenge
   */

  export type AggregatePuzzleChallenge = {
    _count: PuzzleChallengeCountAggregateOutputType | null
    _min: PuzzleChallengeMinAggregateOutputType | null
    _max: PuzzleChallengeMaxAggregateOutputType | null
  }

  export type PuzzleChallengeMinAggregateOutputType = {
    id: string | null
    challenge_id: string | null
    instruction: string | null
    image: string | null
  }

  export type PuzzleChallengeMaxAggregateOutputType = {
    id: string | null
    challenge_id: string | null
    instruction: string | null
    image: string | null
  }

  export type PuzzleChallengeCountAggregateOutputType = {
    id: number
    challenge_id: number
    instruction: number
    image: number
    _all: number
  }


  export type PuzzleChallengeMinAggregateInputType = {
    id?: true
    challenge_id?: true
    instruction?: true
    image?: true
  }

  export type PuzzleChallengeMaxAggregateInputType = {
    id?: true
    challenge_id?: true
    instruction?: true
    image?: true
  }

  export type PuzzleChallengeCountAggregateInputType = {
    id?: true
    challenge_id?: true
    instruction?: true
    image?: true
    _all?: true
  }

  export type PuzzleChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PuzzleChallenge to aggregate.
     */
    where?: PuzzleChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuzzleChallenges to fetch.
     */
    orderBy?: PuzzleChallengeOrderByWithRelationInput | PuzzleChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PuzzleChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuzzleChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuzzleChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PuzzleChallenges
    **/
    _count?: true | PuzzleChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PuzzleChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PuzzleChallengeMaxAggregateInputType
  }

  export type GetPuzzleChallengeAggregateType<T extends PuzzleChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregatePuzzleChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePuzzleChallenge[P]>
      : GetScalarType<T[P], AggregatePuzzleChallenge[P]>
  }




  export type PuzzleChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PuzzleChallengeWhereInput
    orderBy?: PuzzleChallengeOrderByWithAggregationInput | PuzzleChallengeOrderByWithAggregationInput[]
    by: PuzzleChallengeScalarFieldEnum[] | PuzzleChallengeScalarFieldEnum
    having?: PuzzleChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PuzzleChallengeCountAggregateInputType | true
    _min?: PuzzleChallengeMinAggregateInputType
    _max?: PuzzleChallengeMaxAggregateInputType
  }

  export type PuzzleChallengeGroupByOutputType = {
    id: string
    challenge_id: string
    instruction: string
    image: string
    _count: PuzzleChallengeCountAggregateOutputType | null
    _min: PuzzleChallengeMinAggregateOutputType | null
    _max: PuzzleChallengeMaxAggregateOutputType | null
  }

  type GetPuzzleChallengeGroupByPayload<T extends PuzzleChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PuzzleChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PuzzleChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PuzzleChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], PuzzleChallengeGroupByOutputType[P]>
        }
      >
    >


  export type PuzzleChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    instruction?: boolean
    image?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["puzzleChallenge"]>

  export type PuzzleChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    instruction?: boolean
    image?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["puzzleChallenge"]>

  export type PuzzleChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    instruction?: boolean
    image?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["puzzleChallenge"]>

  export type PuzzleChallengeSelectScalar = {
    id?: boolean
    challenge_id?: boolean
    instruction?: boolean
    image?: boolean
  }

  export type PuzzleChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challenge_id" | "instruction" | "image", ExtArgs["result"]["puzzleChallenge"]>
  export type PuzzleChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type PuzzleChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type PuzzleChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $PuzzleChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PuzzleChallenge"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challenge_id: string
      instruction: string
      image: string
    }, ExtArgs["result"]["puzzleChallenge"]>
    composites: {}
  }

  type PuzzleChallengeGetPayload<S extends boolean | null | undefined | PuzzleChallengeDefaultArgs> = $Result.GetResult<Prisma.$PuzzleChallengePayload, S>

  type PuzzleChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PuzzleChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PuzzleChallengeCountAggregateInputType | true
    }

  export interface PuzzleChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PuzzleChallenge'], meta: { name: 'PuzzleChallenge' } }
    /**
     * Find zero or one PuzzleChallenge that matches the filter.
     * @param {PuzzleChallengeFindUniqueArgs} args - Arguments to find a PuzzleChallenge
     * @example
     * // Get one PuzzleChallenge
     * const puzzleChallenge = await prisma.puzzleChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PuzzleChallengeFindUniqueArgs>(args: SelectSubset<T, PuzzleChallengeFindUniqueArgs<ExtArgs>>): Prisma__PuzzleChallengeClient<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PuzzleChallenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PuzzleChallengeFindUniqueOrThrowArgs} args - Arguments to find a PuzzleChallenge
     * @example
     * // Get one PuzzleChallenge
     * const puzzleChallenge = await prisma.puzzleChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PuzzleChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, PuzzleChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PuzzleChallengeClient<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PuzzleChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuzzleChallengeFindFirstArgs} args - Arguments to find a PuzzleChallenge
     * @example
     * // Get one PuzzleChallenge
     * const puzzleChallenge = await prisma.puzzleChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PuzzleChallengeFindFirstArgs>(args?: SelectSubset<T, PuzzleChallengeFindFirstArgs<ExtArgs>>): Prisma__PuzzleChallengeClient<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PuzzleChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuzzleChallengeFindFirstOrThrowArgs} args - Arguments to find a PuzzleChallenge
     * @example
     * // Get one PuzzleChallenge
     * const puzzleChallenge = await prisma.puzzleChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PuzzleChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, PuzzleChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PuzzleChallengeClient<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PuzzleChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuzzleChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PuzzleChallenges
     * const puzzleChallenges = await prisma.puzzleChallenge.findMany()
     * 
     * // Get first 10 PuzzleChallenges
     * const puzzleChallenges = await prisma.puzzleChallenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const puzzleChallengeWithIdOnly = await prisma.puzzleChallenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PuzzleChallengeFindManyArgs>(args?: SelectSubset<T, PuzzleChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PuzzleChallenge.
     * @param {PuzzleChallengeCreateArgs} args - Arguments to create a PuzzleChallenge.
     * @example
     * // Create one PuzzleChallenge
     * const PuzzleChallenge = await prisma.puzzleChallenge.create({
     *   data: {
     *     // ... data to create a PuzzleChallenge
     *   }
     * })
     * 
     */
    create<T extends PuzzleChallengeCreateArgs>(args: SelectSubset<T, PuzzleChallengeCreateArgs<ExtArgs>>): Prisma__PuzzleChallengeClient<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PuzzleChallenges.
     * @param {PuzzleChallengeCreateManyArgs} args - Arguments to create many PuzzleChallenges.
     * @example
     * // Create many PuzzleChallenges
     * const puzzleChallenge = await prisma.puzzleChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PuzzleChallengeCreateManyArgs>(args?: SelectSubset<T, PuzzleChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PuzzleChallenges and returns the data saved in the database.
     * @param {PuzzleChallengeCreateManyAndReturnArgs} args - Arguments to create many PuzzleChallenges.
     * @example
     * // Create many PuzzleChallenges
     * const puzzleChallenge = await prisma.puzzleChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PuzzleChallenges and only return the `id`
     * const puzzleChallengeWithIdOnly = await prisma.puzzleChallenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PuzzleChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, PuzzleChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PuzzleChallenge.
     * @param {PuzzleChallengeDeleteArgs} args - Arguments to delete one PuzzleChallenge.
     * @example
     * // Delete one PuzzleChallenge
     * const PuzzleChallenge = await prisma.puzzleChallenge.delete({
     *   where: {
     *     // ... filter to delete one PuzzleChallenge
     *   }
     * })
     * 
     */
    delete<T extends PuzzleChallengeDeleteArgs>(args: SelectSubset<T, PuzzleChallengeDeleteArgs<ExtArgs>>): Prisma__PuzzleChallengeClient<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PuzzleChallenge.
     * @param {PuzzleChallengeUpdateArgs} args - Arguments to update one PuzzleChallenge.
     * @example
     * // Update one PuzzleChallenge
     * const puzzleChallenge = await prisma.puzzleChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PuzzleChallengeUpdateArgs>(args: SelectSubset<T, PuzzleChallengeUpdateArgs<ExtArgs>>): Prisma__PuzzleChallengeClient<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PuzzleChallenges.
     * @param {PuzzleChallengeDeleteManyArgs} args - Arguments to filter PuzzleChallenges to delete.
     * @example
     * // Delete a few PuzzleChallenges
     * const { count } = await prisma.puzzleChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PuzzleChallengeDeleteManyArgs>(args?: SelectSubset<T, PuzzleChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PuzzleChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuzzleChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PuzzleChallenges
     * const puzzleChallenge = await prisma.puzzleChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PuzzleChallengeUpdateManyArgs>(args: SelectSubset<T, PuzzleChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PuzzleChallenges and returns the data updated in the database.
     * @param {PuzzleChallengeUpdateManyAndReturnArgs} args - Arguments to update many PuzzleChallenges.
     * @example
     * // Update many PuzzleChallenges
     * const puzzleChallenge = await prisma.puzzleChallenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PuzzleChallenges and only return the `id`
     * const puzzleChallengeWithIdOnly = await prisma.puzzleChallenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PuzzleChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, PuzzleChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PuzzleChallenge.
     * @param {PuzzleChallengeUpsertArgs} args - Arguments to update or create a PuzzleChallenge.
     * @example
     * // Update or create a PuzzleChallenge
     * const puzzleChallenge = await prisma.puzzleChallenge.upsert({
     *   create: {
     *     // ... data to create a PuzzleChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PuzzleChallenge we want to update
     *   }
     * })
     */
    upsert<T extends PuzzleChallengeUpsertArgs>(args: SelectSubset<T, PuzzleChallengeUpsertArgs<ExtArgs>>): Prisma__PuzzleChallengeClient<$Result.GetResult<Prisma.$PuzzleChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PuzzleChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuzzleChallengeCountArgs} args - Arguments to filter PuzzleChallenges to count.
     * @example
     * // Count the number of PuzzleChallenges
     * const count = await prisma.puzzleChallenge.count({
     *   where: {
     *     // ... the filter for the PuzzleChallenges we want to count
     *   }
     * })
    **/
    count<T extends PuzzleChallengeCountArgs>(
      args?: Subset<T, PuzzleChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PuzzleChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PuzzleChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuzzleChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PuzzleChallengeAggregateArgs>(args: Subset<T, PuzzleChallengeAggregateArgs>): Prisma.PrismaPromise<GetPuzzleChallengeAggregateType<T>>

    /**
     * Group by PuzzleChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuzzleChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PuzzleChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PuzzleChallengeGroupByArgs['orderBy'] }
        : { orderBy?: PuzzleChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PuzzleChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPuzzleChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PuzzleChallenge model
   */
  readonly fields: PuzzleChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PuzzleChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PuzzleChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PuzzleChallenge model
   */
  interface PuzzleChallengeFieldRefs {
    readonly id: FieldRef<"PuzzleChallenge", 'String'>
    readonly challenge_id: FieldRef<"PuzzleChallenge", 'String'>
    readonly instruction: FieldRef<"PuzzleChallenge", 'String'>
    readonly image: FieldRef<"PuzzleChallenge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PuzzleChallenge findUnique
   */
  export type PuzzleChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    /**
     * Filter, which PuzzleChallenge to fetch.
     */
    where: PuzzleChallengeWhereUniqueInput
  }

  /**
   * PuzzleChallenge findUniqueOrThrow
   */
  export type PuzzleChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    /**
     * Filter, which PuzzleChallenge to fetch.
     */
    where: PuzzleChallengeWhereUniqueInput
  }

  /**
   * PuzzleChallenge findFirst
   */
  export type PuzzleChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    /**
     * Filter, which PuzzleChallenge to fetch.
     */
    where?: PuzzleChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuzzleChallenges to fetch.
     */
    orderBy?: PuzzleChallengeOrderByWithRelationInput | PuzzleChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PuzzleChallenges.
     */
    cursor?: PuzzleChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuzzleChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuzzleChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PuzzleChallenges.
     */
    distinct?: PuzzleChallengeScalarFieldEnum | PuzzleChallengeScalarFieldEnum[]
  }

  /**
   * PuzzleChallenge findFirstOrThrow
   */
  export type PuzzleChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    /**
     * Filter, which PuzzleChallenge to fetch.
     */
    where?: PuzzleChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuzzleChallenges to fetch.
     */
    orderBy?: PuzzleChallengeOrderByWithRelationInput | PuzzleChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PuzzleChallenges.
     */
    cursor?: PuzzleChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuzzleChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuzzleChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PuzzleChallenges.
     */
    distinct?: PuzzleChallengeScalarFieldEnum | PuzzleChallengeScalarFieldEnum[]
  }

  /**
   * PuzzleChallenge findMany
   */
  export type PuzzleChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    /**
     * Filter, which PuzzleChallenges to fetch.
     */
    where?: PuzzleChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuzzleChallenges to fetch.
     */
    orderBy?: PuzzleChallengeOrderByWithRelationInput | PuzzleChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PuzzleChallenges.
     */
    cursor?: PuzzleChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuzzleChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuzzleChallenges.
     */
    skip?: number
    distinct?: PuzzleChallengeScalarFieldEnum | PuzzleChallengeScalarFieldEnum[]
  }

  /**
   * PuzzleChallenge create
   */
  export type PuzzleChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a PuzzleChallenge.
     */
    data: XOR<PuzzleChallengeCreateInput, PuzzleChallengeUncheckedCreateInput>
  }

  /**
   * PuzzleChallenge createMany
   */
  export type PuzzleChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PuzzleChallenges.
     */
    data: PuzzleChallengeCreateManyInput | PuzzleChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PuzzleChallenge createManyAndReturn
   */
  export type PuzzleChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many PuzzleChallenges.
     */
    data: PuzzleChallengeCreateManyInput | PuzzleChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PuzzleChallenge update
   */
  export type PuzzleChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a PuzzleChallenge.
     */
    data: XOR<PuzzleChallengeUpdateInput, PuzzleChallengeUncheckedUpdateInput>
    /**
     * Choose, which PuzzleChallenge to update.
     */
    where: PuzzleChallengeWhereUniqueInput
  }

  /**
   * PuzzleChallenge updateMany
   */
  export type PuzzleChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PuzzleChallenges.
     */
    data: XOR<PuzzleChallengeUpdateManyMutationInput, PuzzleChallengeUncheckedUpdateManyInput>
    /**
     * Filter which PuzzleChallenges to update
     */
    where?: PuzzleChallengeWhereInput
    /**
     * Limit how many PuzzleChallenges to update.
     */
    limit?: number
  }

  /**
   * PuzzleChallenge updateManyAndReturn
   */
  export type PuzzleChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * The data used to update PuzzleChallenges.
     */
    data: XOR<PuzzleChallengeUpdateManyMutationInput, PuzzleChallengeUncheckedUpdateManyInput>
    /**
     * Filter which PuzzleChallenges to update
     */
    where?: PuzzleChallengeWhereInput
    /**
     * Limit how many PuzzleChallenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PuzzleChallenge upsert
   */
  export type PuzzleChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the PuzzleChallenge to update in case it exists.
     */
    where: PuzzleChallengeWhereUniqueInput
    /**
     * In case the PuzzleChallenge found by the `where` argument doesn't exist, create a new PuzzleChallenge with this data.
     */
    create: XOR<PuzzleChallengeCreateInput, PuzzleChallengeUncheckedCreateInput>
    /**
     * In case the PuzzleChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PuzzleChallengeUpdateInput, PuzzleChallengeUncheckedUpdateInput>
  }

  /**
   * PuzzleChallenge delete
   */
  export type PuzzleChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
    /**
     * Filter which PuzzleChallenge to delete.
     */
    where: PuzzleChallengeWhereUniqueInput
  }

  /**
   * PuzzleChallenge deleteMany
   */
  export type PuzzleChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PuzzleChallenges to delete
     */
    where?: PuzzleChallengeWhereInput
    /**
     * Limit how many PuzzleChallenges to delete.
     */
    limit?: number
  }

  /**
   * PuzzleChallenge without action
   */
  export type PuzzleChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuzzleChallenge
     */
    select?: PuzzleChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PuzzleChallenge
     */
    omit?: PuzzleChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PuzzleChallengeInclude<ExtArgs> | null
  }


  /**
   * Model OrderingChallenge
   */

  export type AggregateOrderingChallenge = {
    _count: OrderingChallengeCountAggregateOutputType | null
    _min: OrderingChallengeMinAggregateOutputType | null
    _max: OrderingChallengeMaxAggregateOutputType | null
  }

  export type OrderingChallengeMinAggregateOutputType = {
    id: string | null
    challenge_id: string | null
    instruction: string | null
  }

  export type OrderingChallengeMaxAggregateOutputType = {
    id: string | null
    challenge_id: string | null
    instruction: string | null
  }

  export type OrderingChallengeCountAggregateOutputType = {
    id: number
    challenge_id: number
    instruction: number
    _all: number
  }


  export type OrderingChallengeMinAggregateInputType = {
    id?: true
    challenge_id?: true
    instruction?: true
  }

  export type OrderingChallengeMaxAggregateInputType = {
    id?: true
    challenge_id?: true
    instruction?: true
  }

  export type OrderingChallengeCountAggregateInputType = {
    id?: true
    challenge_id?: true
    instruction?: true
    _all?: true
  }

  export type OrderingChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderingChallenge to aggregate.
     */
    where?: OrderingChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderingChallenges to fetch.
     */
    orderBy?: OrderingChallengeOrderByWithRelationInput | OrderingChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderingChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderingChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderingChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderingChallenges
    **/
    _count?: true | OrderingChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderingChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderingChallengeMaxAggregateInputType
  }

  export type GetOrderingChallengeAggregateType<T extends OrderingChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderingChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderingChallenge[P]>
      : GetScalarType<T[P], AggregateOrderingChallenge[P]>
  }




  export type OrderingChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderingChallengeWhereInput
    orderBy?: OrderingChallengeOrderByWithAggregationInput | OrderingChallengeOrderByWithAggregationInput[]
    by: OrderingChallengeScalarFieldEnum[] | OrderingChallengeScalarFieldEnum
    having?: OrderingChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderingChallengeCountAggregateInputType | true
    _min?: OrderingChallengeMinAggregateInputType
    _max?: OrderingChallengeMaxAggregateInputType
  }

  export type OrderingChallengeGroupByOutputType = {
    id: string
    challenge_id: string
    instruction: string
    _count: OrderingChallengeCountAggregateOutputType | null
    _min: OrderingChallengeMinAggregateOutputType | null
    _max: OrderingChallengeMaxAggregateOutputType | null
  }

  type GetOrderingChallengeGroupByPayload<T extends OrderingChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderingChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderingChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderingChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], OrderingChallengeGroupByOutputType[P]>
        }
      >
    >


  export type OrderingChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    instruction?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    items?: boolean | OrderingChallenge$itemsArgs<ExtArgs>
    _count?: boolean | OrderingChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderingChallenge"]>

  export type OrderingChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    instruction?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderingChallenge"]>

  export type OrderingChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    instruction?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderingChallenge"]>

  export type OrderingChallengeSelectScalar = {
    id?: boolean
    challenge_id?: boolean
    instruction?: boolean
  }

  export type OrderingChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challenge_id" | "instruction", ExtArgs["result"]["orderingChallenge"]>
  export type OrderingChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    items?: boolean | OrderingChallenge$itemsArgs<ExtArgs>
    _count?: boolean | OrderingChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderingChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type OrderingChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $OrderingChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderingChallenge"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
      items: Prisma.$OrderingItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challenge_id: string
      instruction: string
    }, ExtArgs["result"]["orderingChallenge"]>
    composites: {}
  }

  type OrderingChallengeGetPayload<S extends boolean | null | undefined | OrderingChallengeDefaultArgs> = $Result.GetResult<Prisma.$OrderingChallengePayload, S>

  type OrderingChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderingChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderingChallengeCountAggregateInputType | true
    }

  export interface OrderingChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderingChallenge'], meta: { name: 'OrderingChallenge' } }
    /**
     * Find zero or one OrderingChallenge that matches the filter.
     * @param {OrderingChallengeFindUniqueArgs} args - Arguments to find a OrderingChallenge
     * @example
     * // Get one OrderingChallenge
     * const orderingChallenge = await prisma.orderingChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderingChallengeFindUniqueArgs>(args: SelectSubset<T, OrderingChallengeFindUniqueArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderingChallenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderingChallengeFindUniqueOrThrowArgs} args - Arguments to find a OrderingChallenge
     * @example
     * // Get one OrderingChallenge
     * const orderingChallenge = await prisma.orderingChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderingChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderingChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderingChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingChallengeFindFirstArgs} args - Arguments to find a OrderingChallenge
     * @example
     * // Get one OrderingChallenge
     * const orderingChallenge = await prisma.orderingChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderingChallengeFindFirstArgs>(args?: SelectSubset<T, OrderingChallengeFindFirstArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderingChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingChallengeFindFirstOrThrowArgs} args - Arguments to find a OrderingChallenge
     * @example
     * // Get one OrderingChallenge
     * const orderingChallenge = await prisma.orderingChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderingChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderingChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderingChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderingChallenges
     * const orderingChallenges = await prisma.orderingChallenge.findMany()
     * 
     * // Get first 10 OrderingChallenges
     * const orderingChallenges = await prisma.orderingChallenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderingChallengeWithIdOnly = await prisma.orderingChallenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderingChallengeFindManyArgs>(args?: SelectSubset<T, OrderingChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderingChallenge.
     * @param {OrderingChallengeCreateArgs} args - Arguments to create a OrderingChallenge.
     * @example
     * // Create one OrderingChallenge
     * const OrderingChallenge = await prisma.orderingChallenge.create({
     *   data: {
     *     // ... data to create a OrderingChallenge
     *   }
     * })
     * 
     */
    create<T extends OrderingChallengeCreateArgs>(args: SelectSubset<T, OrderingChallengeCreateArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderingChallenges.
     * @param {OrderingChallengeCreateManyArgs} args - Arguments to create many OrderingChallenges.
     * @example
     * // Create many OrderingChallenges
     * const orderingChallenge = await prisma.orderingChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderingChallengeCreateManyArgs>(args?: SelectSubset<T, OrderingChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderingChallenges and returns the data saved in the database.
     * @param {OrderingChallengeCreateManyAndReturnArgs} args - Arguments to create many OrderingChallenges.
     * @example
     * // Create many OrderingChallenges
     * const orderingChallenge = await prisma.orderingChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderingChallenges and only return the `id`
     * const orderingChallengeWithIdOnly = await prisma.orderingChallenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderingChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderingChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderingChallenge.
     * @param {OrderingChallengeDeleteArgs} args - Arguments to delete one OrderingChallenge.
     * @example
     * // Delete one OrderingChallenge
     * const OrderingChallenge = await prisma.orderingChallenge.delete({
     *   where: {
     *     // ... filter to delete one OrderingChallenge
     *   }
     * })
     * 
     */
    delete<T extends OrderingChallengeDeleteArgs>(args: SelectSubset<T, OrderingChallengeDeleteArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderingChallenge.
     * @param {OrderingChallengeUpdateArgs} args - Arguments to update one OrderingChallenge.
     * @example
     * // Update one OrderingChallenge
     * const orderingChallenge = await prisma.orderingChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderingChallengeUpdateArgs>(args: SelectSubset<T, OrderingChallengeUpdateArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderingChallenges.
     * @param {OrderingChallengeDeleteManyArgs} args - Arguments to filter OrderingChallenges to delete.
     * @example
     * // Delete a few OrderingChallenges
     * const { count } = await prisma.orderingChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderingChallengeDeleteManyArgs>(args?: SelectSubset<T, OrderingChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderingChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderingChallenges
     * const orderingChallenge = await prisma.orderingChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderingChallengeUpdateManyArgs>(args: SelectSubset<T, OrderingChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderingChallenges and returns the data updated in the database.
     * @param {OrderingChallengeUpdateManyAndReturnArgs} args - Arguments to update many OrderingChallenges.
     * @example
     * // Update many OrderingChallenges
     * const orderingChallenge = await prisma.orderingChallenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderingChallenges and only return the `id`
     * const orderingChallengeWithIdOnly = await prisma.orderingChallenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderingChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderingChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderingChallenge.
     * @param {OrderingChallengeUpsertArgs} args - Arguments to update or create a OrderingChallenge.
     * @example
     * // Update or create a OrderingChallenge
     * const orderingChallenge = await prisma.orderingChallenge.upsert({
     *   create: {
     *     // ... data to create a OrderingChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderingChallenge we want to update
     *   }
     * })
     */
    upsert<T extends OrderingChallengeUpsertArgs>(args: SelectSubset<T, OrderingChallengeUpsertArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderingChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingChallengeCountArgs} args - Arguments to filter OrderingChallenges to count.
     * @example
     * // Count the number of OrderingChallenges
     * const count = await prisma.orderingChallenge.count({
     *   where: {
     *     // ... the filter for the OrderingChallenges we want to count
     *   }
     * })
    **/
    count<T extends OrderingChallengeCountArgs>(
      args?: Subset<T, OrderingChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderingChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderingChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderingChallengeAggregateArgs>(args: Subset<T, OrderingChallengeAggregateArgs>): Prisma.PrismaPromise<GetOrderingChallengeAggregateType<T>>

    /**
     * Group by OrderingChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderingChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderingChallengeGroupByArgs['orderBy'] }
        : { orderBy?: OrderingChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderingChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderingChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderingChallenge model
   */
  readonly fields: OrderingChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderingChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderingChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends OrderingChallenge$itemsArgs<ExtArgs> = {}>(args?: Subset<T, OrderingChallenge$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderingChallenge model
   */
  interface OrderingChallengeFieldRefs {
    readonly id: FieldRef<"OrderingChallenge", 'String'>
    readonly challenge_id: FieldRef<"OrderingChallenge", 'String'>
    readonly instruction: FieldRef<"OrderingChallenge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderingChallenge findUnique
   */
  export type OrderingChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    /**
     * Filter, which OrderingChallenge to fetch.
     */
    where: OrderingChallengeWhereUniqueInput
  }

  /**
   * OrderingChallenge findUniqueOrThrow
   */
  export type OrderingChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    /**
     * Filter, which OrderingChallenge to fetch.
     */
    where: OrderingChallengeWhereUniqueInput
  }

  /**
   * OrderingChallenge findFirst
   */
  export type OrderingChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    /**
     * Filter, which OrderingChallenge to fetch.
     */
    where?: OrderingChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderingChallenges to fetch.
     */
    orderBy?: OrderingChallengeOrderByWithRelationInput | OrderingChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderingChallenges.
     */
    cursor?: OrderingChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderingChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderingChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderingChallenges.
     */
    distinct?: OrderingChallengeScalarFieldEnum | OrderingChallengeScalarFieldEnum[]
  }

  /**
   * OrderingChallenge findFirstOrThrow
   */
  export type OrderingChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    /**
     * Filter, which OrderingChallenge to fetch.
     */
    where?: OrderingChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderingChallenges to fetch.
     */
    orderBy?: OrderingChallengeOrderByWithRelationInput | OrderingChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderingChallenges.
     */
    cursor?: OrderingChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderingChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderingChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderingChallenges.
     */
    distinct?: OrderingChallengeScalarFieldEnum | OrderingChallengeScalarFieldEnum[]
  }

  /**
   * OrderingChallenge findMany
   */
  export type OrderingChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    /**
     * Filter, which OrderingChallenges to fetch.
     */
    where?: OrderingChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderingChallenges to fetch.
     */
    orderBy?: OrderingChallengeOrderByWithRelationInput | OrderingChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderingChallenges.
     */
    cursor?: OrderingChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderingChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderingChallenges.
     */
    skip?: number
    distinct?: OrderingChallengeScalarFieldEnum | OrderingChallengeScalarFieldEnum[]
  }

  /**
   * OrderingChallenge create
   */
  export type OrderingChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderingChallenge.
     */
    data: XOR<OrderingChallengeCreateInput, OrderingChallengeUncheckedCreateInput>
  }

  /**
   * OrderingChallenge createMany
   */
  export type OrderingChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderingChallenges.
     */
    data: OrderingChallengeCreateManyInput | OrderingChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderingChallenge createManyAndReturn
   */
  export type OrderingChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many OrderingChallenges.
     */
    data: OrderingChallengeCreateManyInput | OrderingChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderingChallenge update
   */
  export type OrderingChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderingChallenge.
     */
    data: XOR<OrderingChallengeUpdateInput, OrderingChallengeUncheckedUpdateInput>
    /**
     * Choose, which OrderingChallenge to update.
     */
    where: OrderingChallengeWhereUniqueInput
  }

  /**
   * OrderingChallenge updateMany
   */
  export type OrderingChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderingChallenges.
     */
    data: XOR<OrderingChallengeUpdateManyMutationInput, OrderingChallengeUncheckedUpdateManyInput>
    /**
     * Filter which OrderingChallenges to update
     */
    where?: OrderingChallengeWhereInput
    /**
     * Limit how many OrderingChallenges to update.
     */
    limit?: number
  }

  /**
   * OrderingChallenge updateManyAndReturn
   */
  export type OrderingChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * The data used to update OrderingChallenges.
     */
    data: XOR<OrderingChallengeUpdateManyMutationInput, OrderingChallengeUncheckedUpdateManyInput>
    /**
     * Filter which OrderingChallenges to update
     */
    where?: OrderingChallengeWhereInput
    /**
     * Limit how many OrderingChallenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderingChallenge upsert
   */
  export type OrderingChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderingChallenge to update in case it exists.
     */
    where: OrderingChallengeWhereUniqueInput
    /**
     * In case the OrderingChallenge found by the `where` argument doesn't exist, create a new OrderingChallenge with this data.
     */
    create: XOR<OrderingChallengeCreateInput, OrderingChallengeUncheckedCreateInput>
    /**
     * In case the OrderingChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderingChallengeUpdateInput, OrderingChallengeUncheckedUpdateInput>
  }

  /**
   * OrderingChallenge delete
   */
  export type OrderingChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
    /**
     * Filter which OrderingChallenge to delete.
     */
    where: OrderingChallengeWhereUniqueInput
  }

  /**
   * OrderingChallenge deleteMany
   */
  export type OrderingChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderingChallenges to delete
     */
    where?: OrderingChallengeWhereInput
    /**
     * Limit how many OrderingChallenges to delete.
     */
    limit?: number
  }

  /**
   * OrderingChallenge.items
   */
  export type OrderingChallenge$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    where?: OrderingItemWhereInput
    orderBy?: OrderingItemOrderByWithRelationInput | OrderingItemOrderByWithRelationInput[]
    cursor?: OrderingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderingItemScalarFieldEnum | OrderingItemScalarFieldEnum[]
  }

  /**
   * OrderingChallenge without action
   */
  export type OrderingChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingChallenge
     */
    select?: OrderingChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingChallenge
     */
    omit?: OrderingChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingChallengeInclude<ExtArgs> | null
  }


  /**
   * Model OrderingItem
   */

  export type AggregateOrderingItem = {
    _count: OrderingItemCountAggregateOutputType | null
    _avg: OrderingItemAvgAggregateOutputType | null
    _sum: OrderingItemSumAggregateOutputType | null
    _min: OrderingItemMinAggregateOutputType | null
    _max: OrderingItemMaxAggregateOutputType | null
  }

  export type OrderingItemAvgAggregateOutputType = {
    correct_order: number | null
  }

  export type OrderingItemSumAggregateOutputType = {
    correct_order: number | null
  }

  export type OrderingItemMinAggregateOutputType = {
    id: string | null
    ordering_id: string | null
    content: string | null
    correct_order: number | null
    explanation: string | null
  }

  export type OrderingItemMaxAggregateOutputType = {
    id: string | null
    ordering_id: string | null
    content: string | null
    correct_order: number | null
    explanation: string | null
  }

  export type OrderingItemCountAggregateOutputType = {
    id: number
    ordering_id: number
    content: number
    correct_order: number
    explanation: number
    _all: number
  }


  export type OrderingItemAvgAggregateInputType = {
    correct_order?: true
  }

  export type OrderingItemSumAggregateInputType = {
    correct_order?: true
  }

  export type OrderingItemMinAggregateInputType = {
    id?: true
    ordering_id?: true
    content?: true
    correct_order?: true
    explanation?: true
  }

  export type OrderingItemMaxAggregateInputType = {
    id?: true
    ordering_id?: true
    content?: true
    correct_order?: true
    explanation?: true
  }

  export type OrderingItemCountAggregateInputType = {
    id?: true
    ordering_id?: true
    content?: true
    correct_order?: true
    explanation?: true
    _all?: true
  }

  export type OrderingItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderingItem to aggregate.
     */
    where?: OrderingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderingItems to fetch.
     */
    orderBy?: OrderingItemOrderByWithRelationInput | OrderingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderingItems
    **/
    _count?: true | OrderingItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderingItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderingItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderingItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderingItemMaxAggregateInputType
  }

  export type GetOrderingItemAggregateType<T extends OrderingItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderingItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderingItem[P]>
      : GetScalarType<T[P], AggregateOrderingItem[P]>
  }




  export type OrderingItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderingItemWhereInput
    orderBy?: OrderingItemOrderByWithAggregationInput | OrderingItemOrderByWithAggregationInput[]
    by: OrderingItemScalarFieldEnum[] | OrderingItemScalarFieldEnum
    having?: OrderingItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderingItemCountAggregateInputType | true
    _avg?: OrderingItemAvgAggregateInputType
    _sum?: OrderingItemSumAggregateInputType
    _min?: OrderingItemMinAggregateInputType
    _max?: OrderingItemMaxAggregateInputType
  }

  export type OrderingItemGroupByOutputType = {
    id: string
    ordering_id: string
    content: string
    correct_order: number
    explanation: string | null
    _count: OrderingItemCountAggregateOutputType | null
    _avg: OrderingItemAvgAggregateOutputType | null
    _sum: OrderingItemSumAggregateOutputType | null
    _min: OrderingItemMinAggregateOutputType | null
    _max: OrderingItemMaxAggregateOutputType | null
  }

  type GetOrderingItemGroupByPayload<T extends OrderingItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderingItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderingItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderingItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderingItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderingItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordering_id?: boolean
    content?: boolean
    correct_order?: boolean
    explanation?: boolean
    orderingChallenge?: boolean | OrderingChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderingItem"]>

  export type OrderingItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordering_id?: boolean
    content?: boolean
    correct_order?: boolean
    explanation?: boolean
    orderingChallenge?: boolean | OrderingChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderingItem"]>

  export type OrderingItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordering_id?: boolean
    content?: boolean
    correct_order?: boolean
    explanation?: boolean
    orderingChallenge?: boolean | OrderingChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderingItem"]>

  export type OrderingItemSelectScalar = {
    id?: boolean
    ordering_id?: boolean
    content?: boolean
    correct_order?: boolean
    explanation?: boolean
  }

  export type OrderingItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ordering_id" | "content" | "correct_order" | "explanation", ExtArgs["result"]["orderingItem"]>
  export type OrderingItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderingChallenge?: boolean | OrderingChallengeDefaultArgs<ExtArgs>
  }
  export type OrderingItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderingChallenge?: boolean | OrderingChallengeDefaultArgs<ExtArgs>
  }
  export type OrderingItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderingChallenge?: boolean | OrderingChallengeDefaultArgs<ExtArgs>
  }

  export type $OrderingItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderingItem"
    objects: {
      orderingChallenge: Prisma.$OrderingChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ordering_id: string
      content: string
      correct_order: number
      explanation: string | null
    }, ExtArgs["result"]["orderingItem"]>
    composites: {}
  }

  type OrderingItemGetPayload<S extends boolean | null | undefined | OrderingItemDefaultArgs> = $Result.GetResult<Prisma.$OrderingItemPayload, S>

  type OrderingItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderingItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderingItemCountAggregateInputType | true
    }

  export interface OrderingItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderingItem'], meta: { name: 'OrderingItem' } }
    /**
     * Find zero or one OrderingItem that matches the filter.
     * @param {OrderingItemFindUniqueArgs} args - Arguments to find a OrderingItem
     * @example
     * // Get one OrderingItem
     * const orderingItem = await prisma.orderingItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderingItemFindUniqueArgs>(args: SelectSubset<T, OrderingItemFindUniqueArgs<ExtArgs>>): Prisma__OrderingItemClient<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderingItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderingItemFindUniqueOrThrowArgs} args - Arguments to find a OrderingItem
     * @example
     * // Get one OrderingItem
     * const orderingItem = await prisma.orderingItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderingItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderingItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderingItemClient<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderingItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingItemFindFirstArgs} args - Arguments to find a OrderingItem
     * @example
     * // Get one OrderingItem
     * const orderingItem = await prisma.orderingItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderingItemFindFirstArgs>(args?: SelectSubset<T, OrderingItemFindFirstArgs<ExtArgs>>): Prisma__OrderingItemClient<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderingItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingItemFindFirstOrThrowArgs} args - Arguments to find a OrderingItem
     * @example
     * // Get one OrderingItem
     * const orderingItem = await prisma.orderingItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderingItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderingItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderingItemClient<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderingItems
     * const orderingItems = await prisma.orderingItem.findMany()
     * 
     * // Get first 10 OrderingItems
     * const orderingItems = await prisma.orderingItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderingItemWithIdOnly = await prisma.orderingItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderingItemFindManyArgs>(args?: SelectSubset<T, OrderingItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderingItem.
     * @param {OrderingItemCreateArgs} args - Arguments to create a OrderingItem.
     * @example
     * // Create one OrderingItem
     * const OrderingItem = await prisma.orderingItem.create({
     *   data: {
     *     // ... data to create a OrderingItem
     *   }
     * })
     * 
     */
    create<T extends OrderingItemCreateArgs>(args: SelectSubset<T, OrderingItemCreateArgs<ExtArgs>>): Prisma__OrderingItemClient<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderingItems.
     * @param {OrderingItemCreateManyArgs} args - Arguments to create many OrderingItems.
     * @example
     * // Create many OrderingItems
     * const orderingItem = await prisma.orderingItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderingItemCreateManyArgs>(args?: SelectSubset<T, OrderingItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderingItems and returns the data saved in the database.
     * @param {OrderingItemCreateManyAndReturnArgs} args - Arguments to create many OrderingItems.
     * @example
     * // Create many OrderingItems
     * const orderingItem = await prisma.orderingItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderingItems and only return the `id`
     * const orderingItemWithIdOnly = await prisma.orderingItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderingItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderingItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderingItem.
     * @param {OrderingItemDeleteArgs} args - Arguments to delete one OrderingItem.
     * @example
     * // Delete one OrderingItem
     * const OrderingItem = await prisma.orderingItem.delete({
     *   where: {
     *     // ... filter to delete one OrderingItem
     *   }
     * })
     * 
     */
    delete<T extends OrderingItemDeleteArgs>(args: SelectSubset<T, OrderingItemDeleteArgs<ExtArgs>>): Prisma__OrderingItemClient<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderingItem.
     * @param {OrderingItemUpdateArgs} args - Arguments to update one OrderingItem.
     * @example
     * // Update one OrderingItem
     * const orderingItem = await prisma.orderingItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderingItemUpdateArgs>(args: SelectSubset<T, OrderingItemUpdateArgs<ExtArgs>>): Prisma__OrderingItemClient<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderingItems.
     * @param {OrderingItemDeleteManyArgs} args - Arguments to filter OrderingItems to delete.
     * @example
     * // Delete a few OrderingItems
     * const { count } = await prisma.orderingItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderingItemDeleteManyArgs>(args?: SelectSubset<T, OrderingItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderingItems
     * const orderingItem = await prisma.orderingItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderingItemUpdateManyArgs>(args: SelectSubset<T, OrderingItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderingItems and returns the data updated in the database.
     * @param {OrderingItemUpdateManyAndReturnArgs} args - Arguments to update many OrderingItems.
     * @example
     * // Update many OrderingItems
     * const orderingItem = await prisma.orderingItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderingItems and only return the `id`
     * const orderingItemWithIdOnly = await prisma.orderingItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderingItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderingItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderingItem.
     * @param {OrderingItemUpsertArgs} args - Arguments to update or create a OrderingItem.
     * @example
     * // Update or create a OrderingItem
     * const orderingItem = await prisma.orderingItem.upsert({
     *   create: {
     *     // ... data to create a OrderingItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderingItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderingItemUpsertArgs>(args: SelectSubset<T, OrderingItemUpsertArgs<ExtArgs>>): Prisma__OrderingItemClient<$Result.GetResult<Prisma.$OrderingItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingItemCountArgs} args - Arguments to filter OrderingItems to count.
     * @example
     * // Count the number of OrderingItems
     * const count = await prisma.orderingItem.count({
     *   where: {
     *     // ... the filter for the OrderingItems we want to count
     *   }
     * })
    **/
    count<T extends OrderingItemCountArgs>(
      args?: Subset<T, OrderingItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderingItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderingItemAggregateArgs>(args: Subset<T, OrderingItemAggregateArgs>): Prisma.PrismaPromise<GetOrderingItemAggregateType<T>>

    /**
     * Group by OrderingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderingItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderingItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderingItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderingItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderingItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderingItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderingItem model
   */
  readonly fields: OrderingItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderingItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderingItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderingChallenge<T extends OrderingChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderingChallengeDefaultArgs<ExtArgs>>): Prisma__OrderingChallengeClient<$Result.GetResult<Prisma.$OrderingChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderingItem model
   */
  interface OrderingItemFieldRefs {
    readonly id: FieldRef<"OrderingItem", 'String'>
    readonly ordering_id: FieldRef<"OrderingItem", 'String'>
    readonly content: FieldRef<"OrderingItem", 'String'>
    readonly correct_order: FieldRef<"OrderingItem", 'Int'>
    readonly explanation: FieldRef<"OrderingItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderingItem findUnique
   */
  export type OrderingItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderingItem to fetch.
     */
    where: OrderingItemWhereUniqueInput
  }

  /**
   * OrderingItem findUniqueOrThrow
   */
  export type OrderingItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderingItem to fetch.
     */
    where: OrderingItemWhereUniqueInput
  }

  /**
   * OrderingItem findFirst
   */
  export type OrderingItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderingItem to fetch.
     */
    where?: OrderingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderingItems to fetch.
     */
    orderBy?: OrderingItemOrderByWithRelationInput | OrderingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderingItems.
     */
    cursor?: OrderingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderingItems.
     */
    distinct?: OrderingItemScalarFieldEnum | OrderingItemScalarFieldEnum[]
  }

  /**
   * OrderingItem findFirstOrThrow
   */
  export type OrderingItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderingItem to fetch.
     */
    where?: OrderingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderingItems to fetch.
     */
    orderBy?: OrderingItemOrderByWithRelationInput | OrderingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderingItems.
     */
    cursor?: OrderingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderingItems.
     */
    distinct?: OrderingItemScalarFieldEnum | OrderingItemScalarFieldEnum[]
  }

  /**
   * OrderingItem findMany
   */
  export type OrderingItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderingItems to fetch.
     */
    where?: OrderingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderingItems to fetch.
     */
    orderBy?: OrderingItemOrderByWithRelationInput | OrderingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderingItems.
     */
    cursor?: OrderingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderingItems.
     */
    skip?: number
    distinct?: OrderingItemScalarFieldEnum | OrderingItemScalarFieldEnum[]
  }

  /**
   * OrderingItem create
   */
  export type OrderingItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderingItem.
     */
    data: XOR<OrderingItemCreateInput, OrderingItemUncheckedCreateInput>
  }

  /**
   * OrderingItem createMany
   */
  export type OrderingItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderingItems.
     */
    data: OrderingItemCreateManyInput | OrderingItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderingItem createManyAndReturn
   */
  export type OrderingItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderingItems.
     */
    data: OrderingItemCreateManyInput | OrderingItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderingItem update
   */
  export type OrderingItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderingItem.
     */
    data: XOR<OrderingItemUpdateInput, OrderingItemUncheckedUpdateInput>
    /**
     * Choose, which OrderingItem to update.
     */
    where: OrderingItemWhereUniqueInput
  }

  /**
   * OrderingItem updateMany
   */
  export type OrderingItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderingItems.
     */
    data: XOR<OrderingItemUpdateManyMutationInput, OrderingItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderingItems to update
     */
    where?: OrderingItemWhereInput
    /**
     * Limit how many OrderingItems to update.
     */
    limit?: number
  }

  /**
   * OrderingItem updateManyAndReturn
   */
  export type OrderingItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderingItems.
     */
    data: XOR<OrderingItemUpdateManyMutationInput, OrderingItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderingItems to update
     */
    where?: OrderingItemWhereInput
    /**
     * Limit how many OrderingItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderingItem upsert
   */
  export type OrderingItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderingItem to update in case it exists.
     */
    where: OrderingItemWhereUniqueInput
    /**
     * In case the OrderingItem found by the `where` argument doesn't exist, create a new OrderingItem with this data.
     */
    create: XOR<OrderingItemCreateInput, OrderingItemUncheckedCreateInput>
    /**
     * In case the OrderingItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderingItemUpdateInput, OrderingItemUncheckedUpdateInput>
  }

  /**
   * OrderingItem delete
   */
  export type OrderingItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
    /**
     * Filter which OrderingItem to delete.
     */
    where: OrderingItemWhereUniqueInput
  }

  /**
   * OrderingItem deleteMany
   */
  export type OrderingItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderingItems to delete
     */
    where?: OrderingItemWhereInput
    /**
     * Limit how many OrderingItems to delete.
     */
    limit?: number
  }

  /**
   * OrderingItem without action
   */
  export type OrderingItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderingItem
     */
    select?: OrderingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderingItem
     */
    omit?: OrderingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderingItemInclude<ExtArgs> | null
  }


  /**
   * Model FillBlankChallenge
   */

  export type AggregateFillBlankChallenge = {
    _count: FillBlankChallengeCountAggregateOutputType | null
    _min: FillBlankChallengeMinAggregateOutputType | null
    _max: FillBlankChallengeMaxAggregateOutputType | null
  }

  export type FillBlankChallengeMinAggregateOutputType = {
    id: string | null
    challenge_id: string | null
  }

  export type FillBlankChallengeMaxAggregateOutputType = {
    id: string | null
    challenge_id: string | null
  }

  export type FillBlankChallengeCountAggregateOutputType = {
    id: number
    challenge_id: number
    _all: number
  }


  export type FillBlankChallengeMinAggregateInputType = {
    id?: true
    challenge_id?: true
  }

  export type FillBlankChallengeMaxAggregateInputType = {
    id?: true
    challenge_id?: true
  }

  export type FillBlankChallengeCountAggregateInputType = {
    id?: true
    challenge_id?: true
    _all?: true
  }

  export type FillBlankChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FillBlankChallenge to aggregate.
     */
    where?: FillBlankChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FillBlankChallenges to fetch.
     */
    orderBy?: FillBlankChallengeOrderByWithRelationInput | FillBlankChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FillBlankChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FillBlankChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FillBlankChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FillBlankChallenges
    **/
    _count?: true | FillBlankChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FillBlankChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FillBlankChallengeMaxAggregateInputType
  }

  export type GetFillBlankChallengeAggregateType<T extends FillBlankChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateFillBlankChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFillBlankChallenge[P]>
      : GetScalarType<T[P], AggregateFillBlankChallenge[P]>
  }




  export type FillBlankChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FillBlankChallengeWhereInput
    orderBy?: FillBlankChallengeOrderByWithAggregationInput | FillBlankChallengeOrderByWithAggregationInput[]
    by: FillBlankChallengeScalarFieldEnum[] | FillBlankChallengeScalarFieldEnum
    having?: FillBlankChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FillBlankChallengeCountAggregateInputType | true
    _min?: FillBlankChallengeMinAggregateInputType
    _max?: FillBlankChallengeMaxAggregateInputType
  }

  export type FillBlankChallengeGroupByOutputType = {
    id: string
    challenge_id: string
    _count: FillBlankChallengeCountAggregateOutputType | null
    _min: FillBlankChallengeMinAggregateOutputType | null
    _max: FillBlankChallengeMaxAggregateOutputType | null
  }

  type GetFillBlankChallengeGroupByPayload<T extends FillBlankChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FillBlankChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FillBlankChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FillBlankChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], FillBlankChallengeGroupByOutputType[P]>
        }
      >
    >


  export type FillBlankChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    questions?: boolean | FillBlankChallenge$questionsArgs<ExtArgs>
    _count?: boolean | FillBlankChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fillBlankChallenge"]>

  export type FillBlankChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fillBlankChallenge"]>

  export type FillBlankChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fillBlankChallenge"]>

  export type FillBlankChallengeSelectScalar = {
    id?: boolean
    challenge_id?: boolean
  }

  export type FillBlankChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challenge_id", ExtArgs["result"]["fillBlankChallenge"]>
  export type FillBlankChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    questions?: boolean | FillBlankChallenge$questionsArgs<ExtArgs>
    _count?: boolean | FillBlankChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FillBlankChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type FillBlankChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $FillBlankChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FillBlankChallenge"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
      questions: Prisma.$FillBlankQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challenge_id: string
    }, ExtArgs["result"]["fillBlankChallenge"]>
    composites: {}
  }

  type FillBlankChallengeGetPayload<S extends boolean | null | undefined | FillBlankChallengeDefaultArgs> = $Result.GetResult<Prisma.$FillBlankChallengePayload, S>

  type FillBlankChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FillBlankChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FillBlankChallengeCountAggregateInputType | true
    }

  export interface FillBlankChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FillBlankChallenge'], meta: { name: 'FillBlankChallenge' } }
    /**
     * Find zero or one FillBlankChallenge that matches the filter.
     * @param {FillBlankChallengeFindUniqueArgs} args - Arguments to find a FillBlankChallenge
     * @example
     * // Get one FillBlankChallenge
     * const fillBlankChallenge = await prisma.fillBlankChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FillBlankChallengeFindUniqueArgs>(args: SelectSubset<T, FillBlankChallengeFindUniqueArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FillBlankChallenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FillBlankChallengeFindUniqueOrThrowArgs} args - Arguments to find a FillBlankChallenge
     * @example
     * // Get one FillBlankChallenge
     * const fillBlankChallenge = await prisma.fillBlankChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FillBlankChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, FillBlankChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FillBlankChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankChallengeFindFirstArgs} args - Arguments to find a FillBlankChallenge
     * @example
     * // Get one FillBlankChallenge
     * const fillBlankChallenge = await prisma.fillBlankChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FillBlankChallengeFindFirstArgs>(args?: SelectSubset<T, FillBlankChallengeFindFirstArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FillBlankChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankChallengeFindFirstOrThrowArgs} args - Arguments to find a FillBlankChallenge
     * @example
     * // Get one FillBlankChallenge
     * const fillBlankChallenge = await prisma.fillBlankChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FillBlankChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, FillBlankChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FillBlankChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FillBlankChallenges
     * const fillBlankChallenges = await prisma.fillBlankChallenge.findMany()
     * 
     * // Get first 10 FillBlankChallenges
     * const fillBlankChallenges = await prisma.fillBlankChallenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fillBlankChallengeWithIdOnly = await prisma.fillBlankChallenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FillBlankChallengeFindManyArgs>(args?: SelectSubset<T, FillBlankChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FillBlankChallenge.
     * @param {FillBlankChallengeCreateArgs} args - Arguments to create a FillBlankChallenge.
     * @example
     * // Create one FillBlankChallenge
     * const FillBlankChallenge = await prisma.fillBlankChallenge.create({
     *   data: {
     *     // ... data to create a FillBlankChallenge
     *   }
     * })
     * 
     */
    create<T extends FillBlankChallengeCreateArgs>(args: SelectSubset<T, FillBlankChallengeCreateArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FillBlankChallenges.
     * @param {FillBlankChallengeCreateManyArgs} args - Arguments to create many FillBlankChallenges.
     * @example
     * // Create many FillBlankChallenges
     * const fillBlankChallenge = await prisma.fillBlankChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FillBlankChallengeCreateManyArgs>(args?: SelectSubset<T, FillBlankChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FillBlankChallenges and returns the data saved in the database.
     * @param {FillBlankChallengeCreateManyAndReturnArgs} args - Arguments to create many FillBlankChallenges.
     * @example
     * // Create many FillBlankChallenges
     * const fillBlankChallenge = await prisma.fillBlankChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FillBlankChallenges and only return the `id`
     * const fillBlankChallengeWithIdOnly = await prisma.fillBlankChallenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FillBlankChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, FillBlankChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FillBlankChallenge.
     * @param {FillBlankChallengeDeleteArgs} args - Arguments to delete one FillBlankChallenge.
     * @example
     * // Delete one FillBlankChallenge
     * const FillBlankChallenge = await prisma.fillBlankChallenge.delete({
     *   where: {
     *     // ... filter to delete one FillBlankChallenge
     *   }
     * })
     * 
     */
    delete<T extends FillBlankChallengeDeleteArgs>(args: SelectSubset<T, FillBlankChallengeDeleteArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FillBlankChallenge.
     * @param {FillBlankChallengeUpdateArgs} args - Arguments to update one FillBlankChallenge.
     * @example
     * // Update one FillBlankChallenge
     * const fillBlankChallenge = await prisma.fillBlankChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FillBlankChallengeUpdateArgs>(args: SelectSubset<T, FillBlankChallengeUpdateArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FillBlankChallenges.
     * @param {FillBlankChallengeDeleteManyArgs} args - Arguments to filter FillBlankChallenges to delete.
     * @example
     * // Delete a few FillBlankChallenges
     * const { count } = await prisma.fillBlankChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FillBlankChallengeDeleteManyArgs>(args?: SelectSubset<T, FillBlankChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FillBlankChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FillBlankChallenges
     * const fillBlankChallenge = await prisma.fillBlankChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FillBlankChallengeUpdateManyArgs>(args: SelectSubset<T, FillBlankChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FillBlankChallenges and returns the data updated in the database.
     * @param {FillBlankChallengeUpdateManyAndReturnArgs} args - Arguments to update many FillBlankChallenges.
     * @example
     * // Update many FillBlankChallenges
     * const fillBlankChallenge = await prisma.fillBlankChallenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FillBlankChallenges and only return the `id`
     * const fillBlankChallengeWithIdOnly = await prisma.fillBlankChallenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FillBlankChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, FillBlankChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FillBlankChallenge.
     * @param {FillBlankChallengeUpsertArgs} args - Arguments to update or create a FillBlankChallenge.
     * @example
     * // Update or create a FillBlankChallenge
     * const fillBlankChallenge = await prisma.fillBlankChallenge.upsert({
     *   create: {
     *     // ... data to create a FillBlankChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FillBlankChallenge we want to update
     *   }
     * })
     */
    upsert<T extends FillBlankChallengeUpsertArgs>(args: SelectSubset<T, FillBlankChallengeUpsertArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FillBlankChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankChallengeCountArgs} args - Arguments to filter FillBlankChallenges to count.
     * @example
     * // Count the number of FillBlankChallenges
     * const count = await prisma.fillBlankChallenge.count({
     *   where: {
     *     // ... the filter for the FillBlankChallenges we want to count
     *   }
     * })
    **/
    count<T extends FillBlankChallengeCountArgs>(
      args?: Subset<T, FillBlankChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FillBlankChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FillBlankChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FillBlankChallengeAggregateArgs>(args: Subset<T, FillBlankChallengeAggregateArgs>): Prisma.PrismaPromise<GetFillBlankChallengeAggregateType<T>>

    /**
     * Group by FillBlankChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FillBlankChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FillBlankChallengeGroupByArgs['orderBy'] }
        : { orderBy?: FillBlankChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FillBlankChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFillBlankChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FillBlankChallenge model
   */
  readonly fields: FillBlankChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FillBlankChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FillBlankChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends FillBlankChallenge$questionsArgs<ExtArgs> = {}>(args?: Subset<T, FillBlankChallenge$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FillBlankChallenge model
   */
  interface FillBlankChallengeFieldRefs {
    readonly id: FieldRef<"FillBlankChallenge", 'String'>
    readonly challenge_id: FieldRef<"FillBlankChallenge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FillBlankChallenge findUnique
   */
  export type FillBlankChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankChallenge to fetch.
     */
    where: FillBlankChallengeWhereUniqueInput
  }

  /**
   * FillBlankChallenge findUniqueOrThrow
   */
  export type FillBlankChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankChallenge to fetch.
     */
    where: FillBlankChallengeWhereUniqueInput
  }

  /**
   * FillBlankChallenge findFirst
   */
  export type FillBlankChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankChallenge to fetch.
     */
    where?: FillBlankChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FillBlankChallenges to fetch.
     */
    orderBy?: FillBlankChallengeOrderByWithRelationInput | FillBlankChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FillBlankChallenges.
     */
    cursor?: FillBlankChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FillBlankChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FillBlankChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FillBlankChallenges.
     */
    distinct?: FillBlankChallengeScalarFieldEnum | FillBlankChallengeScalarFieldEnum[]
  }

  /**
   * FillBlankChallenge findFirstOrThrow
   */
  export type FillBlankChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankChallenge to fetch.
     */
    where?: FillBlankChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FillBlankChallenges to fetch.
     */
    orderBy?: FillBlankChallengeOrderByWithRelationInput | FillBlankChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FillBlankChallenges.
     */
    cursor?: FillBlankChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FillBlankChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FillBlankChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FillBlankChallenges.
     */
    distinct?: FillBlankChallengeScalarFieldEnum | FillBlankChallengeScalarFieldEnum[]
  }

  /**
   * FillBlankChallenge findMany
   */
  export type FillBlankChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankChallenges to fetch.
     */
    where?: FillBlankChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FillBlankChallenges to fetch.
     */
    orderBy?: FillBlankChallengeOrderByWithRelationInput | FillBlankChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FillBlankChallenges.
     */
    cursor?: FillBlankChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FillBlankChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FillBlankChallenges.
     */
    skip?: number
    distinct?: FillBlankChallengeScalarFieldEnum | FillBlankChallengeScalarFieldEnum[]
  }

  /**
   * FillBlankChallenge create
   */
  export type FillBlankChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a FillBlankChallenge.
     */
    data: XOR<FillBlankChallengeCreateInput, FillBlankChallengeUncheckedCreateInput>
  }

  /**
   * FillBlankChallenge createMany
   */
  export type FillBlankChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FillBlankChallenges.
     */
    data: FillBlankChallengeCreateManyInput | FillBlankChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FillBlankChallenge createManyAndReturn
   */
  export type FillBlankChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many FillBlankChallenges.
     */
    data: FillBlankChallengeCreateManyInput | FillBlankChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FillBlankChallenge update
   */
  export type FillBlankChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a FillBlankChallenge.
     */
    data: XOR<FillBlankChallengeUpdateInput, FillBlankChallengeUncheckedUpdateInput>
    /**
     * Choose, which FillBlankChallenge to update.
     */
    where: FillBlankChallengeWhereUniqueInput
  }

  /**
   * FillBlankChallenge updateMany
   */
  export type FillBlankChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FillBlankChallenges.
     */
    data: XOR<FillBlankChallengeUpdateManyMutationInput, FillBlankChallengeUncheckedUpdateManyInput>
    /**
     * Filter which FillBlankChallenges to update
     */
    where?: FillBlankChallengeWhereInput
    /**
     * Limit how many FillBlankChallenges to update.
     */
    limit?: number
  }

  /**
   * FillBlankChallenge updateManyAndReturn
   */
  export type FillBlankChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * The data used to update FillBlankChallenges.
     */
    data: XOR<FillBlankChallengeUpdateManyMutationInput, FillBlankChallengeUncheckedUpdateManyInput>
    /**
     * Filter which FillBlankChallenges to update
     */
    where?: FillBlankChallengeWhereInput
    /**
     * Limit how many FillBlankChallenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FillBlankChallenge upsert
   */
  export type FillBlankChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the FillBlankChallenge to update in case it exists.
     */
    where: FillBlankChallengeWhereUniqueInput
    /**
     * In case the FillBlankChallenge found by the `where` argument doesn't exist, create a new FillBlankChallenge with this data.
     */
    create: XOR<FillBlankChallengeCreateInput, FillBlankChallengeUncheckedCreateInput>
    /**
     * In case the FillBlankChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FillBlankChallengeUpdateInput, FillBlankChallengeUncheckedUpdateInput>
  }

  /**
   * FillBlankChallenge delete
   */
  export type FillBlankChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
    /**
     * Filter which FillBlankChallenge to delete.
     */
    where: FillBlankChallengeWhereUniqueInput
  }

  /**
   * FillBlankChallenge deleteMany
   */
  export type FillBlankChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FillBlankChallenges to delete
     */
    where?: FillBlankChallengeWhereInput
    /**
     * Limit how many FillBlankChallenges to delete.
     */
    limit?: number
  }

  /**
   * FillBlankChallenge.questions
   */
  export type FillBlankChallenge$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    where?: FillBlankQuestionWhereInput
    orderBy?: FillBlankQuestionOrderByWithRelationInput | FillBlankQuestionOrderByWithRelationInput[]
    cursor?: FillBlankQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FillBlankQuestionScalarFieldEnum | FillBlankQuestionScalarFieldEnum[]
  }

  /**
   * FillBlankChallenge without action
   */
  export type FillBlankChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankChallenge
     */
    select?: FillBlankChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankChallenge
     */
    omit?: FillBlankChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankChallengeInclude<ExtArgs> | null
  }


  /**
   * Model FillBlankQuestion
   */

  export type AggregateFillBlankQuestion = {
    _count: FillBlankQuestionCountAggregateOutputType | null
    _min: FillBlankQuestionMinAggregateOutputType | null
    _max: FillBlankQuestionMaxAggregateOutputType | null
  }

  export type FillBlankQuestionMinAggregateOutputType = {
    id: string | null
    challenge_id: string | null
    sentence: string | null
    correct_word: string | null
  }

  export type FillBlankQuestionMaxAggregateOutputType = {
    id: string | null
    challenge_id: string | null
    sentence: string | null
    correct_word: string | null
  }

  export type FillBlankQuestionCountAggregateOutputType = {
    id: number
    challenge_id: number
    sentence: number
    correct_word: number
    _all: number
  }


  export type FillBlankQuestionMinAggregateInputType = {
    id?: true
    challenge_id?: true
    sentence?: true
    correct_word?: true
  }

  export type FillBlankQuestionMaxAggregateInputType = {
    id?: true
    challenge_id?: true
    sentence?: true
    correct_word?: true
  }

  export type FillBlankQuestionCountAggregateInputType = {
    id?: true
    challenge_id?: true
    sentence?: true
    correct_word?: true
    _all?: true
  }

  export type FillBlankQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FillBlankQuestion to aggregate.
     */
    where?: FillBlankQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FillBlankQuestions to fetch.
     */
    orderBy?: FillBlankQuestionOrderByWithRelationInput | FillBlankQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FillBlankQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FillBlankQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FillBlankQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FillBlankQuestions
    **/
    _count?: true | FillBlankQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FillBlankQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FillBlankQuestionMaxAggregateInputType
  }

  export type GetFillBlankQuestionAggregateType<T extends FillBlankQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateFillBlankQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFillBlankQuestion[P]>
      : GetScalarType<T[P], AggregateFillBlankQuestion[P]>
  }




  export type FillBlankQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FillBlankQuestionWhereInput
    orderBy?: FillBlankQuestionOrderByWithAggregationInput | FillBlankQuestionOrderByWithAggregationInput[]
    by: FillBlankQuestionScalarFieldEnum[] | FillBlankQuestionScalarFieldEnum
    having?: FillBlankQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FillBlankQuestionCountAggregateInputType | true
    _min?: FillBlankQuestionMinAggregateInputType
    _max?: FillBlankQuestionMaxAggregateInputType
  }

  export type FillBlankQuestionGroupByOutputType = {
    id: string
    challenge_id: string
    sentence: string
    correct_word: string
    _count: FillBlankQuestionCountAggregateOutputType | null
    _min: FillBlankQuestionMinAggregateOutputType | null
    _max: FillBlankQuestionMaxAggregateOutputType | null
  }

  type GetFillBlankQuestionGroupByPayload<T extends FillBlankQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FillBlankQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FillBlankQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FillBlankQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], FillBlankQuestionGroupByOutputType[P]>
        }
      >
    >


  export type FillBlankQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    sentence?: boolean
    correct_word?: boolean
    challenge?: boolean | FillBlankChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fillBlankQuestion"]>

  export type FillBlankQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    sentence?: boolean
    correct_word?: boolean
    challenge?: boolean | FillBlankChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fillBlankQuestion"]>

  export type FillBlankQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    sentence?: boolean
    correct_word?: boolean
    challenge?: boolean | FillBlankChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fillBlankQuestion"]>

  export type FillBlankQuestionSelectScalar = {
    id?: boolean
    challenge_id?: boolean
    sentence?: boolean
    correct_word?: boolean
  }

  export type FillBlankQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challenge_id" | "sentence" | "correct_word", ExtArgs["result"]["fillBlankQuestion"]>
  export type FillBlankQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | FillBlankChallengeDefaultArgs<ExtArgs>
  }
  export type FillBlankQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | FillBlankChallengeDefaultArgs<ExtArgs>
  }
  export type FillBlankQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | FillBlankChallengeDefaultArgs<ExtArgs>
  }

  export type $FillBlankQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FillBlankQuestion"
    objects: {
      challenge: Prisma.$FillBlankChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challenge_id: string
      sentence: string
      correct_word: string
    }, ExtArgs["result"]["fillBlankQuestion"]>
    composites: {}
  }

  type FillBlankQuestionGetPayload<S extends boolean | null | undefined | FillBlankQuestionDefaultArgs> = $Result.GetResult<Prisma.$FillBlankQuestionPayload, S>

  type FillBlankQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FillBlankQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FillBlankQuestionCountAggregateInputType | true
    }

  export interface FillBlankQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FillBlankQuestion'], meta: { name: 'FillBlankQuestion' } }
    /**
     * Find zero or one FillBlankQuestion that matches the filter.
     * @param {FillBlankQuestionFindUniqueArgs} args - Arguments to find a FillBlankQuestion
     * @example
     * // Get one FillBlankQuestion
     * const fillBlankQuestion = await prisma.fillBlankQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FillBlankQuestionFindUniqueArgs>(args: SelectSubset<T, FillBlankQuestionFindUniqueArgs<ExtArgs>>): Prisma__FillBlankQuestionClient<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FillBlankQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FillBlankQuestionFindUniqueOrThrowArgs} args - Arguments to find a FillBlankQuestion
     * @example
     * // Get one FillBlankQuestion
     * const fillBlankQuestion = await prisma.fillBlankQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FillBlankQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, FillBlankQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FillBlankQuestionClient<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FillBlankQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankQuestionFindFirstArgs} args - Arguments to find a FillBlankQuestion
     * @example
     * // Get one FillBlankQuestion
     * const fillBlankQuestion = await prisma.fillBlankQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FillBlankQuestionFindFirstArgs>(args?: SelectSubset<T, FillBlankQuestionFindFirstArgs<ExtArgs>>): Prisma__FillBlankQuestionClient<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FillBlankQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankQuestionFindFirstOrThrowArgs} args - Arguments to find a FillBlankQuestion
     * @example
     * // Get one FillBlankQuestion
     * const fillBlankQuestion = await prisma.fillBlankQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FillBlankQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, FillBlankQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FillBlankQuestionClient<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FillBlankQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FillBlankQuestions
     * const fillBlankQuestions = await prisma.fillBlankQuestion.findMany()
     * 
     * // Get first 10 FillBlankQuestions
     * const fillBlankQuestions = await prisma.fillBlankQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fillBlankQuestionWithIdOnly = await prisma.fillBlankQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FillBlankQuestionFindManyArgs>(args?: SelectSubset<T, FillBlankQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FillBlankQuestion.
     * @param {FillBlankQuestionCreateArgs} args - Arguments to create a FillBlankQuestion.
     * @example
     * // Create one FillBlankQuestion
     * const FillBlankQuestion = await prisma.fillBlankQuestion.create({
     *   data: {
     *     // ... data to create a FillBlankQuestion
     *   }
     * })
     * 
     */
    create<T extends FillBlankQuestionCreateArgs>(args: SelectSubset<T, FillBlankQuestionCreateArgs<ExtArgs>>): Prisma__FillBlankQuestionClient<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FillBlankQuestions.
     * @param {FillBlankQuestionCreateManyArgs} args - Arguments to create many FillBlankQuestions.
     * @example
     * // Create many FillBlankQuestions
     * const fillBlankQuestion = await prisma.fillBlankQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FillBlankQuestionCreateManyArgs>(args?: SelectSubset<T, FillBlankQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FillBlankQuestions and returns the data saved in the database.
     * @param {FillBlankQuestionCreateManyAndReturnArgs} args - Arguments to create many FillBlankQuestions.
     * @example
     * // Create many FillBlankQuestions
     * const fillBlankQuestion = await prisma.fillBlankQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FillBlankQuestions and only return the `id`
     * const fillBlankQuestionWithIdOnly = await prisma.fillBlankQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FillBlankQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, FillBlankQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FillBlankQuestion.
     * @param {FillBlankQuestionDeleteArgs} args - Arguments to delete one FillBlankQuestion.
     * @example
     * // Delete one FillBlankQuestion
     * const FillBlankQuestion = await prisma.fillBlankQuestion.delete({
     *   where: {
     *     // ... filter to delete one FillBlankQuestion
     *   }
     * })
     * 
     */
    delete<T extends FillBlankQuestionDeleteArgs>(args: SelectSubset<T, FillBlankQuestionDeleteArgs<ExtArgs>>): Prisma__FillBlankQuestionClient<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FillBlankQuestion.
     * @param {FillBlankQuestionUpdateArgs} args - Arguments to update one FillBlankQuestion.
     * @example
     * // Update one FillBlankQuestion
     * const fillBlankQuestion = await prisma.fillBlankQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FillBlankQuestionUpdateArgs>(args: SelectSubset<T, FillBlankQuestionUpdateArgs<ExtArgs>>): Prisma__FillBlankQuestionClient<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FillBlankQuestions.
     * @param {FillBlankQuestionDeleteManyArgs} args - Arguments to filter FillBlankQuestions to delete.
     * @example
     * // Delete a few FillBlankQuestions
     * const { count } = await prisma.fillBlankQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FillBlankQuestionDeleteManyArgs>(args?: SelectSubset<T, FillBlankQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FillBlankQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FillBlankQuestions
     * const fillBlankQuestion = await prisma.fillBlankQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FillBlankQuestionUpdateManyArgs>(args: SelectSubset<T, FillBlankQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FillBlankQuestions and returns the data updated in the database.
     * @param {FillBlankQuestionUpdateManyAndReturnArgs} args - Arguments to update many FillBlankQuestions.
     * @example
     * // Update many FillBlankQuestions
     * const fillBlankQuestion = await prisma.fillBlankQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FillBlankQuestions and only return the `id`
     * const fillBlankQuestionWithIdOnly = await prisma.fillBlankQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FillBlankQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, FillBlankQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FillBlankQuestion.
     * @param {FillBlankQuestionUpsertArgs} args - Arguments to update or create a FillBlankQuestion.
     * @example
     * // Update or create a FillBlankQuestion
     * const fillBlankQuestion = await prisma.fillBlankQuestion.upsert({
     *   create: {
     *     // ... data to create a FillBlankQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FillBlankQuestion we want to update
     *   }
     * })
     */
    upsert<T extends FillBlankQuestionUpsertArgs>(args: SelectSubset<T, FillBlankQuestionUpsertArgs<ExtArgs>>): Prisma__FillBlankQuestionClient<$Result.GetResult<Prisma.$FillBlankQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FillBlankQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankQuestionCountArgs} args - Arguments to filter FillBlankQuestions to count.
     * @example
     * // Count the number of FillBlankQuestions
     * const count = await prisma.fillBlankQuestion.count({
     *   where: {
     *     // ... the filter for the FillBlankQuestions we want to count
     *   }
     * })
    **/
    count<T extends FillBlankQuestionCountArgs>(
      args?: Subset<T, FillBlankQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FillBlankQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FillBlankQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FillBlankQuestionAggregateArgs>(args: Subset<T, FillBlankQuestionAggregateArgs>): Prisma.PrismaPromise<GetFillBlankQuestionAggregateType<T>>

    /**
     * Group by FillBlankQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FillBlankQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FillBlankQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FillBlankQuestionGroupByArgs['orderBy'] }
        : { orderBy?: FillBlankQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FillBlankQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFillBlankQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FillBlankQuestion model
   */
  readonly fields: FillBlankQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FillBlankQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FillBlankQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends FillBlankChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FillBlankChallengeDefaultArgs<ExtArgs>>): Prisma__FillBlankChallengeClient<$Result.GetResult<Prisma.$FillBlankChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FillBlankQuestion model
   */
  interface FillBlankQuestionFieldRefs {
    readonly id: FieldRef<"FillBlankQuestion", 'String'>
    readonly challenge_id: FieldRef<"FillBlankQuestion", 'String'>
    readonly sentence: FieldRef<"FillBlankQuestion", 'String'>
    readonly correct_word: FieldRef<"FillBlankQuestion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FillBlankQuestion findUnique
   */
  export type FillBlankQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankQuestion to fetch.
     */
    where: FillBlankQuestionWhereUniqueInput
  }

  /**
   * FillBlankQuestion findUniqueOrThrow
   */
  export type FillBlankQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankQuestion to fetch.
     */
    where: FillBlankQuestionWhereUniqueInput
  }

  /**
   * FillBlankQuestion findFirst
   */
  export type FillBlankQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankQuestion to fetch.
     */
    where?: FillBlankQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FillBlankQuestions to fetch.
     */
    orderBy?: FillBlankQuestionOrderByWithRelationInput | FillBlankQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FillBlankQuestions.
     */
    cursor?: FillBlankQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FillBlankQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FillBlankQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FillBlankQuestions.
     */
    distinct?: FillBlankQuestionScalarFieldEnum | FillBlankQuestionScalarFieldEnum[]
  }

  /**
   * FillBlankQuestion findFirstOrThrow
   */
  export type FillBlankQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankQuestion to fetch.
     */
    where?: FillBlankQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FillBlankQuestions to fetch.
     */
    orderBy?: FillBlankQuestionOrderByWithRelationInput | FillBlankQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FillBlankQuestions.
     */
    cursor?: FillBlankQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FillBlankQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FillBlankQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FillBlankQuestions.
     */
    distinct?: FillBlankQuestionScalarFieldEnum | FillBlankQuestionScalarFieldEnum[]
  }

  /**
   * FillBlankQuestion findMany
   */
  export type FillBlankQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FillBlankQuestions to fetch.
     */
    where?: FillBlankQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FillBlankQuestions to fetch.
     */
    orderBy?: FillBlankQuestionOrderByWithRelationInput | FillBlankQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FillBlankQuestions.
     */
    cursor?: FillBlankQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FillBlankQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FillBlankQuestions.
     */
    skip?: number
    distinct?: FillBlankQuestionScalarFieldEnum | FillBlankQuestionScalarFieldEnum[]
  }

  /**
   * FillBlankQuestion create
   */
  export type FillBlankQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a FillBlankQuestion.
     */
    data: XOR<FillBlankQuestionCreateInput, FillBlankQuestionUncheckedCreateInput>
  }

  /**
   * FillBlankQuestion createMany
   */
  export type FillBlankQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FillBlankQuestions.
     */
    data: FillBlankQuestionCreateManyInput | FillBlankQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FillBlankQuestion createManyAndReturn
   */
  export type FillBlankQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many FillBlankQuestions.
     */
    data: FillBlankQuestionCreateManyInput | FillBlankQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FillBlankQuestion update
   */
  export type FillBlankQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a FillBlankQuestion.
     */
    data: XOR<FillBlankQuestionUpdateInput, FillBlankQuestionUncheckedUpdateInput>
    /**
     * Choose, which FillBlankQuestion to update.
     */
    where: FillBlankQuestionWhereUniqueInput
  }

  /**
   * FillBlankQuestion updateMany
   */
  export type FillBlankQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FillBlankQuestions.
     */
    data: XOR<FillBlankQuestionUpdateManyMutationInput, FillBlankQuestionUncheckedUpdateManyInput>
    /**
     * Filter which FillBlankQuestions to update
     */
    where?: FillBlankQuestionWhereInput
    /**
     * Limit how many FillBlankQuestions to update.
     */
    limit?: number
  }

  /**
   * FillBlankQuestion updateManyAndReturn
   */
  export type FillBlankQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * The data used to update FillBlankQuestions.
     */
    data: XOR<FillBlankQuestionUpdateManyMutationInput, FillBlankQuestionUncheckedUpdateManyInput>
    /**
     * Filter which FillBlankQuestions to update
     */
    where?: FillBlankQuestionWhereInput
    /**
     * Limit how many FillBlankQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FillBlankQuestion upsert
   */
  export type FillBlankQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the FillBlankQuestion to update in case it exists.
     */
    where: FillBlankQuestionWhereUniqueInput
    /**
     * In case the FillBlankQuestion found by the `where` argument doesn't exist, create a new FillBlankQuestion with this data.
     */
    create: XOR<FillBlankQuestionCreateInput, FillBlankQuestionUncheckedCreateInput>
    /**
     * In case the FillBlankQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FillBlankQuestionUpdateInput, FillBlankQuestionUncheckedUpdateInput>
  }

  /**
   * FillBlankQuestion delete
   */
  export type FillBlankQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
    /**
     * Filter which FillBlankQuestion to delete.
     */
    where: FillBlankQuestionWhereUniqueInput
  }

  /**
   * FillBlankQuestion deleteMany
   */
  export type FillBlankQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FillBlankQuestions to delete
     */
    where?: FillBlankQuestionWhereInput
    /**
     * Limit how many FillBlankQuestions to delete.
     */
    limit?: number
  }

  /**
   * FillBlankQuestion without action
   */
  export type FillBlankQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FillBlankQuestion
     */
    select?: FillBlankQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FillBlankQuestion
     */
    omit?: FillBlankQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FillBlankQuestionInclude<ExtArgs> | null
  }


  /**
   * Model UserLessonProgress
   */

  export type AggregateUserLessonProgress = {
    _count: UserLessonProgressCountAggregateOutputType | null
    _min: UserLessonProgressMinAggregateOutputType | null
    _max: UserLessonProgressMaxAggregateOutputType | null
  }

  export type UserLessonProgressMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    lesson_id: string | null
    completed_at: Date | null
  }

  export type UserLessonProgressMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    lesson_id: string | null
    completed_at: Date | null
  }

  export type UserLessonProgressCountAggregateOutputType = {
    id: number
    user_id: number
    lesson_id: number
    completed_at: number
    _all: number
  }


  export type UserLessonProgressMinAggregateInputType = {
    id?: true
    user_id?: true
    lesson_id?: true
    completed_at?: true
  }

  export type UserLessonProgressMaxAggregateInputType = {
    id?: true
    user_id?: true
    lesson_id?: true
    completed_at?: true
  }

  export type UserLessonProgressCountAggregateInputType = {
    id?: true
    user_id?: true
    lesson_id?: true
    completed_at?: true
    _all?: true
  }

  export type UserLessonProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLessonProgress to aggregate.
     */
    where?: UserLessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonProgresses to fetch.
     */
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLessonProgresses
    **/
    _count?: true | UserLessonProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLessonProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLessonProgressMaxAggregateInputType
  }

  export type GetUserLessonProgressAggregateType<T extends UserLessonProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLessonProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLessonProgress[P]>
      : GetScalarType<T[P], AggregateUserLessonProgress[P]>
  }




  export type UserLessonProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLessonProgressWhereInput
    orderBy?: UserLessonProgressOrderByWithAggregationInput | UserLessonProgressOrderByWithAggregationInput[]
    by: UserLessonProgressScalarFieldEnum[] | UserLessonProgressScalarFieldEnum
    having?: UserLessonProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLessonProgressCountAggregateInputType | true
    _min?: UserLessonProgressMinAggregateInputType
    _max?: UserLessonProgressMaxAggregateInputType
  }

  export type UserLessonProgressGroupByOutputType = {
    id: string
    user_id: string
    lesson_id: string
    completed_at: Date | null
    _count: UserLessonProgressCountAggregateOutputType | null
    _min: UserLessonProgressMinAggregateOutputType | null
    _max: UserLessonProgressMaxAggregateOutputType | null
  }

  type GetUserLessonProgressGroupByPayload<T extends UserLessonProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLessonProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLessonProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLessonProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserLessonProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserLessonProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    lesson_id?: boolean
    completed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLessonProgress"]>

  export type UserLessonProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    lesson_id?: boolean
    completed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLessonProgress"]>

  export type UserLessonProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    lesson_id?: boolean
    completed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLessonProgress"]>

  export type UserLessonProgressSelectScalar = {
    id?: boolean
    user_id?: boolean
    lesson_id?: boolean
    completed_at?: boolean
  }

  export type UserLessonProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "lesson_id" | "completed_at", ExtArgs["result"]["userLessonProgress"]>
  export type UserLessonProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type UserLessonProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type UserLessonProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $UserLessonProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLessonProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      lesson_id: string
      completed_at: Date | null
    }, ExtArgs["result"]["userLessonProgress"]>
    composites: {}
  }

  type UserLessonProgressGetPayload<S extends boolean | null | undefined | UserLessonProgressDefaultArgs> = $Result.GetResult<Prisma.$UserLessonProgressPayload, S>

  type UserLessonProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLessonProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLessonProgressCountAggregateInputType | true
    }

  export interface UserLessonProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLessonProgress'], meta: { name: 'UserLessonProgress' } }
    /**
     * Find zero or one UserLessonProgress that matches the filter.
     * @param {UserLessonProgressFindUniqueArgs} args - Arguments to find a UserLessonProgress
     * @example
     * // Get one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLessonProgressFindUniqueArgs>(args: SelectSubset<T, UserLessonProgressFindUniqueArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLessonProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLessonProgressFindUniqueOrThrowArgs} args - Arguments to find a UserLessonProgress
     * @example
     * // Get one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLessonProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLessonProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLessonProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressFindFirstArgs} args - Arguments to find a UserLessonProgress
     * @example
     * // Get one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLessonProgressFindFirstArgs>(args?: SelectSubset<T, UserLessonProgressFindFirstArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLessonProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressFindFirstOrThrowArgs} args - Arguments to find a UserLessonProgress
     * @example
     * // Get one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLessonProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLessonProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLessonProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLessonProgresses
     * const userLessonProgresses = await prisma.userLessonProgress.findMany()
     * 
     * // Get first 10 UserLessonProgresses
     * const userLessonProgresses = await prisma.userLessonProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLessonProgressWithIdOnly = await prisma.userLessonProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLessonProgressFindManyArgs>(args?: SelectSubset<T, UserLessonProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLessonProgress.
     * @param {UserLessonProgressCreateArgs} args - Arguments to create a UserLessonProgress.
     * @example
     * // Create one UserLessonProgress
     * const UserLessonProgress = await prisma.userLessonProgress.create({
     *   data: {
     *     // ... data to create a UserLessonProgress
     *   }
     * })
     * 
     */
    create<T extends UserLessonProgressCreateArgs>(args: SelectSubset<T, UserLessonProgressCreateArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLessonProgresses.
     * @param {UserLessonProgressCreateManyArgs} args - Arguments to create many UserLessonProgresses.
     * @example
     * // Create many UserLessonProgresses
     * const userLessonProgress = await prisma.userLessonProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLessonProgressCreateManyArgs>(args?: SelectSubset<T, UserLessonProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLessonProgresses and returns the data saved in the database.
     * @param {UserLessonProgressCreateManyAndReturnArgs} args - Arguments to create many UserLessonProgresses.
     * @example
     * // Create many UserLessonProgresses
     * const userLessonProgress = await prisma.userLessonProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLessonProgresses and only return the `id`
     * const userLessonProgressWithIdOnly = await prisma.userLessonProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLessonProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLessonProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLessonProgress.
     * @param {UserLessonProgressDeleteArgs} args - Arguments to delete one UserLessonProgress.
     * @example
     * // Delete one UserLessonProgress
     * const UserLessonProgress = await prisma.userLessonProgress.delete({
     *   where: {
     *     // ... filter to delete one UserLessonProgress
     *   }
     * })
     * 
     */
    delete<T extends UserLessonProgressDeleteArgs>(args: SelectSubset<T, UserLessonProgressDeleteArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLessonProgress.
     * @param {UserLessonProgressUpdateArgs} args - Arguments to update one UserLessonProgress.
     * @example
     * // Update one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLessonProgressUpdateArgs>(args: SelectSubset<T, UserLessonProgressUpdateArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLessonProgresses.
     * @param {UserLessonProgressDeleteManyArgs} args - Arguments to filter UserLessonProgresses to delete.
     * @example
     * // Delete a few UserLessonProgresses
     * const { count } = await prisma.userLessonProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLessonProgressDeleteManyArgs>(args?: SelectSubset<T, UserLessonProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLessonProgresses
     * const userLessonProgress = await prisma.userLessonProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLessonProgressUpdateManyArgs>(args: SelectSubset<T, UserLessonProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLessonProgresses and returns the data updated in the database.
     * @param {UserLessonProgressUpdateManyAndReturnArgs} args - Arguments to update many UserLessonProgresses.
     * @example
     * // Update many UserLessonProgresses
     * const userLessonProgress = await prisma.userLessonProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLessonProgresses and only return the `id`
     * const userLessonProgressWithIdOnly = await prisma.userLessonProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLessonProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLessonProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLessonProgress.
     * @param {UserLessonProgressUpsertArgs} args - Arguments to update or create a UserLessonProgress.
     * @example
     * // Update or create a UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.upsert({
     *   create: {
     *     // ... data to create a UserLessonProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLessonProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserLessonProgressUpsertArgs>(args: SelectSubset<T, UserLessonProgressUpsertArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressCountArgs} args - Arguments to filter UserLessonProgresses to count.
     * @example
     * // Count the number of UserLessonProgresses
     * const count = await prisma.userLessonProgress.count({
     *   where: {
     *     // ... the filter for the UserLessonProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserLessonProgressCountArgs>(
      args?: Subset<T, UserLessonProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLessonProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLessonProgressAggregateArgs>(args: Subset<T, UserLessonProgressAggregateArgs>): Prisma.PrismaPromise<GetUserLessonProgressAggregateType<T>>

    /**
     * Group by UserLessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLessonProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLessonProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserLessonProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLessonProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLessonProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLessonProgress model
   */
  readonly fields: UserLessonProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLessonProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLessonProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLessonProgress model
   */
  interface UserLessonProgressFieldRefs {
    readonly id: FieldRef<"UserLessonProgress", 'String'>
    readonly user_id: FieldRef<"UserLessonProgress", 'String'>
    readonly lesson_id: FieldRef<"UserLessonProgress", 'String'>
    readonly completed_at: FieldRef<"UserLessonProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLessonProgress findUnique
   */
  export type UserLessonProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgress to fetch.
     */
    where: UserLessonProgressWhereUniqueInput
  }

  /**
   * UserLessonProgress findUniqueOrThrow
   */
  export type UserLessonProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgress to fetch.
     */
    where: UserLessonProgressWhereUniqueInput
  }

  /**
   * UserLessonProgress findFirst
   */
  export type UserLessonProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgress to fetch.
     */
    where?: UserLessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonProgresses to fetch.
     */
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLessonProgresses.
     */
    cursor?: UserLessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLessonProgresses.
     */
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * UserLessonProgress findFirstOrThrow
   */
  export type UserLessonProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgress to fetch.
     */
    where?: UserLessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonProgresses to fetch.
     */
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLessonProgresses.
     */
    cursor?: UserLessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLessonProgresses.
     */
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * UserLessonProgress findMany
   */
  export type UserLessonProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgresses to fetch.
     */
    where?: UserLessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonProgresses to fetch.
     */
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLessonProgresses.
     */
    cursor?: UserLessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonProgresses.
     */
    skip?: number
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * UserLessonProgress create
   */
  export type UserLessonProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLessonProgress.
     */
    data: XOR<UserLessonProgressCreateInput, UserLessonProgressUncheckedCreateInput>
  }

  /**
   * UserLessonProgress createMany
   */
  export type UserLessonProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLessonProgresses.
     */
    data: UserLessonProgressCreateManyInput | UserLessonProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLessonProgress createManyAndReturn
   */
  export type UserLessonProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserLessonProgresses.
     */
    data: UserLessonProgressCreateManyInput | UserLessonProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLessonProgress update
   */
  export type UserLessonProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLessonProgress.
     */
    data: XOR<UserLessonProgressUpdateInput, UserLessonProgressUncheckedUpdateInput>
    /**
     * Choose, which UserLessonProgress to update.
     */
    where: UserLessonProgressWhereUniqueInput
  }

  /**
   * UserLessonProgress updateMany
   */
  export type UserLessonProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLessonProgresses.
     */
    data: XOR<UserLessonProgressUpdateManyMutationInput, UserLessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserLessonProgresses to update
     */
    where?: UserLessonProgressWhereInput
    /**
     * Limit how many UserLessonProgresses to update.
     */
    limit?: number
  }

  /**
   * UserLessonProgress updateManyAndReturn
   */
  export type UserLessonProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserLessonProgresses.
     */
    data: XOR<UserLessonProgressUpdateManyMutationInput, UserLessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserLessonProgresses to update
     */
    where?: UserLessonProgressWhereInput
    /**
     * Limit how many UserLessonProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLessonProgress upsert
   */
  export type UserLessonProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLessonProgress to update in case it exists.
     */
    where: UserLessonProgressWhereUniqueInput
    /**
     * In case the UserLessonProgress found by the `where` argument doesn't exist, create a new UserLessonProgress with this data.
     */
    create: XOR<UserLessonProgressCreateInput, UserLessonProgressUncheckedCreateInput>
    /**
     * In case the UserLessonProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLessonProgressUpdateInput, UserLessonProgressUncheckedUpdateInput>
  }

  /**
   * UserLessonProgress delete
   */
  export type UserLessonProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter which UserLessonProgress to delete.
     */
    where: UserLessonProgressWhereUniqueInput
  }

  /**
   * UserLessonProgress deleteMany
   */
  export type UserLessonProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLessonProgresses to delete
     */
    where?: UserLessonProgressWhereInput
    /**
     * Limit how many UserLessonProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserLessonProgress without action
   */
  export type UserLessonProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeScore
   */

  export type AggregateChallengeScore = {
    _count: ChallengeScoreCountAggregateOutputType | null
    _avg: ChallengeScoreAvgAggregateOutputType | null
    _sum: ChallengeScoreSumAggregateOutputType | null
    _min: ChallengeScoreMinAggregateOutputType | null
    _max: ChallengeScoreMaxAggregateOutputType | null
  }

  export type ChallengeScoreAvgAggregateOutputType = {
    score: number | null
  }

  export type ChallengeScoreSumAggregateOutputType = {
    score: number | null
  }

  export type ChallengeScoreMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    challenge_id: string | null
    score: number | null
    submitted_at: Date | null
  }

  export type ChallengeScoreMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    challenge_id: string | null
    score: number | null
    submitted_at: Date | null
  }

  export type ChallengeScoreCountAggregateOutputType = {
    id: number
    user_id: number
    challenge_id: number
    score: number
    submitted_at: number
    _all: number
  }


  export type ChallengeScoreAvgAggregateInputType = {
    score?: true
  }

  export type ChallengeScoreSumAggregateInputType = {
    score?: true
  }

  export type ChallengeScoreMinAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    score?: true
    submitted_at?: true
  }

  export type ChallengeScoreMaxAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    score?: true
    submitted_at?: true
  }

  export type ChallengeScoreCountAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    score?: true
    submitted_at?: true
    _all?: true
  }

  export type ChallengeScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeScore to aggregate.
     */
    where?: ChallengeScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeScores to fetch.
     */
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeScores
    **/
    _count?: true | ChallengeScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeScoreMaxAggregateInputType
  }

  export type GetChallengeScoreAggregateType<T extends ChallengeScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeScore[P]>
      : GetScalarType<T[P], AggregateChallengeScore[P]>
  }




  export type ChallengeScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeScoreWhereInput
    orderBy?: ChallengeScoreOrderByWithAggregationInput | ChallengeScoreOrderByWithAggregationInput[]
    by: ChallengeScoreScalarFieldEnum[] | ChallengeScoreScalarFieldEnum
    having?: ChallengeScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeScoreCountAggregateInputType | true
    _avg?: ChallengeScoreAvgAggregateInputType
    _sum?: ChallengeScoreSumAggregateInputType
    _min?: ChallengeScoreMinAggregateInputType
    _max?: ChallengeScoreMaxAggregateInputType
  }

  export type ChallengeScoreGroupByOutputType = {
    id: string
    user_id: string
    challenge_id: string
    score: number
    submitted_at: Date
    _count: ChallengeScoreCountAggregateOutputType | null
    _avg: ChallengeScoreAvgAggregateOutputType | null
    _sum: ChallengeScoreSumAggregateOutputType | null
    _min: ChallengeScoreMinAggregateOutputType | null
    _max: ChallengeScoreMaxAggregateOutputType | null
  }

  type GetChallengeScoreGroupByPayload<T extends ChallengeScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeScoreGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeScoreGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    score?: boolean
    submitted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeScore"]>

  export type ChallengeScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    score?: boolean
    submitted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeScore"]>

  export type ChallengeScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    score?: boolean
    submitted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeScore"]>

  export type ChallengeScoreSelectScalar = {
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    score?: boolean
    submitted_at?: boolean
  }

  export type ChallengeScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "challenge_id" | "score" | "submitted_at", ExtArgs["result"]["challengeScore"]>
  export type ChallengeScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeScore"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      challenge_id: string
      score: number
      submitted_at: Date
    }, ExtArgs["result"]["challengeScore"]>
    composites: {}
  }

  type ChallengeScoreGetPayload<S extends boolean | null | undefined | ChallengeScoreDefaultArgs> = $Result.GetResult<Prisma.$ChallengeScorePayload, S>

  type ChallengeScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeScoreCountAggregateInputType | true
    }

  export interface ChallengeScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeScore'], meta: { name: 'ChallengeScore' } }
    /**
     * Find zero or one ChallengeScore that matches the filter.
     * @param {ChallengeScoreFindUniqueArgs} args - Arguments to find a ChallengeScore
     * @example
     * // Get one ChallengeScore
     * const challengeScore = await prisma.challengeScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeScoreFindUniqueArgs>(args: SelectSubset<T, ChallengeScoreFindUniqueArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeScoreFindUniqueOrThrowArgs} args - Arguments to find a ChallengeScore
     * @example
     * // Get one ChallengeScore
     * const challengeScore = await prisma.challengeScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreFindFirstArgs} args - Arguments to find a ChallengeScore
     * @example
     * // Get one ChallengeScore
     * const challengeScore = await prisma.challengeScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeScoreFindFirstArgs>(args?: SelectSubset<T, ChallengeScoreFindFirstArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreFindFirstOrThrowArgs} args - Arguments to find a ChallengeScore
     * @example
     * // Get one ChallengeScore
     * const challengeScore = await prisma.challengeScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeScores
     * const challengeScores = await prisma.challengeScore.findMany()
     * 
     * // Get first 10 ChallengeScores
     * const challengeScores = await prisma.challengeScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeScoreWithIdOnly = await prisma.challengeScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeScoreFindManyArgs>(args?: SelectSubset<T, ChallengeScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeScore.
     * @param {ChallengeScoreCreateArgs} args - Arguments to create a ChallengeScore.
     * @example
     * // Create one ChallengeScore
     * const ChallengeScore = await prisma.challengeScore.create({
     *   data: {
     *     // ... data to create a ChallengeScore
     *   }
     * })
     * 
     */
    create<T extends ChallengeScoreCreateArgs>(args: SelectSubset<T, ChallengeScoreCreateArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeScores.
     * @param {ChallengeScoreCreateManyArgs} args - Arguments to create many ChallengeScores.
     * @example
     * // Create many ChallengeScores
     * const challengeScore = await prisma.challengeScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeScoreCreateManyArgs>(args?: SelectSubset<T, ChallengeScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeScores and returns the data saved in the database.
     * @param {ChallengeScoreCreateManyAndReturnArgs} args - Arguments to create many ChallengeScores.
     * @example
     * // Create many ChallengeScores
     * const challengeScore = await prisma.challengeScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeScores and only return the `id`
     * const challengeScoreWithIdOnly = await prisma.challengeScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeScore.
     * @param {ChallengeScoreDeleteArgs} args - Arguments to delete one ChallengeScore.
     * @example
     * // Delete one ChallengeScore
     * const ChallengeScore = await prisma.challengeScore.delete({
     *   where: {
     *     // ... filter to delete one ChallengeScore
     *   }
     * })
     * 
     */
    delete<T extends ChallengeScoreDeleteArgs>(args: SelectSubset<T, ChallengeScoreDeleteArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeScore.
     * @param {ChallengeScoreUpdateArgs} args - Arguments to update one ChallengeScore.
     * @example
     * // Update one ChallengeScore
     * const challengeScore = await prisma.challengeScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeScoreUpdateArgs>(args: SelectSubset<T, ChallengeScoreUpdateArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeScores.
     * @param {ChallengeScoreDeleteManyArgs} args - Arguments to filter ChallengeScores to delete.
     * @example
     * // Delete a few ChallengeScores
     * const { count } = await prisma.challengeScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeScoreDeleteManyArgs>(args?: SelectSubset<T, ChallengeScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeScores
     * const challengeScore = await prisma.challengeScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeScoreUpdateManyArgs>(args: SelectSubset<T, ChallengeScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeScores and returns the data updated in the database.
     * @param {ChallengeScoreUpdateManyAndReturnArgs} args - Arguments to update many ChallengeScores.
     * @example
     * // Update many ChallengeScores
     * const challengeScore = await prisma.challengeScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeScores and only return the `id`
     * const challengeScoreWithIdOnly = await prisma.challengeScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeScore.
     * @param {ChallengeScoreUpsertArgs} args - Arguments to update or create a ChallengeScore.
     * @example
     * // Update or create a ChallengeScore
     * const challengeScore = await prisma.challengeScore.upsert({
     *   create: {
     *     // ... data to create a ChallengeScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeScore we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeScoreUpsertArgs>(args: SelectSubset<T, ChallengeScoreUpsertArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreCountArgs} args - Arguments to filter ChallengeScores to count.
     * @example
     * // Count the number of ChallengeScores
     * const count = await prisma.challengeScore.count({
     *   where: {
     *     // ... the filter for the ChallengeScores we want to count
     *   }
     * })
    **/
    count<T extends ChallengeScoreCountArgs>(
      args?: Subset<T, ChallengeScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeScoreAggregateArgs>(args: Subset<T, ChallengeScoreAggregateArgs>): Prisma.PrismaPromise<GetChallengeScoreAggregateType<T>>

    /**
     * Group by ChallengeScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeScoreGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeScore model
   */
  readonly fields: ChallengeScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeScore model
   */
  interface ChallengeScoreFieldRefs {
    readonly id: FieldRef<"ChallengeScore", 'String'>
    readonly user_id: FieldRef<"ChallengeScore", 'String'>
    readonly challenge_id: FieldRef<"ChallengeScore", 'String'>
    readonly score: FieldRef<"ChallengeScore", 'Float'>
    readonly submitted_at: FieldRef<"ChallengeScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeScore findUnique
   */
  export type ChallengeScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScore to fetch.
     */
    where: ChallengeScoreWhereUniqueInput
  }

  /**
   * ChallengeScore findUniqueOrThrow
   */
  export type ChallengeScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScore to fetch.
     */
    where: ChallengeScoreWhereUniqueInput
  }

  /**
   * ChallengeScore findFirst
   */
  export type ChallengeScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScore to fetch.
     */
    where?: ChallengeScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeScores to fetch.
     */
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeScores.
     */
    cursor?: ChallengeScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeScores.
     */
    distinct?: ChallengeScoreScalarFieldEnum | ChallengeScoreScalarFieldEnum[]
  }

  /**
   * ChallengeScore findFirstOrThrow
   */
  export type ChallengeScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScore to fetch.
     */
    where?: ChallengeScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeScores to fetch.
     */
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeScores.
     */
    cursor?: ChallengeScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeScores.
     */
    distinct?: ChallengeScoreScalarFieldEnum | ChallengeScoreScalarFieldEnum[]
  }

  /**
   * ChallengeScore findMany
   */
  export type ChallengeScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScores to fetch.
     */
    where?: ChallengeScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeScores to fetch.
     */
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeScores.
     */
    cursor?: ChallengeScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeScores.
     */
    skip?: number
    distinct?: ChallengeScoreScalarFieldEnum | ChallengeScoreScalarFieldEnum[]
  }

  /**
   * ChallengeScore create
   */
  export type ChallengeScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeScore.
     */
    data: XOR<ChallengeScoreCreateInput, ChallengeScoreUncheckedCreateInput>
  }

  /**
   * ChallengeScore createMany
   */
  export type ChallengeScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeScores.
     */
    data: ChallengeScoreCreateManyInput | ChallengeScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeScore createManyAndReturn
   */
  export type ChallengeScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeScores.
     */
    data: ChallengeScoreCreateManyInput | ChallengeScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeScore update
   */
  export type ChallengeScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeScore.
     */
    data: XOR<ChallengeScoreUpdateInput, ChallengeScoreUncheckedUpdateInput>
    /**
     * Choose, which ChallengeScore to update.
     */
    where: ChallengeScoreWhereUniqueInput
  }

  /**
   * ChallengeScore updateMany
   */
  export type ChallengeScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeScores.
     */
    data: XOR<ChallengeScoreUpdateManyMutationInput, ChallengeScoreUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeScores to update
     */
    where?: ChallengeScoreWhereInput
    /**
     * Limit how many ChallengeScores to update.
     */
    limit?: number
  }

  /**
   * ChallengeScore updateManyAndReturn
   */
  export type ChallengeScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeScores.
     */
    data: XOR<ChallengeScoreUpdateManyMutationInput, ChallengeScoreUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeScores to update
     */
    where?: ChallengeScoreWhereInput
    /**
     * Limit how many ChallengeScores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeScore upsert
   */
  export type ChallengeScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeScore to update in case it exists.
     */
    where: ChallengeScoreWhereUniqueInput
    /**
     * In case the ChallengeScore found by the `where` argument doesn't exist, create a new ChallengeScore with this data.
     */
    create: XOR<ChallengeScoreCreateInput, ChallengeScoreUncheckedCreateInput>
    /**
     * In case the ChallengeScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeScoreUpdateInput, ChallengeScoreUncheckedUpdateInput>
  }

  /**
   * ChallengeScore delete
   */
  export type ChallengeScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter which ChallengeScore to delete.
     */
    where: ChallengeScoreWhereUniqueInput
  }

  /**
   * ChallengeScore deleteMany
   */
  export type ChallengeScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeScores to delete
     */
    where?: ChallengeScoreWhereInput
    /**
     * Limit how many ChallengeScores to delete.
     */
    limit?: number
  }

  /**
   * ChallengeScore without action
   */
  export type ChallengeScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model UserLessonScore
   */

  export type AggregateUserLessonScore = {
    _count: UserLessonScoreCountAggregateOutputType | null
    _avg: UserLessonScoreAvgAggregateOutputType | null
    _sum: UserLessonScoreSumAggregateOutputType | null
    _min: UserLessonScoreMinAggregateOutputType | null
    _max: UserLessonScoreMaxAggregateOutputType | null
  }

  export type UserLessonScoreAvgAggregateOutputType = {
    score: number | null
  }

  export type UserLessonScoreSumAggregateOutputType = {
    score: number | null
  }

  export type UserLessonScoreMinAggregateOutputType = {
    id: string | null
    userId: string | null
    lessonId: string | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserLessonScoreMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    lessonId: string | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserLessonScoreCountAggregateOutputType = {
    id: number
    userId: number
    lessonId: number
    score: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserLessonScoreAvgAggregateInputType = {
    score?: true
  }

  export type UserLessonScoreSumAggregateInputType = {
    score?: true
  }

  export type UserLessonScoreMinAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserLessonScoreMaxAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserLessonScoreCountAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserLessonScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLessonScore to aggregate.
     */
    where?: UserLessonScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonScores to fetch.
     */
    orderBy?: UserLessonScoreOrderByWithRelationInput | UserLessonScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLessonScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLessonScores
    **/
    _count?: true | UserLessonScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLessonScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLessonScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLessonScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLessonScoreMaxAggregateInputType
  }

  export type GetUserLessonScoreAggregateType<T extends UserLessonScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLessonScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLessonScore[P]>
      : GetScalarType<T[P], AggregateUserLessonScore[P]>
  }




  export type UserLessonScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLessonScoreWhereInput
    orderBy?: UserLessonScoreOrderByWithAggregationInput | UserLessonScoreOrderByWithAggregationInput[]
    by: UserLessonScoreScalarFieldEnum[] | UserLessonScoreScalarFieldEnum
    having?: UserLessonScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLessonScoreCountAggregateInputType | true
    _avg?: UserLessonScoreAvgAggregateInputType
    _sum?: UserLessonScoreSumAggregateInputType
    _min?: UserLessonScoreMinAggregateInputType
    _max?: UserLessonScoreMaxAggregateInputType
  }

  export type UserLessonScoreGroupByOutputType = {
    id: string
    userId: string
    lessonId: string
    score: number
    createdAt: Date
    updatedAt: Date
    _count: UserLessonScoreCountAggregateOutputType | null
    _avg: UserLessonScoreAvgAggregateOutputType | null
    _sum: UserLessonScoreSumAggregateOutputType | null
    _min: UserLessonScoreMinAggregateOutputType | null
    _max: UserLessonScoreMaxAggregateOutputType | null
  }

  type GetUserLessonScoreGroupByPayload<T extends UserLessonScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLessonScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLessonScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLessonScoreGroupByOutputType[P]>
            : GetScalarType<T[P], UserLessonScoreGroupByOutputType[P]>
        }
      >
    >


  export type UserLessonScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLessonScore"]>

  export type UserLessonScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLessonScore"]>

  export type UserLessonScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLessonScore"]>

  export type UserLessonScoreSelectScalar = {
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserLessonScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "lessonId" | "score" | "createdAt" | "updatedAt", ExtArgs["result"]["userLessonScore"]>
  export type UserLessonScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type UserLessonScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type UserLessonScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $UserLessonScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLessonScore"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      lessonId: string
      score: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userLessonScore"]>
    composites: {}
  }

  type UserLessonScoreGetPayload<S extends boolean | null | undefined | UserLessonScoreDefaultArgs> = $Result.GetResult<Prisma.$UserLessonScorePayload, S>

  type UserLessonScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLessonScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLessonScoreCountAggregateInputType | true
    }

  export interface UserLessonScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLessonScore'], meta: { name: 'UserLessonScore' } }
    /**
     * Find zero or one UserLessonScore that matches the filter.
     * @param {UserLessonScoreFindUniqueArgs} args - Arguments to find a UserLessonScore
     * @example
     * // Get one UserLessonScore
     * const userLessonScore = await prisma.userLessonScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLessonScoreFindUniqueArgs>(args: SelectSubset<T, UserLessonScoreFindUniqueArgs<ExtArgs>>): Prisma__UserLessonScoreClient<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLessonScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLessonScoreFindUniqueOrThrowArgs} args - Arguments to find a UserLessonScore
     * @example
     * // Get one UserLessonScore
     * const userLessonScore = await prisma.userLessonScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLessonScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLessonScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLessonScoreClient<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLessonScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonScoreFindFirstArgs} args - Arguments to find a UserLessonScore
     * @example
     * // Get one UserLessonScore
     * const userLessonScore = await prisma.userLessonScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLessonScoreFindFirstArgs>(args?: SelectSubset<T, UserLessonScoreFindFirstArgs<ExtArgs>>): Prisma__UserLessonScoreClient<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLessonScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonScoreFindFirstOrThrowArgs} args - Arguments to find a UserLessonScore
     * @example
     * // Get one UserLessonScore
     * const userLessonScore = await prisma.userLessonScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLessonScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLessonScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLessonScoreClient<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLessonScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLessonScores
     * const userLessonScores = await prisma.userLessonScore.findMany()
     * 
     * // Get first 10 UserLessonScores
     * const userLessonScores = await prisma.userLessonScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLessonScoreWithIdOnly = await prisma.userLessonScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLessonScoreFindManyArgs>(args?: SelectSubset<T, UserLessonScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLessonScore.
     * @param {UserLessonScoreCreateArgs} args - Arguments to create a UserLessonScore.
     * @example
     * // Create one UserLessonScore
     * const UserLessonScore = await prisma.userLessonScore.create({
     *   data: {
     *     // ... data to create a UserLessonScore
     *   }
     * })
     * 
     */
    create<T extends UserLessonScoreCreateArgs>(args: SelectSubset<T, UserLessonScoreCreateArgs<ExtArgs>>): Prisma__UserLessonScoreClient<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLessonScores.
     * @param {UserLessonScoreCreateManyArgs} args - Arguments to create many UserLessonScores.
     * @example
     * // Create many UserLessonScores
     * const userLessonScore = await prisma.userLessonScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLessonScoreCreateManyArgs>(args?: SelectSubset<T, UserLessonScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLessonScores and returns the data saved in the database.
     * @param {UserLessonScoreCreateManyAndReturnArgs} args - Arguments to create many UserLessonScores.
     * @example
     * // Create many UserLessonScores
     * const userLessonScore = await prisma.userLessonScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLessonScores and only return the `id`
     * const userLessonScoreWithIdOnly = await prisma.userLessonScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLessonScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLessonScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLessonScore.
     * @param {UserLessonScoreDeleteArgs} args - Arguments to delete one UserLessonScore.
     * @example
     * // Delete one UserLessonScore
     * const UserLessonScore = await prisma.userLessonScore.delete({
     *   where: {
     *     // ... filter to delete one UserLessonScore
     *   }
     * })
     * 
     */
    delete<T extends UserLessonScoreDeleteArgs>(args: SelectSubset<T, UserLessonScoreDeleteArgs<ExtArgs>>): Prisma__UserLessonScoreClient<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLessonScore.
     * @param {UserLessonScoreUpdateArgs} args - Arguments to update one UserLessonScore.
     * @example
     * // Update one UserLessonScore
     * const userLessonScore = await prisma.userLessonScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLessonScoreUpdateArgs>(args: SelectSubset<T, UserLessonScoreUpdateArgs<ExtArgs>>): Prisma__UserLessonScoreClient<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLessonScores.
     * @param {UserLessonScoreDeleteManyArgs} args - Arguments to filter UserLessonScores to delete.
     * @example
     * // Delete a few UserLessonScores
     * const { count } = await prisma.userLessonScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLessonScoreDeleteManyArgs>(args?: SelectSubset<T, UserLessonScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLessonScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLessonScores
     * const userLessonScore = await prisma.userLessonScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLessonScoreUpdateManyArgs>(args: SelectSubset<T, UserLessonScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLessonScores and returns the data updated in the database.
     * @param {UserLessonScoreUpdateManyAndReturnArgs} args - Arguments to update many UserLessonScores.
     * @example
     * // Update many UserLessonScores
     * const userLessonScore = await prisma.userLessonScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLessonScores and only return the `id`
     * const userLessonScoreWithIdOnly = await prisma.userLessonScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLessonScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLessonScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLessonScore.
     * @param {UserLessonScoreUpsertArgs} args - Arguments to update or create a UserLessonScore.
     * @example
     * // Update or create a UserLessonScore
     * const userLessonScore = await prisma.userLessonScore.upsert({
     *   create: {
     *     // ... data to create a UserLessonScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLessonScore we want to update
     *   }
     * })
     */
    upsert<T extends UserLessonScoreUpsertArgs>(args: SelectSubset<T, UserLessonScoreUpsertArgs<ExtArgs>>): Prisma__UserLessonScoreClient<$Result.GetResult<Prisma.$UserLessonScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLessonScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonScoreCountArgs} args - Arguments to filter UserLessonScores to count.
     * @example
     * // Count the number of UserLessonScores
     * const count = await prisma.userLessonScore.count({
     *   where: {
     *     // ... the filter for the UserLessonScores we want to count
     *   }
     * })
    **/
    count<T extends UserLessonScoreCountArgs>(
      args?: Subset<T, UserLessonScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLessonScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLessonScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLessonScoreAggregateArgs>(args: Subset<T, UserLessonScoreAggregateArgs>): Prisma.PrismaPromise<GetUserLessonScoreAggregateType<T>>

    /**
     * Group by UserLessonScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLessonScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLessonScoreGroupByArgs['orderBy'] }
        : { orderBy?: UserLessonScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLessonScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLessonScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLessonScore model
   */
  readonly fields: UserLessonScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLessonScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLessonScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLessonScore model
   */
  interface UserLessonScoreFieldRefs {
    readonly id: FieldRef<"UserLessonScore", 'String'>
    readonly userId: FieldRef<"UserLessonScore", 'String'>
    readonly lessonId: FieldRef<"UserLessonScore", 'String'>
    readonly score: FieldRef<"UserLessonScore", 'Float'>
    readonly createdAt: FieldRef<"UserLessonScore", 'DateTime'>
    readonly updatedAt: FieldRef<"UserLessonScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLessonScore findUnique
   */
  export type UserLessonScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonScore to fetch.
     */
    where: UserLessonScoreWhereUniqueInput
  }

  /**
   * UserLessonScore findUniqueOrThrow
   */
  export type UserLessonScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonScore to fetch.
     */
    where: UserLessonScoreWhereUniqueInput
  }

  /**
   * UserLessonScore findFirst
   */
  export type UserLessonScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonScore to fetch.
     */
    where?: UserLessonScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonScores to fetch.
     */
    orderBy?: UserLessonScoreOrderByWithRelationInput | UserLessonScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLessonScores.
     */
    cursor?: UserLessonScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLessonScores.
     */
    distinct?: UserLessonScoreScalarFieldEnum | UserLessonScoreScalarFieldEnum[]
  }

  /**
   * UserLessonScore findFirstOrThrow
   */
  export type UserLessonScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonScore to fetch.
     */
    where?: UserLessonScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonScores to fetch.
     */
    orderBy?: UserLessonScoreOrderByWithRelationInput | UserLessonScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLessonScores.
     */
    cursor?: UserLessonScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLessonScores.
     */
    distinct?: UserLessonScoreScalarFieldEnum | UserLessonScoreScalarFieldEnum[]
  }

  /**
   * UserLessonScore findMany
   */
  export type UserLessonScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonScores to fetch.
     */
    where?: UserLessonScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonScores to fetch.
     */
    orderBy?: UserLessonScoreOrderByWithRelationInput | UserLessonScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLessonScores.
     */
    cursor?: UserLessonScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonScores.
     */
    skip?: number
    distinct?: UserLessonScoreScalarFieldEnum | UserLessonScoreScalarFieldEnum[]
  }

  /**
   * UserLessonScore create
   */
  export type UserLessonScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLessonScore.
     */
    data: XOR<UserLessonScoreCreateInput, UserLessonScoreUncheckedCreateInput>
  }

  /**
   * UserLessonScore createMany
   */
  export type UserLessonScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLessonScores.
     */
    data: UserLessonScoreCreateManyInput | UserLessonScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLessonScore createManyAndReturn
   */
  export type UserLessonScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * The data used to create many UserLessonScores.
     */
    data: UserLessonScoreCreateManyInput | UserLessonScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLessonScore update
   */
  export type UserLessonScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLessonScore.
     */
    data: XOR<UserLessonScoreUpdateInput, UserLessonScoreUncheckedUpdateInput>
    /**
     * Choose, which UserLessonScore to update.
     */
    where: UserLessonScoreWhereUniqueInput
  }

  /**
   * UserLessonScore updateMany
   */
  export type UserLessonScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLessonScores.
     */
    data: XOR<UserLessonScoreUpdateManyMutationInput, UserLessonScoreUncheckedUpdateManyInput>
    /**
     * Filter which UserLessonScores to update
     */
    where?: UserLessonScoreWhereInput
    /**
     * Limit how many UserLessonScores to update.
     */
    limit?: number
  }

  /**
   * UserLessonScore updateManyAndReturn
   */
  export type UserLessonScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * The data used to update UserLessonScores.
     */
    data: XOR<UserLessonScoreUpdateManyMutationInput, UserLessonScoreUncheckedUpdateManyInput>
    /**
     * Filter which UserLessonScores to update
     */
    where?: UserLessonScoreWhereInput
    /**
     * Limit how many UserLessonScores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLessonScore upsert
   */
  export type UserLessonScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLessonScore to update in case it exists.
     */
    where: UserLessonScoreWhereUniqueInput
    /**
     * In case the UserLessonScore found by the `where` argument doesn't exist, create a new UserLessonScore with this data.
     */
    create: XOR<UserLessonScoreCreateInput, UserLessonScoreUncheckedCreateInput>
    /**
     * In case the UserLessonScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLessonScoreUpdateInput, UserLessonScoreUncheckedUpdateInput>
  }

  /**
   * UserLessonScore delete
   */
  export type UserLessonScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
    /**
     * Filter which UserLessonScore to delete.
     */
    where: UserLessonScoreWhereUniqueInput
  }

  /**
   * UserLessonScore deleteMany
   */
  export type UserLessonScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLessonScores to delete
     */
    where?: UserLessonScoreWhereInput
    /**
     * Limit how many UserLessonScores to delete.
     */
    limit?: number
  }

  /**
   * UserLessonScore without action
   */
  export type UserLessonScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonScore
     */
    select?: UserLessonScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonScore
     */
    omit?: UserLessonScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonScoreInclude<ExtArgs> | null
  }


  /**
   * Model UserCourseProgress
   */

  export type AggregateUserCourseProgress = {
    _count: UserCourseProgressCountAggregateOutputType | null
    _min: UserCourseProgressMinAggregateOutputType | null
    _max: UserCourseProgressMaxAggregateOutputType | null
  }

  export type UserCourseProgressMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    product_id: string | null
    completed_at: Date | null
  }

  export type UserCourseProgressMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    product_id: string | null
    completed_at: Date | null
  }

  export type UserCourseProgressCountAggregateOutputType = {
    id: number
    user_id: number
    product_id: number
    completed_at: number
    _all: number
  }


  export type UserCourseProgressMinAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
    completed_at?: true
  }

  export type UserCourseProgressMaxAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
    completed_at?: true
  }

  export type UserCourseProgressCountAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
    completed_at?: true
    _all?: true
  }

  export type UserCourseProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourseProgress to aggregate.
     */
    where?: UserCourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseProgresses to fetch.
     */
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCourseProgresses
    **/
    _count?: true | UserCourseProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCourseProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCourseProgressMaxAggregateInputType
  }

  export type GetUserCourseProgressAggregateType<T extends UserCourseProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCourseProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCourseProgress[P]>
      : GetScalarType<T[P], AggregateUserCourseProgress[P]>
  }




  export type UserCourseProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseProgressWhereInput
    orderBy?: UserCourseProgressOrderByWithAggregationInput | UserCourseProgressOrderByWithAggregationInput[]
    by: UserCourseProgressScalarFieldEnum[] | UserCourseProgressScalarFieldEnum
    having?: UserCourseProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCourseProgressCountAggregateInputType | true
    _min?: UserCourseProgressMinAggregateInputType
    _max?: UserCourseProgressMaxAggregateInputType
  }

  export type UserCourseProgressGroupByOutputType = {
    id: string
    user_id: string
    product_id: string
    completed_at: Date | null
    _count: UserCourseProgressCountAggregateOutputType | null
    _min: UserCourseProgressMinAggregateOutputType | null
    _max: UserCourseProgressMaxAggregateOutputType | null
  }

  type GetUserCourseProgressGroupByPayload<T extends UserCourseProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCourseProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCourseProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCourseProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserCourseProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserCourseProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    completed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseProgress"]>

  export type UserCourseProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    completed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseProgress"]>

  export type UserCourseProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    completed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseProgress"]>

  export type UserCourseProgressSelectScalar = {
    id?: boolean
    user_id?: boolean
    product_id?: boolean
    completed_at?: boolean
  }

  export type UserCourseProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "product_id" | "completed_at", ExtArgs["result"]["userCourseProgress"]>
  export type UserCourseProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type UserCourseProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type UserCourseProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $UserCourseProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCourseProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      product_id: string
      completed_at: Date | null
    }, ExtArgs["result"]["userCourseProgress"]>
    composites: {}
  }

  type UserCourseProgressGetPayload<S extends boolean | null | undefined | UserCourseProgressDefaultArgs> = $Result.GetResult<Prisma.$UserCourseProgressPayload, S>

  type UserCourseProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCourseProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCourseProgressCountAggregateInputType | true
    }

  export interface UserCourseProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCourseProgress'], meta: { name: 'UserCourseProgress' } }
    /**
     * Find zero or one UserCourseProgress that matches the filter.
     * @param {UserCourseProgressFindUniqueArgs} args - Arguments to find a UserCourseProgress
     * @example
     * // Get one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCourseProgressFindUniqueArgs>(args: SelectSubset<T, UserCourseProgressFindUniqueArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCourseProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCourseProgressFindUniqueOrThrowArgs} args - Arguments to find a UserCourseProgress
     * @example
     * // Get one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCourseProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCourseProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCourseProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressFindFirstArgs} args - Arguments to find a UserCourseProgress
     * @example
     * // Get one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCourseProgressFindFirstArgs>(args?: SelectSubset<T, UserCourseProgressFindFirstArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCourseProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressFindFirstOrThrowArgs} args - Arguments to find a UserCourseProgress
     * @example
     * // Get one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCourseProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCourseProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCourseProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCourseProgresses
     * const userCourseProgresses = await prisma.userCourseProgress.findMany()
     * 
     * // Get first 10 UserCourseProgresses
     * const userCourseProgresses = await prisma.userCourseProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCourseProgressWithIdOnly = await prisma.userCourseProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCourseProgressFindManyArgs>(args?: SelectSubset<T, UserCourseProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCourseProgress.
     * @param {UserCourseProgressCreateArgs} args - Arguments to create a UserCourseProgress.
     * @example
     * // Create one UserCourseProgress
     * const UserCourseProgress = await prisma.userCourseProgress.create({
     *   data: {
     *     // ... data to create a UserCourseProgress
     *   }
     * })
     * 
     */
    create<T extends UserCourseProgressCreateArgs>(args: SelectSubset<T, UserCourseProgressCreateArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCourseProgresses.
     * @param {UserCourseProgressCreateManyArgs} args - Arguments to create many UserCourseProgresses.
     * @example
     * // Create many UserCourseProgresses
     * const userCourseProgress = await prisma.userCourseProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCourseProgressCreateManyArgs>(args?: SelectSubset<T, UserCourseProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCourseProgresses and returns the data saved in the database.
     * @param {UserCourseProgressCreateManyAndReturnArgs} args - Arguments to create many UserCourseProgresses.
     * @example
     * // Create many UserCourseProgresses
     * const userCourseProgress = await prisma.userCourseProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCourseProgresses and only return the `id`
     * const userCourseProgressWithIdOnly = await prisma.userCourseProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCourseProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCourseProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCourseProgress.
     * @param {UserCourseProgressDeleteArgs} args - Arguments to delete one UserCourseProgress.
     * @example
     * // Delete one UserCourseProgress
     * const UserCourseProgress = await prisma.userCourseProgress.delete({
     *   where: {
     *     // ... filter to delete one UserCourseProgress
     *   }
     * })
     * 
     */
    delete<T extends UserCourseProgressDeleteArgs>(args: SelectSubset<T, UserCourseProgressDeleteArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCourseProgress.
     * @param {UserCourseProgressUpdateArgs} args - Arguments to update one UserCourseProgress.
     * @example
     * // Update one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCourseProgressUpdateArgs>(args: SelectSubset<T, UserCourseProgressUpdateArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCourseProgresses.
     * @param {UserCourseProgressDeleteManyArgs} args - Arguments to filter UserCourseProgresses to delete.
     * @example
     * // Delete a few UserCourseProgresses
     * const { count } = await prisma.userCourseProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCourseProgressDeleteManyArgs>(args?: SelectSubset<T, UserCourseProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCourseProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCourseProgresses
     * const userCourseProgress = await prisma.userCourseProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCourseProgressUpdateManyArgs>(args: SelectSubset<T, UserCourseProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCourseProgresses and returns the data updated in the database.
     * @param {UserCourseProgressUpdateManyAndReturnArgs} args - Arguments to update many UserCourseProgresses.
     * @example
     * // Update many UserCourseProgresses
     * const userCourseProgress = await prisma.userCourseProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCourseProgresses and only return the `id`
     * const userCourseProgressWithIdOnly = await prisma.userCourseProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCourseProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCourseProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCourseProgress.
     * @param {UserCourseProgressUpsertArgs} args - Arguments to update or create a UserCourseProgress.
     * @example
     * // Update or create a UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.upsert({
     *   create: {
     *     // ... data to create a UserCourseProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCourseProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserCourseProgressUpsertArgs>(args: SelectSubset<T, UserCourseProgressUpsertArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCourseProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressCountArgs} args - Arguments to filter UserCourseProgresses to count.
     * @example
     * // Count the number of UserCourseProgresses
     * const count = await prisma.userCourseProgress.count({
     *   where: {
     *     // ... the filter for the UserCourseProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserCourseProgressCountArgs>(
      args?: Subset<T, UserCourseProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCourseProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCourseProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCourseProgressAggregateArgs>(args: Subset<T, UserCourseProgressAggregateArgs>): Prisma.PrismaPromise<GetUserCourseProgressAggregateType<T>>

    /**
     * Group by UserCourseProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCourseProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCourseProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserCourseProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCourseProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCourseProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCourseProgress model
   */
  readonly fields: UserCourseProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCourseProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCourseProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCourseProgress model
   */
  interface UserCourseProgressFieldRefs {
    readonly id: FieldRef<"UserCourseProgress", 'String'>
    readonly user_id: FieldRef<"UserCourseProgress", 'String'>
    readonly product_id: FieldRef<"UserCourseProgress", 'String'>
    readonly completed_at: FieldRef<"UserCourseProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserCourseProgress findUnique
   */
  export type UserCourseProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgress to fetch.
     */
    where: UserCourseProgressWhereUniqueInput
  }

  /**
   * UserCourseProgress findUniqueOrThrow
   */
  export type UserCourseProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgress to fetch.
     */
    where: UserCourseProgressWhereUniqueInput
  }

  /**
   * UserCourseProgress findFirst
   */
  export type UserCourseProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgress to fetch.
     */
    where?: UserCourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseProgresses to fetch.
     */
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourseProgresses.
     */
    cursor?: UserCourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourseProgresses.
     */
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * UserCourseProgress findFirstOrThrow
   */
  export type UserCourseProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgress to fetch.
     */
    where?: UserCourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseProgresses to fetch.
     */
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourseProgresses.
     */
    cursor?: UserCourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourseProgresses.
     */
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * UserCourseProgress findMany
   */
  export type UserCourseProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgresses to fetch.
     */
    where?: UserCourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseProgresses to fetch.
     */
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCourseProgresses.
     */
    cursor?: UserCourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseProgresses.
     */
    skip?: number
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * UserCourseProgress create
   */
  export type UserCourseProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCourseProgress.
     */
    data: XOR<UserCourseProgressCreateInput, UserCourseProgressUncheckedCreateInput>
  }

  /**
   * UserCourseProgress createMany
   */
  export type UserCourseProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCourseProgresses.
     */
    data: UserCourseProgressCreateManyInput | UserCourseProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCourseProgress createManyAndReturn
   */
  export type UserCourseProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserCourseProgresses.
     */
    data: UserCourseProgressCreateManyInput | UserCourseProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCourseProgress update
   */
  export type UserCourseProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCourseProgress.
     */
    data: XOR<UserCourseProgressUpdateInput, UserCourseProgressUncheckedUpdateInput>
    /**
     * Choose, which UserCourseProgress to update.
     */
    where: UserCourseProgressWhereUniqueInput
  }

  /**
   * UserCourseProgress updateMany
   */
  export type UserCourseProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCourseProgresses.
     */
    data: XOR<UserCourseProgressUpdateManyMutationInput, UserCourseProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserCourseProgresses to update
     */
    where?: UserCourseProgressWhereInput
    /**
     * Limit how many UserCourseProgresses to update.
     */
    limit?: number
  }

  /**
   * UserCourseProgress updateManyAndReturn
   */
  export type UserCourseProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserCourseProgresses.
     */
    data: XOR<UserCourseProgressUpdateManyMutationInput, UserCourseProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserCourseProgresses to update
     */
    where?: UserCourseProgressWhereInput
    /**
     * Limit how many UserCourseProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCourseProgress upsert
   */
  export type UserCourseProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCourseProgress to update in case it exists.
     */
    where: UserCourseProgressWhereUniqueInput
    /**
     * In case the UserCourseProgress found by the `where` argument doesn't exist, create a new UserCourseProgress with this data.
     */
    create: XOR<UserCourseProgressCreateInput, UserCourseProgressUncheckedCreateInput>
    /**
     * In case the UserCourseProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCourseProgressUpdateInput, UserCourseProgressUncheckedUpdateInput>
  }

  /**
   * UserCourseProgress delete
   */
  export type UserCourseProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter which UserCourseProgress to delete.
     */
    where: UserCourseProgressWhereUniqueInput
  }

  /**
   * UserCourseProgress deleteMany
   */
  export type UserCourseProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourseProgresses to delete
     */
    where?: UserCourseProgressWhereInput
    /**
     * Limit how many UserCourseProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserCourseProgress without action
   */
  export type UserCourseProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    fullName: 'fullName',
    password: 'password',
    avatar: 'avatar',
    isVerified: 'isVerified',
    role: 'role',
    age: 'age',
    grade: 'grade'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OTPScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    code: 'code',
    isUsed: 'isUsed',
    userId: 'userId'
  };

  export type OTPScalarFieldEnum = (typeof OTPScalarFieldEnum)[keyof typeof OTPScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    short_description: 'short_description',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    short_description: 'short_description',
    description: 'description',
    category_id: 'category_id',
    thumbnail: 'thumbnail',
    label: 'label',
    status: 'status',
    requirements: 'requirements',
    learning_outcomes: 'learning_outcomes',
    preview_video: 'preview_video',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    course_id: 'course_id',
    title: 'title',
    short_description: 'short_description',
    order: 'order',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    module_id: 'module_id',
    title: 'title',
    description: 'description',
    type: 'type',
    is_previewable: 'is_previewable',
    status: 'status',
    order: 'order',
    attachment: 'attachment',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    product_id: 'product_id',
    created_at: 'created_at'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    product_id: 'product_id',
    rating: 'rating',
    comment: 'comment',
    status: 'status',
    created_at: 'created_at'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    lesson_id: 'lesson_id',
    question: 'question',
    explanation: 'explanation',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuizAnswerScalarFieldEnum: {
    id: 'id',
    quiz_question_id: 'quiz_question_id',
    answer: 'answer',
    is_correct: 'is_correct',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type QuizAnswerScalarFieldEnum = (typeof QuizAnswerScalarFieldEnum)[keyof typeof QuizAnswerScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    type: 'type',
    order: 'order',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const ChallengeQuestionScalarFieldEnum: {
    id: 'id',
    challenge_id: 'challenge_id',
    question: 'question',
    explanation: 'explanation',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChallengeQuestionScalarFieldEnum = (typeof ChallengeQuestionScalarFieldEnum)[keyof typeof ChallengeQuestionScalarFieldEnum]


  export const ChallengeAnswerScalarFieldEnum: {
    id: 'id',
    challenge_question_id: 'challenge_question_id',
    answer: 'answer',
    is_correct: 'is_correct',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChallengeAnswerScalarFieldEnum = (typeof ChallengeAnswerScalarFieldEnum)[keyof typeof ChallengeAnswerScalarFieldEnum]


  export const PuzzleChallengeScalarFieldEnum: {
    id: 'id',
    challenge_id: 'challenge_id',
    instruction: 'instruction',
    image: 'image'
  };

  export type PuzzleChallengeScalarFieldEnum = (typeof PuzzleChallengeScalarFieldEnum)[keyof typeof PuzzleChallengeScalarFieldEnum]


  export const OrderingChallengeScalarFieldEnum: {
    id: 'id',
    challenge_id: 'challenge_id',
    instruction: 'instruction'
  };

  export type OrderingChallengeScalarFieldEnum = (typeof OrderingChallengeScalarFieldEnum)[keyof typeof OrderingChallengeScalarFieldEnum]


  export const OrderingItemScalarFieldEnum: {
    id: 'id',
    ordering_id: 'ordering_id',
    content: 'content',
    correct_order: 'correct_order',
    explanation: 'explanation'
  };

  export type OrderingItemScalarFieldEnum = (typeof OrderingItemScalarFieldEnum)[keyof typeof OrderingItemScalarFieldEnum]


  export const FillBlankChallengeScalarFieldEnum: {
    id: 'id',
    challenge_id: 'challenge_id'
  };

  export type FillBlankChallengeScalarFieldEnum = (typeof FillBlankChallengeScalarFieldEnum)[keyof typeof FillBlankChallengeScalarFieldEnum]


  export const FillBlankQuestionScalarFieldEnum: {
    id: 'id',
    challenge_id: 'challenge_id',
    sentence: 'sentence',
    correct_word: 'correct_word'
  };

  export type FillBlankQuestionScalarFieldEnum = (typeof FillBlankQuestionScalarFieldEnum)[keyof typeof FillBlankQuestionScalarFieldEnum]


  export const UserLessonProgressScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    lesson_id: 'lesson_id',
    completed_at: 'completed_at'
  };

  export type UserLessonProgressScalarFieldEnum = (typeof UserLessonProgressScalarFieldEnum)[keyof typeof UserLessonProgressScalarFieldEnum]


  export const ChallengeScoreScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    challenge_id: 'challenge_id',
    score: 'score',
    submitted_at: 'submitted_at'
  };

  export type ChallengeScoreScalarFieldEnum = (typeof ChallengeScoreScalarFieldEnum)[keyof typeof ChallengeScoreScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const UserLessonScoreScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    lessonId: 'lessonId',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserLessonScoreScalarFieldEnum = (typeof UserLessonScoreScalarFieldEnum)[keyof typeof UserLessonScoreScalarFieldEnum]


  export const UserCourseProgressScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    product_id: 'product_id',
    completed_at: 'completed_at'
  };

  export type UserCourseProgressScalarFieldEnum = (typeof UserCourseProgressScalarFieldEnum)[keyof typeof UserCourseProgressScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Grade'
   */
  export type EnumGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Grade'>
    


  /**
   * Reference to a field of type 'Grade[]'
   */
  export type ListEnumGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Grade[]'>
    


  /**
   * Reference to a field of type 'CategoryStatus'
   */
  export type EnumCategoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryStatus'>
    


  /**
   * Reference to a field of type 'CategoryStatus[]'
   */
  export type ListEnumCategoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryStatus[]'>
    


  /**
   * Reference to a field of type 'ProductLabel'
   */
  export type EnumProductLabelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductLabel'>
    


  /**
   * Reference to a field of type 'ProductLabel[]'
   */
  export type ListEnumProductLabelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductLabel[]'>
    


  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


  /**
   * Reference to a field of type 'ProductStatus[]'
   */
  export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus[]'>
    


  /**
   * Reference to a field of type 'ModuleStatus'
   */
  export type EnumModuleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModuleStatus'>
    


  /**
   * Reference to a field of type 'ModuleStatus[]'
   */
  export type ListEnumModuleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModuleStatus[]'>
    


  /**
   * Reference to a field of type 'LessonType'
   */
  export type EnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType'>
    


  /**
   * Reference to a field of type 'LessonType[]'
   */
  export type ListEnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType[]'>
    


  /**
   * Reference to a field of type 'LessonStatus'
   */
  export type EnumLessonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonStatus'>
    


  /**
   * Reference to a field of type 'LessonStatus[]'
   */
  export type ListEnumLessonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonStatus[]'>
    


  /**
   * Reference to a field of type 'ChallengeType'
   */
  export type EnumChallengeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeType'>
    


  /**
   * Reference to a field of type 'ChallengeType[]'
   */
  export type ListEnumChallengeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeType[]'>
    


  /**
   * Reference to a field of type 'ChallengeStatus'
   */
  export type EnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatus'>
    


  /**
   * Reference to a field of type 'ChallengeStatus[]'
   */
  export type ListEnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    age?: IntNullableFilter<"User"> | number | null
    grade?: EnumGradeNullableFilter<"User"> | $Enums.Grade | null
    otps?: OTPListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    reviews?: ReviewListRelationFilter
    userLessonProgress?: UserLessonProgressListRelationFilter
    challengeScore?: ChallengeScoreListRelationFilter
    userLessonScore?: UserLessonScoreListRelationFilter
    userCourseProgress?: UserCourseProgressListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    age?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    otps?: OTPOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    userLessonProgress?: UserLessonProgressOrderByRelationAggregateInput
    challengeScore?: ChallengeScoreOrderByRelationAggregateInput
    userLessonScore?: UserLessonScoreOrderByRelationAggregateInput
    userCourseProgress?: UserCourseProgressOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    fullName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    age?: IntNullableFilter<"User"> | number | null
    grade?: EnumGradeNullableFilter<"User"> | $Enums.Grade | null
    otps?: OTPListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    reviews?: ReviewListRelationFilter
    userLessonProgress?: UserLessonProgressListRelationFilter
    challengeScore?: ChallengeScoreListRelationFilter
    userLessonScore?: UserLessonScoreListRelationFilter
    userCourseProgress?: UserCourseProgressListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    age?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    role?: StringWithAggregatesFilter<"User"> | string
    age?: IntNullableWithAggregatesFilter<"User"> | number | null
    grade?: EnumGradeNullableWithAggregatesFilter<"User"> | $Enums.Grade | null
  }

  export type OTPWhereInput = {
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    id?: UuidFilter<"OTP"> | string
    createdAt?: DateTimeFilter<"OTP"> | Date | string
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    code?: StringFilter<"OTP"> | string
    isUsed?: BoolFilter<"OTP"> | boolean
    userId?: UuidFilter<"OTP"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OTPOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OTPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    createdAt?: DateTimeFilter<"OTP"> | Date | string
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    code?: StringFilter<"OTP"> | string
    isUsed?: BoolFilter<"OTP"> | boolean
    userId?: UuidFilter<"OTP"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OTPOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
    _count?: OTPCountOrderByAggregateInput
    _max?: OTPMaxOrderByAggregateInput
    _min?: OTPMinOrderByAggregateInput
  }

  export type OTPScalarWhereWithAggregatesInput = {
    AND?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    OR?: OTPScalarWhereWithAggregatesInput[]
    NOT?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OTP"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
    code?: StringWithAggregatesFilter<"OTP"> | string
    isUsed?: BoolWithAggregatesFilter<"OTP"> | boolean
    userId?: UuidWithAggregatesFilter<"OTP"> | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: UuidFilter<"Category"> | string
    title?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    short_description?: StringFilter<"Category"> | string
    status?: EnumCategoryStatusFilter<"Category"> | $Enums.CategoryStatus
    created_at?: DateTimeFilter<"Category"> | Date | string
    updated_at?: DateTimeFilter<"Category"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Category"> | Date | string | null
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    title?: StringFilter<"Category"> | string
    short_description?: StringFilter<"Category"> | string
    status?: EnumCategoryStatusFilter<"Category"> | $Enums.CategoryStatus
    created_at?: DateTimeFilter<"Category"> | Date | string
    updated_at?: DateTimeFilter<"Category"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Category"> | Date | string | null
    products?: ProductListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Category"> | string
    title?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    short_description?: StringWithAggregatesFilter<"Category"> | string
    status?: EnumCategoryStatusWithAggregatesFilter<"Category"> | $Enums.CategoryStatus
    created_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: UuidFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    short_description?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category_id?: UuidFilter<"Product"> | string
    thumbnail?: StringFilter<"Product"> | string
    label?: EnumProductLabelFilter<"Product"> | $Enums.ProductLabel
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    requirements?: StringFilter<"Product"> | string
    learning_outcomes?: StringFilter<"Product"> | string
    preview_video?: StringNullableFilter<"Product"> | string | null
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Product"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    modules?: ModuleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    reviews?: ReviewListRelationFilter
    userCourseProgress?: UserCourseProgressListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    description?: SortOrderInput | SortOrder
    category_id?: SortOrder
    thumbnail?: SortOrder
    label?: SortOrder
    status?: SortOrder
    requirements?: SortOrder
    learning_outcomes?: SortOrder
    preview_video?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    modules?: ModuleOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    userCourseProgress?: UserCourseProgressOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    label_slug?: ProductLabelSlugCompoundUniqueInput
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    title?: StringFilter<"Product"> | string
    short_description?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category_id?: UuidFilter<"Product"> | string
    thumbnail?: StringFilter<"Product"> | string
    label?: EnumProductLabelFilter<"Product"> | $Enums.ProductLabel
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    requirements?: StringFilter<"Product"> | string
    learning_outcomes?: StringFilter<"Product"> | string
    preview_video?: StringNullableFilter<"Product"> | string | null
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Product"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    modules?: ModuleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    reviews?: ReviewListRelationFilter
    userCourseProgress?: UserCourseProgressListRelationFilter
  }, "id" | "slug" | "label_slug">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    description?: SortOrderInput | SortOrder
    category_id?: SortOrder
    thumbnail?: SortOrder
    label?: SortOrder
    status?: SortOrder
    requirements?: SortOrder
    learning_outcomes?: SortOrder
    preview_video?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Product"> | string
    title?: StringWithAggregatesFilter<"Product"> | string
    slug?: StringWithAggregatesFilter<"Product"> | string
    short_description?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category_id?: UuidWithAggregatesFilter<"Product"> | string
    thumbnail?: StringWithAggregatesFilter<"Product"> | string
    label?: EnumProductLabelWithAggregatesFilter<"Product"> | $Enums.ProductLabel
    status?: EnumProductStatusWithAggregatesFilter<"Product"> | $Enums.ProductStatus
    requirements?: StringWithAggregatesFilter<"Product"> | string
    learning_outcomes?: StringWithAggregatesFilter<"Product"> | string
    preview_video?: StringNullableWithAggregatesFilter<"Product"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: UuidFilter<"Module"> | string
    course_id?: UuidFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    short_description?: StringFilter<"Module"> | string
    order?: IntFilter<"Module"> | number
    status?: EnumModuleStatusFilter<"Module"> | $Enums.ModuleStatus
    created_at?: DateTimeFilter<"Module"> | Date | string
    updated_at?: DateTimeFilter<"Module"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Module"> | Date | string | null
    course?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    lessons?: LessonListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    course_id?: SortOrder
    title?: SortOrder
    short_description?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    course?: ProductOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    course_id?: UuidFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    short_description?: StringFilter<"Module"> | string
    order?: IntFilter<"Module"> | number
    status?: EnumModuleStatusFilter<"Module"> | $Enums.ModuleStatus
    created_at?: DateTimeFilter<"Module"> | Date | string
    updated_at?: DateTimeFilter<"Module"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Module"> | Date | string | null
    course?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    lessons?: LessonListRelationFilter
  }, "id">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    course_id?: SortOrder
    title?: SortOrder
    short_description?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Module"> | string
    course_id?: UuidWithAggregatesFilter<"Module"> | string
    title?: StringWithAggregatesFilter<"Module"> | string
    short_description?: StringWithAggregatesFilter<"Module"> | string
    order?: IntWithAggregatesFilter<"Module"> | number
    status?: EnumModuleStatusWithAggregatesFilter<"Module"> | $Enums.ModuleStatus
    created_at?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Module"> | Date | string | null
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: UuidFilter<"Lesson"> | string
    module_id?: UuidFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    description?: StringFilter<"Lesson"> | string
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    is_previewable?: BoolFilter<"Lesson"> | boolean
    status?: EnumLessonStatusFilter<"Lesson"> | $Enums.LessonStatus
    order?: IntFilter<"Lesson"> | number
    attachment?: StringNullableFilter<"Lesson"> | string | null
    created_at?: DateTimeFilter<"Lesson"> | Date | string
    updated_at?: DateTimeFilter<"Lesson"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    question?: QuizQuestionListRelationFilter
    userProgress?: UserLessonProgressListRelationFilter
    userLessonScore?: UserLessonScoreListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    module_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    is_previewable?: SortOrder
    status?: SortOrder
    order?: SortOrder
    attachment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    module?: ModuleOrderByWithRelationInput
    question?: QuizQuestionOrderByRelationAggregateInput
    userProgress?: UserLessonProgressOrderByRelationAggregateInput
    userLessonScore?: UserLessonScoreOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    module_id?: UuidFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    description?: StringFilter<"Lesson"> | string
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    is_previewable?: BoolFilter<"Lesson"> | boolean
    status?: EnumLessonStatusFilter<"Lesson"> | $Enums.LessonStatus
    order?: IntFilter<"Lesson"> | number
    attachment?: StringNullableFilter<"Lesson"> | string | null
    created_at?: DateTimeFilter<"Lesson"> | Date | string
    updated_at?: DateTimeFilter<"Lesson"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    question?: QuizQuestionListRelationFilter
    userProgress?: UserLessonProgressListRelationFilter
    userLessonScore?: UserLessonScoreListRelationFilter
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    module_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    is_previewable?: SortOrder
    status?: SortOrder
    order?: SortOrder
    attachment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Lesson"> | string
    module_id?: UuidWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    description?: StringWithAggregatesFilter<"Lesson"> | string
    type?: EnumLessonTypeWithAggregatesFilter<"Lesson"> | $Enums.LessonType
    is_previewable?: BoolWithAggregatesFilter<"Lesson"> | boolean
    status?: EnumLessonStatusWithAggregatesFilter<"Lesson"> | $Enums.LessonStatus
    order?: IntWithAggregatesFilter<"Lesson"> | number
    attachment?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Lesson"> | Date | string | null
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: UuidFilter<"Enrollment"> | string
    user_id?: UuidFilter<"Enrollment"> | string
    product_id?: UuidFilter<"Enrollment"> | string
    created_at?: DateTimeFilter<"Enrollment"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_product_id?: EnrollmentUser_idProduct_idCompoundUniqueInput
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    user_id?: UuidFilter<"Enrollment"> | string
    product_id?: UuidFilter<"Enrollment"> | string
    created_at?: DateTimeFilter<"Enrollment"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id_product_id">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Enrollment"> | string
    user_id?: UuidWithAggregatesFilter<"Enrollment"> | string
    product_id?: UuidWithAggregatesFilter<"Enrollment"> | string
    created_at?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: UuidFilter<"Review"> | string
    user_id?: UuidFilter<"Review"> | string
    product_id?: UuidFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    status?: BoolFilter<"Review"> | boolean
    created_at?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_product_id?: ReviewUser_idProduct_idCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    user_id?: UuidFilter<"Review"> | string
    product_id?: UuidFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    status?: BoolFilter<"Review"> | boolean
    created_at?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "user_id_product_id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Review"> | string
    user_id?: UuidWithAggregatesFilter<"Review"> | string
    product_id?: UuidWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    status?: BoolWithAggregatesFilter<"Review"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: UuidFilter<"QuizQuestion"> | string
    lesson_id?: UuidFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    created_at?: DateTimeFilter<"QuizQuestion"> | Date | string
    updated_at?: DateTimeFilter<"QuizQuestion"> | Date | string
    deleted_at?: DateTimeNullableFilter<"QuizQuestion"> | Date | string | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    answers?: QuizAnswerListRelationFilter
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    lesson?: LessonOrderByWithRelationInput
    answers?: QuizAnswerOrderByRelationAggregateInput
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    lesson_id?: UuidFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    created_at?: DateTimeFilter<"QuizQuestion"> | Date | string
    updated_at?: DateTimeFilter<"QuizQuestion"> | Date | string
    deleted_at?: DateTimeNullableFilter<"QuizQuestion"> | Date | string | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    answers?: QuizAnswerListRelationFilter
  }, "id">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QuizQuestion"> | string
    lesson_id?: UuidWithAggregatesFilter<"QuizQuestion"> | string
    question?: StringWithAggregatesFilter<"QuizQuestion"> | string
    explanation?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"QuizQuestion"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"QuizQuestion"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"QuizQuestion"> | Date | string | null
  }

  export type QuizAnswerWhereInput = {
    AND?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    OR?: QuizAnswerWhereInput[]
    NOT?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    id?: UuidFilter<"QuizAnswer"> | string
    quiz_question_id?: UuidFilter<"QuizAnswer"> | string
    answer?: StringFilter<"QuizAnswer"> | string
    is_correct?: BoolFilter<"QuizAnswer"> | boolean
    created_at?: DateTimeFilter<"QuizAnswer"> | Date | string
    updated_at?: DateTimeFilter<"QuizAnswer"> | Date | string
    deleted_at?: DateTimeNullableFilter<"QuizAnswer"> | Date | string | null
    quiz_question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
  }

  export type QuizAnswerOrderByWithRelationInput = {
    id?: SortOrder
    quiz_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    quiz_question?: QuizQuestionOrderByWithRelationInput
  }

  export type QuizAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    OR?: QuizAnswerWhereInput[]
    NOT?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    quiz_question_id?: UuidFilter<"QuizAnswer"> | string
    answer?: StringFilter<"QuizAnswer"> | string
    is_correct?: BoolFilter<"QuizAnswer"> | boolean
    created_at?: DateTimeFilter<"QuizAnswer"> | Date | string
    updated_at?: DateTimeFilter<"QuizAnswer"> | Date | string
    deleted_at?: DateTimeNullableFilter<"QuizAnswer"> | Date | string | null
    quiz_question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
  }, "id">

  export type QuizAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    quiz_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: QuizAnswerCountOrderByAggregateInput
    _max?: QuizAnswerMaxOrderByAggregateInput
    _min?: QuizAnswerMinOrderByAggregateInput
  }

  export type QuizAnswerScalarWhereWithAggregatesInput = {
    AND?: QuizAnswerScalarWhereWithAggregatesInput | QuizAnswerScalarWhereWithAggregatesInput[]
    OR?: QuizAnswerScalarWhereWithAggregatesInput[]
    NOT?: QuizAnswerScalarWhereWithAggregatesInput | QuizAnswerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QuizAnswer"> | string
    quiz_question_id?: UuidWithAggregatesFilter<"QuizAnswer"> | string
    answer?: StringWithAggregatesFilter<"QuizAnswer"> | string
    is_correct?: BoolWithAggregatesFilter<"QuizAnswer"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"QuizAnswer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"QuizAnswer"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"QuizAnswer"> | Date | string | null
  }

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: UuidFilter<"Challenge"> | string
    title?: StringFilter<"Challenge"> | string
    slug?: StringFilter<"Challenge"> | string
    description?: StringNullableFilter<"Challenge"> | string | null
    type?: EnumChallengeTypeFilter<"Challenge"> | $Enums.ChallengeType
    order?: IntFilter<"Challenge"> | number
    status?: EnumChallengeStatusFilter<"Challenge"> | $Enums.ChallengeStatus
    created_at?: DateTimeFilter<"Challenge"> | Date | string
    updated_at?: DateTimeFilter<"Challenge"> | Date | string
    questions?: ChallengeQuestionListRelationFilter
    challengeScore?: ChallengeScoreListRelationFilter
    puzzleChallenge?: XOR<PuzzleChallengeNullableScalarRelationFilter, PuzzleChallengeWhereInput> | null
    orderingChallenge?: XOR<OrderingChallengeNullableScalarRelationFilter, OrderingChallengeWhereInput> | null
    fillBlankChallenge?: XOR<FillBlankChallengeNullableScalarRelationFilter, FillBlankChallengeWhereInput> | null
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    questions?: ChallengeQuestionOrderByRelationAggregateInput
    challengeScore?: ChallengeScoreOrderByRelationAggregateInput
    puzzleChallenge?: PuzzleChallengeOrderByWithRelationInput
    orderingChallenge?: OrderingChallengeOrderByWithRelationInput
    fillBlankChallenge?: FillBlankChallengeOrderByWithRelationInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    title?: StringFilter<"Challenge"> | string
    description?: StringNullableFilter<"Challenge"> | string | null
    type?: EnumChallengeTypeFilter<"Challenge"> | $Enums.ChallengeType
    order?: IntFilter<"Challenge"> | number
    status?: EnumChallengeStatusFilter<"Challenge"> | $Enums.ChallengeStatus
    created_at?: DateTimeFilter<"Challenge"> | Date | string
    updated_at?: DateTimeFilter<"Challenge"> | Date | string
    questions?: ChallengeQuestionListRelationFilter
    challengeScore?: ChallengeScoreListRelationFilter
    puzzleChallenge?: XOR<PuzzleChallengeNullableScalarRelationFilter, PuzzleChallengeWhereInput> | null
    orderingChallenge?: XOR<OrderingChallengeNullableScalarRelationFilter, OrderingChallengeWhereInput> | null
    fillBlankChallenge?: XOR<FillBlankChallengeNullableScalarRelationFilter, FillBlankChallengeWhereInput> | null
  }, "id" | "slug">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Challenge"> | string
    title?: StringWithAggregatesFilter<"Challenge"> | string
    slug?: StringWithAggregatesFilter<"Challenge"> | string
    description?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    type?: EnumChallengeTypeWithAggregatesFilter<"Challenge"> | $Enums.ChallengeType
    order?: IntWithAggregatesFilter<"Challenge"> | number
    status?: EnumChallengeStatusWithAggregatesFilter<"Challenge"> | $Enums.ChallengeStatus
    created_at?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
  }

  export type ChallengeQuestionWhereInput = {
    AND?: ChallengeQuestionWhereInput | ChallengeQuestionWhereInput[]
    OR?: ChallengeQuestionWhereInput[]
    NOT?: ChallengeQuestionWhereInput | ChallengeQuestionWhereInput[]
    id?: UuidFilter<"ChallengeQuestion"> | string
    challenge_id?: UuidFilter<"ChallengeQuestion"> | string
    question?: StringFilter<"ChallengeQuestion"> | string
    explanation?: StringNullableFilter<"ChallengeQuestion"> | string | null
    created_at?: DateTimeFilter<"ChallengeQuestion"> | Date | string
    updated_at?: DateTimeFilter<"ChallengeQuestion"> | Date | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    answers?: ChallengeAnswerListRelationFilter
  }

  export type ChallengeQuestionOrderByWithRelationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    answers?: ChallengeAnswerOrderByRelationAggregateInput
  }

  export type ChallengeQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeQuestionWhereInput | ChallengeQuestionWhereInput[]
    OR?: ChallengeQuestionWhereInput[]
    NOT?: ChallengeQuestionWhereInput | ChallengeQuestionWhereInput[]
    challenge_id?: UuidFilter<"ChallengeQuestion"> | string
    question?: StringFilter<"ChallengeQuestion"> | string
    explanation?: StringNullableFilter<"ChallengeQuestion"> | string | null
    created_at?: DateTimeFilter<"ChallengeQuestion"> | Date | string
    updated_at?: DateTimeFilter<"ChallengeQuestion"> | Date | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    answers?: ChallengeAnswerListRelationFilter
  }, "id">

  export type ChallengeQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChallengeQuestionCountOrderByAggregateInput
    _max?: ChallengeQuestionMaxOrderByAggregateInput
    _min?: ChallengeQuestionMinOrderByAggregateInput
  }

  export type ChallengeQuestionScalarWhereWithAggregatesInput = {
    AND?: ChallengeQuestionScalarWhereWithAggregatesInput | ChallengeQuestionScalarWhereWithAggregatesInput[]
    OR?: ChallengeQuestionScalarWhereWithAggregatesInput[]
    NOT?: ChallengeQuestionScalarWhereWithAggregatesInput | ChallengeQuestionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ChallengeQuestion"> | string
    challenge_id?: UuidWithAggregatesFilter<"ChallengeQuestion"> | string
    question?: StringWithAggregatesFilter<"ChallengeQuestion"> | string
    explanation?: StringNullableWithAggregatesFilter<"ChallengeQuestion"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ChallengeQuestion"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChallengeQuestion"> | Date | string
  }

  export type ChallengeAnswerWhereInput = {
    AND?: ChallengeAnswerWhereInput | ChallengeAnswerWhereInput[]
    OR?: ChallengeAnswerWhereInput[]
    NOT?: ChallengeAnswerWhereInput | ChallengeAnswerWhereInput[]
    id?: UuidFilter<"ChallengeAnswer"> | string
    challenge_question_id?: UuidFilter<"ChallengeAnswer"> | string
    answer?: StringFilter<"ChallengeAnswer"> | string
    is_correct?: BoolFilter<"ChallengeAnswer"> | boolean
    created_at?: DateTimeFilter<"ChallengeAnswer"> | Date | string
    updated_at?: DateTimeFilter<"ChallengeAnswer"> | Date | string
    challenge_question?: XOR<ChallengeQuestionScalarRelationFilter, ChallengeQuestionWhereInput>
  }

  export type ChallengeAnswerOrderByWithRelationInput = {
    id?: SortOrder
    challenge_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    challenge_question?: ChallengeQuestionOrderByWithRelationInput
  }

  export type ChallengeAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeAnswerWhereInput | ChallengeAnswerWhereInput[]
    OR?: ChallengeAnswerWhereInput[]
    NOT?: ChallengeAnswerWhereInput | ChallengeAnswerWhereInput[]
    challenge_question_id?: UuidFilter<"ChallengeAnswer"> | string
    answer?: StringFilter<"ChallengeAnswer"> | string
    is_correct?: BoolFilter<"ChallengeAnswer"> | boolean
    created_at?: DateTimeFilter<"ChallengeAnswer"> | Date | string
    updated_at?: DateTimeFilter<"ChallengeAnswer"> | Date | string
    challenge_question?: XOR<ChallengeQuestionScalarRelationFilter, ChallengeQuestionWhereInput>
  }, "id">

  export type ChallengeAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    challenge_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChallengeAnswerCountOrderByAggregateInput
    _max?: ChallengeAnswerMaxOrderByAggregateInput
    _min?: ChallengeAnswerMinOrderByAggregateInput
  }

  export type ChallengeAnswerScalarWhereWithAggregatesInput = {
    AND?: ChallengeAnswerScalarWhereWithAggregatesInput | ChallengeAnswerScalarWhereWithAggregatesInput[]
    OR?: ChallengeAnswerScalarWhereWithAggregatesInput[]
    NOT?: ChallengeAnswerScalarWhereWithAggregatesInput | ChallengeAnswerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ChallengeAnswer"> | string
    challenge_question_id?: UuidWithAggregatesFilter<"ChallengeAnswer"> | string
    answer?: StringWithAggregatesFilter<"ChallengeAnswer"> | string
    is_correct?: BoolWithAggregatesFilter<"ChallengeAnswer"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ChallengeAnswer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChallengeAnswer"> | Date | string
  }

  export type PuzzleChallengeWhereInput = {
    AND?: PuzzleChallengeWhereInput | PuzzleChallengeWhereInput[]
    OR?: PuzzleChallengeWhereInput[]
    NOT?: PuzzleChallengeWhereInput | PuzzleChallengeWhereInput[]
    id?: UuidFilter<"PuzzleChallenge"> | string
    challenge_id?: UuidFilter<"PuzzleChallenge"> | string
    instruction?: StringFilter<"PuzzleChallenge"> | string
    image?: StringFilter<"PuzzleChallenge"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type PuzzleChallengeOrderByWithRelationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
    image?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type PuzzleChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    challenge_id?: string
    AND?: PuzzleChallengeWhereInput | PuzzleChallengeWhereInput[]
    OR?: PuzzleChallengeWhereInput[]
    NOT?: PuzzleChallengeWhereInput | PuzzleChallengeWhereInput[]
    instruction?: StringFilter<"PuzzleChallenge"> | string
    image?: StringFilter<"PuzzleChallenge"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id" | "challenge_id">

  export type PuzzleChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
    image?: SortOrder
    _count?: PuzzleChallengeCountOrderByAggregateInput
    _max?: PuzzleChallengeMaxOrderByAggregateInput
    _min?: PuzzleChallengeMinOrderByAggregateInput
  }

  export type PuzzleChallengeScalarWhereWithAggregatesInput = {
    AND?: PuzzleChallengeScalarWhereWithAggregatesInput | PuzzleChallengeScalarWhereWithAggregatesInput[]
    OR?: PuzzleChallengeScalarWhereWithAggregatesInput[]
    NOT?: PuzzleChallengeScalarWhereWithAggregatesInput | PuzzleChallengeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PuzzleChallenge"> | string
    challenge_id?: UuidWithAggregatesFilter<"PuzzleChallenge"> | string
    instruction?: StringWithAggregatesFilter<"PuzzleChallenge"> | string
    image?: StringWithAggregatesFilter<"PuzzleChallenge"> | string
  }

  export type OrderingChallengeWhereInput = {
    AND?: OrderingChallengeWhereInput | OrderingChallengeWhereInput[]
    OR?: OrderingChallengeWhereInput[]
    NOT?: OrderingChallengeWhereInput | OrderingChallengeWhereInput[]
    id?: UuidFilter<"OrderingChallenge"> | string
    challenge_id?: UuidFilter<"OrderingChallenge"> | string
    instruction?: StringFilter<"OrderingChallenge"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    items?: OrderingItemListRelationFilter
  }

  export type OrderingChallengeOrderByWithRelationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    items?: OrderingItemOrderByRelationAggregateInput
  }

  export type OrderingChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    challenge_id?: string
    AND?: OrderingChallengeWhereInput | OrderingChallengeWhereInput[]
    OR?: OrderingChallengeWhereInput[]
    NOT?: OrderingChallengeWhereInput | OrderingChallengeWhereInput[]
    instruction?: StringFilter<"OrderingChallenge"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    items?: OrderingItemListRelationFilter
  }, "id" | "challenge_id">

  export type OrderingChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
    _count?: OrderingChallengeCountOrderByAggregateInput
    _max?: OrderingChallengeMaxOrderByAggregateInput
    _min?: OrderingChallengeMinOrderByAggregateInput
  }

  export type OrderingChallengeScalarWhereWithAggregatesInput = {
    AND?: OrderingChallengeScalarWhereWithAggregatesInput | OrderingChallengeScalarWhereWithAggregatesInput[]
    OR?: OrderingChallengeScalarWhereWithAggregatesInput[]
    NOT?: OrderingChallengeScalarWhereWithAggregatesInput | OrderingChallengeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OrderingChallenge"> | string
    challenge_id?: UuidWithAggregatesFilter<"OrderingChallenge"> | string
    instruction?: StringWithAggregatesFilter<"OrderingChallenge"> | string
  }

  export type OrderingItemWhereInput = {
    AND?: OrderingItemWhereInput | OrderingItemWhereInput[]
    OR?: OrderingItemWhereInput[]
    NOT?: OrderingItemWhereInput | OrderingItemWhereInput[]
    id?: UuidFilter<"OrderingItem"> | string
    ordering_id?: UuidFilter<"OrderingItem"> | string
    content?: StringFilter<"OrderingItem"> | string
    correct_order?: IntFilter<"OrderingItem"> | number
    explanation?: StringNullableFilter<"OrderingItem"> | string | null
    orderingChallenge?: XOR<OrderingChallengeScalarRelationFilter, OrderingChallengeWhereInput>
  }

  export type OrderingItemOrderByWithRelationInput = {
    id?: SortOrder
    ordering_id?: SortOrder
    content?: SortOrder
    correct_order?: SortOrder
    explanation?: SortOrderInput | SortOrder
    orderingChallenge?: OrderingChallengeOrderByWithRelationInput
  }

  export type OrderingItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderingItemWhereInput | OrderingItemWhereInput[]
    OR?: OrderingItemWhereInput[]
    NOT?: OrderingItemWhereInput | OrderingItemWhereInput[]
    ordering_id?: UuidFilter<"OrderingItem"> | string
    content?: StringFilter<"OrderingItem"> | string
    correct_order?: IntFilter<"OrderingItem"> | number
    explanation?: StringNullableFilter<"OrderingItem"> | string | null
    orderingChallenge?: XOR<OrderingChallengeScalarRelationFilter, OrderingChallengeWhereInput>
  }, "id">

  export type OrderingItemOrderByWithAggregationInput = {
    id?: SortOrder
    ordering_id?: SortOrder
    content?: SortOrder
    correct_order?: SortOrder
    explanation?: SortOrderInput | SortOrder
    _count?: OrderingItemCountOrderByAggregateInput
    _avg?: OrderingItemAvgOrderByAggregateInput
    _max?: OrderingItemMaxOrderByAggregateInput
    _min?: OrderingItemMinOrderByAggregateInput
    _sum?: OrderingItemSumOrderByAggregateInput
  }

  export type OrderingItemScalarWhereWithAggregatesInput = {
    AND?: OrderingItemScalarWhereWithAggregatesInput | OrderingItemScalarWhereWithAggregatesInput[]
    OR?: OrderingItemScalarWhereWithAggregatesInput[]
    NOT?: OrderingItemScalarWhereWithAggregatesInput | OrderingItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OrderingItem"> | string
    ordering_id?: UuidWithAggregatesFilter<"OrderingItem"> | string
    content?: StringWithAggregatesFilter<"OrderingItem"> | string
    correct_order?: IntWithAggregatesFilter<"OrderingItem"> | number
    explanation?: StringNullableWithAggregatesFilter<"OrderingItem"> | string | null
  }

  export type FillBlankChallengeWhereInput = {
    AND?: FillBlankChallengeWhereInput | FillBlankChallengeWhereInput[]
    OR?: FillBlankChallengeWhereInput[]
    NOT?: FillBlankChallengeWhereInput | FillBlankChallengeWhereInput[]
    id?: UuidFilter<"FillBlankChallenge"> | string
    challenge_id?: UuidFilter<"FillBlankChallenge"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    questions?: FillBlankQuestionListRelationFilter
  }

  export type FillBlankChallengeOrderByWithRelationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    questions?: FillBlankQuestionOrderByRelationAggregateInput
  }

  export type FillBlankChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    challenge_id?: string
    AND?: FillBlankChallengeWhereInput | FillBlankChallengeWhereInput[]
    OR?: FillBlankChallengeWhereInput[]
    NOT?: FillBlankChallengeWhereInput | FillBlankChallengeWhereInput[]
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    questions?: FillBlankQuestionListRelationFilter
  }, "id" | "challenge_id">

  export type FillBlankChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    _count?: FillBlankChallengeCountOrderByAggregateInput
    _max?: FillBlankChallengeMaxOrderByAggregateInput
    _min?: FillBlankChallengeMinOrderByAggregateInput
  }

  export type FillBlankChallengeScalarWhereWithAggregatesInput = {
    AND?: FillBlankChallengeScalarWhereWithAggregatesInput | FillBlankChallengeScalarWhereWithAggregatesInput[]
    OR?: FillBlankChallengeScalarWhereWithAggregatesInput[]
    NOT?: FillBlankChallengeScalarWhereWithAggregatesInput | FillBlankChallengeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FillBlankChallenge"> | string
    challenge_id?: UuidWithAggregatesFilter<"FillBlankChallenge"> | string
  }

  export type FillBlankQuestionWhereInput = {
    AND?: FillBlankQuestionWhereInput | FillBlankQuestionWhereInput[]
    OR?: FillBlankQuestionWhereInput[]
    NOT?: FillBlankQuestionWhereInput | FillBlankQuestionWhereInput[]
    id?: UuidFilter<"FillBlankQuestion"> | string
    challenge_id?: UuidFilter<"FillBlankQuestion"> | string
    sentence?: StringFilter<"FillBlankQuestion"> | string
    correct_word?: StringFilter<"FillBlankQuestion"> | string
    challenge?: XOR<FillBlankChallengeScalarRelationFilter, FillBlankChallengeWhereInput>
  }

  export type FillBlankQuestionOrderByWithRelationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    sentence?: SortOrder
    correct_word?: SortOrder
    challenge?: FillBlankChallengeOrderByWithRelationInput
  }

  export type FillBlankQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FillBlankQuestionWhereInput | FillBlankQuestionWhereInput[]
    OR?: FillBlankQuestionWhereInput[]
    NOT?: FillBlankQuestionWhereInput | FillBlankQuestionWhereInput[]
    challenge_id?: UuidFilter<"FillBlankQuestion"> | string
    sentence?: StringFilter<"FillBlankQuestion"> | string
    correct_word?: StringFilter<"FillBlankQuestion"> | string
    challenge?: XOR<FillBlankChallengeScalarRelationFilter, FillBlankChallengeWhereInput>
  }, "id">

  export type FillBlankQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    sentence?: SortOrder
    correct_word?: SortOrder
    _count?: FillBlankQuestionCountOrderByAggregateInput
    _max?: FillBlankQuestionMaxOrderByAggregateInput
    _min?: FillBlankQuestionMinOrderByAggregateInput
  }

  export type FillBlankQuestionScalarWhereWithAggregatesInput = {
    AND?: FillBlankQuestionScalarWhereWithAggregatesInput | FillBlankQuestionScalarWhereWithAggregatesInput[]
    OR?: FillBlankQuestionScalarWhereWithAggregatesInput[]
    NOT?: FillBlankQuestionScalarWhereWithAggregatesInput | FillBlankQuestionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FillBlankQuestion"> | string
    challenge_id?: UuidWithAggregatesFilter<"FillBlankQuestion"> | string
    sentence?: StringWithAggregatesFilter<"FillBlankQuestion"> | string
    correct_word?: StringWithAggregatesFilter<"FillBlankQuestion"> | string
  }

  export type UserLessonProgressWhereInput = {
    AND?: UserLessonProgressWhereInput | UserLessonProgressWhereInput[]
    OR?: UserLessonProgressWhereInput[]
    NOT?: UserLessonProgressWhereInput | UserLessonProgressWhereInput[]
    id?: UuidFilter<"UserLessonProgress"> | string
    user_id?: UuidFilter<"UserLessonProgress"> | string
    lesson_id?: UuidFilter<"UserLessonProgress"> | string
    completed_at?: DateTimeNullableFilter<"UserLessonProgress"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type UserLessonProgressOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lesson_id?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type UserLessonProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_lesson_id?: UserLessonProgressUser_idLesson_idCompoundUniqueInput
    AND?: UserLessonProgressWhereInput | UserLessonProgressWhereInput[]
    OR?: UserLessonProgressWhereInput[]
    NOT?: UserLessonProgressWhereInput | UserLessonProgressWhereInput[]
    user_id?: UuidFilter<"UserLessonProgress"> | string
    lesson_id?: UuidFilter<"UserLessonProgress"> | string
    completed_at?: DateTimeNullableFilter<"UserLessonProgress"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id" | "user_id_lesson_id">

  export type UserLessonProgressOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lesson_id?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    _count?: UserLessonProgressCountOrderByAggregateInput
    _max?: UserLessonProgressMaxOrderByAggregateInput
    _min?: UserLessonProgressMinOrderByAggregateInput
  }

  export type UserLessonProgressScalarWhereWithAggregatesInput = {
    AND?: UserLessonProgressScalarWhereWithAggregatesInput | UserLessonProgressScalarWhereWithAggregatesInput[]
    OR?: UserLessonProgressScalarWhereWithAggregatesInput[]
    NOT?: UserLessonProgressScalarWhereWithAggregatesInput | UserLessonProgressScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserLessonProgress"> | string
    user_id?: UuidWithAggregatesFilter<"UserLessonProgress"> | string
    lesson_id?: UuidWithAggregatesFilter<"UserLessonProgress"> | string
    completed_at?: DateTimeNullableWithAggregatesFilter<"UserLessonProgress"> | Date | string | null
  }

  export type ChallengeScoreWhereInput = {
    AND?: ChallengeScoreWhereInput | ChallengeScoreWhereInput[]
    OR?: ChallengeScoreWhereInput[]
    NOT?: ChallengeScoreWhereInput | ChallengeScoreWhereInput[]
    id?: UuidFilter<"ChallengeScore"> | string
    user_id?: UuidFilter<"ChallengeScore"> | string
    challenge_id?: UuidFilter<"ChallengeScore"> | string
    score?: FloatFilter<"ChallengeScore"> | number
    submitted_at?: DateTimeFilter<"ChallengeScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeScoreOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    score?: SortOrder
    submitted_at?: SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type ChallengeScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_challenge_id?: ChallengeScoreUser_idChallenge_idCompoundUniqueInput
    AND?: ChallengeScoreWhereInput | ChallengeScoreWhereInput[]
    OR?: ChallengeScoreWhereInput[]
    NOT?: ChallengeScoreWhereInput | ChallengeScoreWhereInput[]
    user_id?: UuidFilter<"ChallengeScore"> | string
    challenge_id?: UuidFilter<"ChallengeScore"> | string
    score?: FloatFilter<"ChallengeScore"> | number
    submitted_at?: DateTimeFilter<"ChallengeScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id" | "user_id_challenge_id">

  export type ChallengeScoreOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    score?: SortOrder
    submitted_at?: SortOrder
    _count?: ChallengeScoreCountOrderByAggregateInput
    _avg?: ChallengeScoreAvgOrderByAggregateInput
    _max?: ChallengeScoreMaxOrderByAggregateInput
    _min?: ChallengeScoreMinOrderByAggregateInput
    _sum?: ChallengeScoreSumOrderByAggregateInput
  }

  export type ChallengeScoreScalarWhereWithAggregatesInput = {
    AND?: ChallengeScoreScalarWhereWithAggregatesInput | ChallengeScoreScalarWhereWithAggregatesInput[]
    OR?: ChallengeScoreScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScoreScalarWhereWithAggregatesInput | ChallengeScoreScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ChallengeScore"> | string
    user_id?: UuidWithAggregatesFilter<"ChallengeScore"> | string
    challenge_id?: UuidWithAggregatesFilter<"ChallengeScore"> | string
    score?: FloatWithAggregatesFilter<"ChallengeScore"> | number
    submitted_at?: DateTimeWithAggregatesFilter<"ChallengeScore"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: UuidFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type UserLessonScoreWhereInput = {
    AND?: UserLessonScoreWhereInput | UserLessonScoreWhereInput[]
    OR?: UserLessonScoreWhereInput[]
    NOT?: UserLessonScoreWhereInput | UserLessonScoreWhereInput[]
    id?: UuidFilter<"UserLessonScore"> | string
    userId?: UuidFilter<"UserLessonScore"> | string
    lessonId?: UuidFilter<"UserLessonScore"> | string
    score?: FloatFilter<"UserLessonScore"> | number
    createdAt?: DateTimeFilter<"UserLessonScore"> | Date | string
    updatedAt?: DateTimeFilter<"UserLessonScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type UserLessonScoreOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type UserLessonScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_lessonId?: UserLessonScoreUserIdLessonIdCompoundUniqueInput
    AND?: UserLessonScoreWhereInput | UserLessonScoreWhereInput[]
    OR?: UserLessonScoreWhereInput[]
    NOT?: UserLessonScoreWhereInput | UserLessonScoreWhereInput[]
    userId?: UuidFilter<"UserLessonScore"> | string
    lessonId?: UuidFilter<"UserLessonScore"> | string
    score?: FloatFilter<"UserLessonScore"> | number
    createdAt?: DateTimeFilter<"UserLessonScore"> | Date | string
    updatedAt?: DateTimeFilter<"UserLessonScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id" | "userId_lessonId">

  export type UserLessonScoreOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserLessonScoreCountOrderByAggregateInput
    _avg?: UserLessonScoreAvgOrderByAggregateInput
    _max?: UserLessonScoreMaxOrderByAggregateInput
    _min?: UserLessonScoreMinOrderByAggregateInput
    _sum?: UserLessonScoreSumOrderByAggregateInput
  }

  export type UserLessonScoreScalarWhereWithAggregatesInput = {
    AND?: UserLessonScoreScalarWhereWithAggregatesInput | UserLessonScoreScalarWhereWithAggregatesInput[]
    OR?: UserLessonScoreScalarWhereWithAggregatesInput[]
    NOT?: UserLessonScoreScalarWhereWithAggregatesInput | UserLessonScoreScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserLessonScore"> | string
    userId?: UuidWithAggregatesFilter<"UserLessonScore"> | string
    lessonId?: UuidWithAggregatesFilter<"UserLessonScore"> | string
    score?: FloatWithAggregatesFilter<"UserLessonScore"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserLessonScore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserLessonScore"> | Date | string
  }

  export type UserCourseProgressWhereInput = {
    AND?: UserCourseProgressWhereInput | UserCourseProgressWhereInput[]
    OR?: UserCourseProgressWhereInput[]
    NOT?: UserCourseProgressWhereInput | UserCourseProgressWhereInput[]
    id?: UuidFilter<"UserCourseProgress"> | string
    user_id?: UuidFilter<"UserCourseProgress"> | string
    product_id?: UuidFilter<"UserCourseProgress"> | string
    completed_at?: DateTimeNullableFilter<"UserCourseProgress"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type UserCourseProgressOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    course?: ProductOrderByWithRelationInput
  }

  export type UserCourseProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_product_id?: UserCourseProgressUser_idProduct_idCompoundUniqueInput
    AND?: UserCourseProgressWhereInput | UserCourseProgressWhereInput[]
    OR?: UserCourseProgressWhereInput[]
    NOT?: UserCourseProgressWhereInput | UserCourseProgressWhereInput[]
    user_id?: UuidFilter<"UserCourseProgress"> | string
    product_id?: UuidFilter<"UserCourseProgress"> | string
    completed_at?: DateTimeNullableFilter<"UserCourseProgress"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "user_id_product_id">

  export type UserCourseProgressOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    _count?: UserCourseProgressCountOrderByAggregateInput
    _max?: UserCourseProgressMaxOrderByAggregateInput
    _min?: UserCourseProgressMinOrderByAggregateInput
  }

  export type UserCourseProgressScalarWhereWithAggregatesInput = {
    AND?: UserCourseProgressScalarWhereWithAggregatesInput | UserCourseProgressScalarWhereWithAggregatesInput[]
    OR?: UserCourseProgressScalarWhereWithAggregatesInput[]
    NOT?: UserCourseProgressScalarWhereWithAggregatesInput | UserCourseProgressScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserCourseProgress"> | string
    user_id?: UuidWithAggregatesFilter<"UserCourseProgress"> | string
    product_id?: UuidWithAggregatesFilter<"UserCourseProgress"> | string
    completed_at?: DateTimeNullableWithAggregatesFilter<"UserCourseProgress"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
  }

  export type OTPCreateInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    code: string
    isUsed?: boolean
    user: UserCreateNestedOneWithoutOtpsInput
  }

  export type OTPUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    code: string
    isUsed?: boolean
    userId: string
  }

  export type OTPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOtpsNestedInput
  }

  export type OTPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OTPCreateManyInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    code: string
    isUsed?: boolean
    userId: string
  }

  export type OTPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OTPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    status?: $Enums.CategoryStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    status?: $Enums.CategoryStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryStatusFieldUpdateOperationsInput | $Enums.CategoryStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryStatusFieldUpdateOperationsInput | $Enums.CategoryStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    status?: $Enums.CategoryStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryStatusFieldUpdateOperationsInput | $Enums.CategoryStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryStatusFieldUpdateOperationsInput | $Enums.CategoryStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutCourseInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    category_id: string
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    category_id: string
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModuleCreateInput = {
    id?: string
    title: string
    short_description: string
    order?: number
    status?: $Enums.ModuleStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    course: ProductCreateNestedOneWithoutModulesInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    course_id: string
    title: string
    short_description: string
    order?: number
    status?: $Enums.ModuleStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumModuleStatusFieldUpdateOperationsInput | $Enums.ModuleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: ProductUpdateOneRequiredWithoutModulesNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumModuleStatusFieldUpdateOperationsInput | $Enums.ModuleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    course_id: string
    title: string
    short_description: string
    order?: number
    status?: $Enums.ModuleStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumModuleStatusFieldUpdateOperationsInput | $Enums.ModuleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumModuleStatusFieldUpdateOperationsInput | $Enums.ModuleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    module: ModuleCreateNestedOneWithoutLessonsInput
    question?: QuizQuestionCreateNestedManyWithoutLessonInput
    userProgress?: UserLessonProgressCreateNestedManyWithoutLessonInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    module_id: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    question?: QuizQuestionUncheckedCreateNestedManyWithoutLessonInput
    userProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutLessonInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    question?: QuizQuestionUpdateManyWithoutLessonNestedInput
    userProgress?: UserLessonProgressUpdateManyWithoutLessonNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    module_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuizQuestionUncheckedUpdateManyWithoutLessonNestedInput
    userProgress?: UserLessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    module_id: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    module_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentCreateInput = {
    id?: string
    created_at?: Date | string
    product: ProductCreateNestedOneWithoutEnrollmentsInput
    user: UserCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    user_id: string
    product_id: string
    created_at?: Date | string
  }

  export type EnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutEnrollmentsNestedInput
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    user_id: string
    product_id: string
    created_at?: Date | string
  }

  export type EnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    status?: boolean
    created_at?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    user_id: string
    product_id: string
    rating: number
    comment?: string | null
    status?: boolean
    created_at?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    user_id: string
    product_id: string
    rating: number
    comment?: string | null
    status?: boolean
    created_at?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    lesson: LessonCreateNestedOneWithoutQuestionInput
    answers?: QuizAnswerCreateNestedManyWithoutQuiz_questionInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: string
    lesson_id: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuiz_questionInput
  }

  export type QuizQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutQuestionNestedInput
    answers?: QuizAnswerUpdateManyWithoutQuiz_questionNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lesson_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuiz_questionNestedInput
  }

  export type QuizQuestionCreateManyInput = {
    id?: string
    lesson_id: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuizQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lesson_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerCreateInput = {
    id?: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    quiz_question: QuizQuestionCreateNestedOneWithoutAnswersInput
  }

  export type QuizAnswerUncheckedCreateInput = {
    id?: string
    quiz_question_id: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuizAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz_question?: QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuizAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_question_id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerCreateManyInput = {
    id?: string
    quiz_question_id: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuizAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_question_id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionCreateNestedManyWithoutChallengeInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeCreateNestedOneWithoutChallengeInput
    orderingChallenge?: OrderingChallengeCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionUncheckedCreateNestedManyWithoutChallengeInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeUncheckedCreateNestedOneWithoutChallengeInput
    orderingChallenge?: OrderingChallengeUncheckedCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeUncheckedCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUpdateManyWithoutChallengeNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUpdateOneWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUpdateOneWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUncheckedUpdateManyWithoutChallengeNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUncheckedUpdateOneWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUncheckedUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUncheckedUpdateOneWithoutChallengeNestedInput
  }

  export type ChallengeCreateManyInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeQuestionCreateInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    challenge: ChallengeCreateNestedOneWithoutQuestionsInput
    answers?: ChallengeAnswerCreateNestedManyWithoutChallenge_questionInput
  }

  export type ChallengeQuestionUncheckedCreateInput = {
    id?: string
    challenge_id: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    answers?: ChallengeAnswerUncheckedCreateNestedManyWithoutChallenge_questionInput
  }

  export type ChallengeQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutQuestionsNestedInput
    answers?: ChallengeAnswerUpdateManyWithoutChallenge_questionNestedInput
  }

  export type ChallengeQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: ChallengeAnswerUncheckedUpdateManyWithoutChallenge_questionNestedInput
  }

  export type ChallengeQuestionCreateManyInput = {
    id?: string
    challenge_id: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAnswerCreateInput = {
    id?: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    challenge_question: ChallengeQuestionCreateNestedOneWithoutAnswersInput
  }

  export type ChallengeAnswerUncheckedCreateInput = {
    id?: string
    challenge_question_id: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge_question?: ChallengeQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type ChallengeAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_question_id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAnswerCreateManyInput = {
    id?: string
    challenge_question_id: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_question_id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PuzzleChallengeCreateInput = {
    id?: string
    instruction: string
    image: string
    challenge: ChallengeCreateNestedOneWithoutPuzzleChallengeInput
  }

  export type PuzzleChallengeUncheckedCreateInput = {
    id?: string
    challenge_id: string
    instruction: string
    image: string
  }

  export type PuzzleChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutPuzzleChallengeNestedInput
  }

  export type PuzzleChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type PuzzleChallengeCreateManyInput = {
    id?: string
    challenge_id: string
    instruction: string
    image: string
  }

  export type PuzzleChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type PuzzleChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type OrderingChallengeCreateInput = {
    id?: string
    instruction: string
    challenge: ChallengeCreateNestedOneWithoutOrderingChallengeInput
    items?: OrderingItemCreateNestedManyWithoutOrderingChallengeInput
  }

  export type OrderingChallengeUncheckedCreateInput = {
    id?: string
    challenge_id: string
    instruction: string
    items?: OrderingItemUncheckedCreateNestedManyWithoutOrderingChallengeInput
  }

  export type OrderingChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutOrderingChallengeNestedInput
    items?: OrderingItemUpdateManyWithoutOrderingChallengeNestedInput
  }

  export type OrderingChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    items?: OrderingItemUncheckedUpdateManyWithoutOrderingChallengeNestedInput
  }

  export type OrderingChallengeCreateManyInput = {
    id?: string
    challenge_id: string
    instruction: string
  }

  export type OrderingChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
  }

  export type OrderingChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
  }

  export type OrderingItemCreateInput = {
    id?: string
    content: string
    correct_order: number
    explanation?: string | null
    orderingChallenge: OrderingChallengeCreateNestedOneWithoutItemsInput
  }

  export type OrderingItemUncheckedCreateInput = {
    id?: string
    ordering_id: string
    content: string
    correct_order: number
    explanation?: string | null
  }

  export type OrderingItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    correct_order?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    orderingChallenge?: OrderingChallengeUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderingItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordering_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    correct_order?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderingItemCreateManyInput = {
    id?: string
    ordering_id: string
    content: string
    correct_order: number
    explanation?: string | null
  }

  export type OrderingItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    correct_order?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderingItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordering_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    correct_order?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FillBlankChallengeCreateInput = {
    id?: string
    challenge: ChallengeCreateNestedOneWithoutFillBlankChallengeInput
    questions?: FillBlankQuestionCreateNestedManyWithoutChallengeInput
  }

  export type FillBlankChallengeUncheckedCreateInput = {
    id?: string
    challenge_id: string
    questions?: FillBlankQuestionUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type FillBlankChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutFillBlankChallengeNestedInput
    questions?: FillBlankQuestionUpdateManyWithoutChallengeNestedInput
  }

  export type FillBlankChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    questions?: FillBlankQuestionUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type FillBlankChallengeCreateManyInput = {
    id?: string
    challenge_id: string
  }

  export type FillBlankChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type FillBlankChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
  }

  export type FillBlankQuestionCreateInput = {
    id?: string
    sentence: string
    correct_word: string
    challenge: FillBlankChallengeCreateNestedOneWithoutQuestionsInput
  }

  export type FillBlankQuestionUncheckedCreateInput = {
    id?: string
    challenge_id: string
    sentence: string
    correct_word: string
  }

  export type FillBlankQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentence?: StringFieldUpdateOperationsInput | string
    correct_word?: StringFieldUpdateOperationsInput | string
    challenge?: FillBlankChallengeUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type FillBlankQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    sentence?: StringFieldUpdateOperationsInput | string
    correct_word?: StringFieldUpdateOperationsInput | string
  }

  export type FillBlankQuestionCreateManyInput = {
    id?: string
    challenge_id: string
    sentence: string
    correct_word: string
  }

  export type FillBlankQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentence?: StringFieldUpdateOperationsInput | string
    correct_word?: StringFieldUpdateOperationsInput | string
  }

  export type FillBlankQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    sentence?: StringFieldUpdateOperationsInput | string
    correct_word?: StringFieldUpdateOperationsInput | string
  }

  export type UserLessonProgressCreateInput = {
    id?: string
    completed_at?: Date | string | null
    user: UserCreateNestedOneWithoutUserLessonProgressInput
    lesson: LessonCreateNestedOneWithoutUserProgressInput
  }

  export type UserLessonProgressUncheckedCreateInput = {
    id?: string
    user_id: string
    lesson_id: string
    completed_at?: Date | string | null
  }

  export type UserLessonProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserLessonProgressNestedInput
    lesson?: LessonUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserLessonProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    lesson_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLessonProgressCreateManyInput = {
    id?: string
    user_id: string
    lesson_id: string
    completed_at?: Date | string | null
  }

  export type UserLessonProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLessonProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    lesson_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeScoreCreateInput = {
    id?: string
    score: number
    submitted_at?: Date | string
    user: UserCreateNestedOneWithoutChallengeScoreInput
    challenge: ChallengeCreateNestedOneWithoutChallengeScoreInput
  }

  export type ChallengeScoreUncheckedCreateInput = {
    id?: string
    user_id: string
    challenge_id: string
    score: number
    submitted_at?: Date | string
  }

  export type ChallengeScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChallengeScoreNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutChallengeScoreNestedInput
  }

  export type ChallengeScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreCreateManyInput = {
    id?: string
    user_id: string
    challenge_id: string
    score: number
    submitted_at?: Date | string
  }

  export type ChallengeScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonScoreCreateInput = {
    id?: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserLessonScoreInput
    lesson: LessonCreateNestedOneWithoutUserLessonScoreInput
  }

  export type UserLessonScoreUncheckedCreateInput = {
    id?: string
    userId: string
    lessonId: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLessonScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserLessonScoreNestedInput
    lesson?: LessonUpdateOneRequiredWithoutUserLessonScoreNestedInput
  }

  export type UserLessonScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonScoreCreateManyInput = {
    id?: string
    userId: string
    lessonId: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLessonScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseProgressCreateInput = {
    id?: string
    completed_at?: Date | string | null
    user: UserCreateNestedOneWithoutUserCourseProgressInput
    course: ProductCreateNestedOneWithoutUserCourseProgressInput
  }

  export type UserCourseProgressUncheckedCreateInput = {
    id?: string
    user_id: string
    product_id: string
    completed_at?: Date | string | null
  }

  export type UserCourseProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserCourseProgressNestedInput
    course?: ProductUpdateOneRequiredWithoutUserCourseProgressNestedInput
  }

  export type UserCourseProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCourseProgressCreateManyInput = {
    id?: string
    user_id: string
    product_id: string
    completed_at?: Date | string | null
  }

  export type UserCourseProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCourseProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumGradeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Grade | EnumGradeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Grade[] | ListEnumGradeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Grade[] | ListEnumGradeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGradeNullableFilter<$PrismaModel> | $Enums.Grade | null
  }

  export type OTPListRelationFilter = {
    every?: OTPWhereInput
    some?: OTPWhereInput
    none?: OTPWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type UserLessonProgressListRelationFilter = {
    every?: UserLessonProgressWhereInput
    some?: UserLessonProgressWhereInput
    none?: UserLessonProgressWhereInput
  }

  export type ChallengeScoreListRelationFilter = {
    every?: ChallengeScoreWhereInput
    some?: ChallengeScoreWhereInput
    none?: ChallengeScoreWhereInput
  }

  export type UserLessonScoreListRelationFilter = {
    every?: UserLessonScoreWhereInput
    some?: UserLessonScoreWhereInput
    none?: UserLessonScoreWhereInput
  }

  export type UserCourseProgressListRelationFilter = {
    every?: UserCourseProgressWhereInput
    some?: UserCourseProgressWhereInput
    none?: UserCourseProgressWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OTPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLessonProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLessonScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCourseProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    age?: SortOrder
    grade?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    age?: SortOrder
    grade?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    age?: SortOrder
    grade?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumGradeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Grade | EnumGradeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Grade[] | ListEnumGradeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Grade[] | ListEnumGradeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGradeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Grade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGradeNullableFilter<$PrismaModel>
    _max?: NestedEnumGradeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OTPCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
  }

  export type OTPMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
  }

  export type OTPMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
  }

  export type EnumCategoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryStatus | EnumCategoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryStatus[] | ListEnumCategoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryStatus[] | ListEnumCategoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryStatusFilter<$PrismaModel> | $Enums.CategoryStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type EnumCategoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryStatus | EnumCategoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryStatus[] | ListEnumCategoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryStatus[] | ListEnumCategoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.CategoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryStatusFilter<$PrismaModel>
    _max?: NestedEnumCategoryStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumProductLabelFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductLabel | EnumProductLabelFieldRefInput<$PrismaModel>
    in?: $Enums.ProductLabel[] | ListEnumProductLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductLabel[] | ListEnumProductLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumProductLabelFilter<$PrismaModel> | $Enums.ProductLabel
  }

  export type EnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductLabelSlugCompoundUniqueInput = {
    label: $Enums.ProductLabel
    slug: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    thumbnail?: SortOrder
    label?: SortOrder
    status?: SortOrder
    requirements?: SortOrder
    learning_outcomes?: SortOrder
    preview_video?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    thumbnail?: SortOrder
    label?: SortOrder
    status?: SortOrder
    requirements?: SortOrder
    learning_outcomes?: SortOrder
    preview_video?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    short_description?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    thumbnail?: SortOrder
    label?: SortOrder
    status?: SortOrder
    requirements?: SortOrder
    learning_outcomes?: SortOrder
    preview_video?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type EnumProductLabelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductLabel | EnumProductLabelFieldRefInput<$PrismaModel>
    in?: $Enums.ProductLabel[] | ListEnumProductLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductLabel[] | ListEnumProductLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumProductLabelWithAggregatesFilter<$PrismaModel> | $Enums.ProductLabel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductLabelFilter<$PrismaModel>
    _max?: NestedEnumProductLabelFilter<$PrismaModel>
  }

  export type EnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumModuleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModuleStatus | EnumModuleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModuleStatus[] | ListEnumModuleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModuleStatus[] | ListEnumModuleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModuleStatusFilter<$PrismaModel> | $Enums.ModuleStatus
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    title?: SortOrder
    short_description?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    title?: SortOrder
    short_description?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    title?: SortOrder
    short_description?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumModuleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModuleStatus | EnumModuleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModuleStatus[] | ListEnumModuleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModuleStatus[] | ListEnumModuleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModuleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModuleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModuleStatusFilter<$PrismaModel>
    _max?: NestedEnumModuleStatusFilter<$PrismaModel>
  }

  export type EnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type EnumLessonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusFilter<$PrismaModel> | $Enums.LessonStatus
  }

  export type ModuleScalarRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    module_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    is_previewable?: SortOrder
    status?: SortOrder
    order?: SortOrder
    attachment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    module_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    is_previewable?: SortOrder
    status?: SortOrder
    order?: SortOrder
    attachment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    module_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    is_previewable?: SortOrder
    status?: SortOrder
    order?: SortOrder
    attachment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type EnumLessonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusWithAggregatesFilter<$PrismaModel> | $Enums.LessonStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonStatusFilter<$PrismaModel>
    _max?: NestedEnumLessonStatusFilter<$PrismaModel>
  }

  export type EnrollmentUser_idProduct_idCompoundUniqueInput = {
    user_id: string
    product_id: string
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewUser_idProduct_idCompoundUniqueInput = {
    user_id: string
    product_id: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type QuizAnswerListRelationFilter = {
    every?: QuizAnswerWhereInput
    some?: QuizAnswerWhereInput
    none?: QuizAnswerWhereInput
  }

  export type QuizAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type QuizQuestionScalarRelationFilter = {
    is?: QuizQuestionWhereInput
    isNot?: QuizQuestionWhereInput
  }

  export type QuizAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    quiz_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type QuizAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    quiz_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type QuizAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    quiz_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type EnumChallengeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeFilter<$PrismaModel> | $Enums.ChallengeType
  }

  export type EnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus
  }

  export type ChallengeQuestionListRelationFilter = {
    every?: ChallengeQuestionWhereInput
    some?: ChallengeQuestionWhereInput
    none?: ChallengeQuestionWhereInput
  }

  export type PuzzleChallengeNullableScalarRelationFilter = {
    is?: PuzzleChallengeWhereInput | null
    isNot?: PuzzleChallengeWhereInput | null
  }

  export type OrderingChallengeNullableScalarRelationFilter = {
    is?: OrderingChallengeWhereInput | null
    isNot?: OrderingChallengeWhereInput | null
  }

  export type FillBlankChallengeNullableScalarRelationFilter = {
    is?: FillBlankChallengeWhereInput | null
    isNot?: FillBlankChallengeWhereInput | null
  }

  export type ChallengeQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    order?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumChallengeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeTypeFilter<$PrismaModel>
    _max?: NestedEnumChallengeTypeFilter<$PrismaModel>
  }

  export type EnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>
  }

  export type ChallengeScalarRelationFilter = {
    is?: ChallengeWhereInput
    isNot?: ChallengeWhereInput
  }

  export type ChallengeAnswerListRelationFilter = {
    every?: ChallengeAnswerWhereInput
    some?: ChallengeAnswerWhereInput
    none?: ChallengeAnswerWhereInput
  }

  export type ChallengeAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    question?: SortOrder
    explanation?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeQuestionScalarRelationFilter = {
    is?: ChallengeQuestionWhereInput
    isNot?: ChallengeQuestionWhereInput
  }

  export type ChallengeAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    challenge_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    challenge_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    challenge_question_id?: SortOrder
    answer?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PuzzleChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
    image?: SortOrder
  }

  export type PuzzleChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
    image?: SortOrder
  }

  export type PuzzleChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
    image?: SortOrder
  }

  export type OrderingItemListRelationFilter = {
    every?: OrderingItemWhereInput
    some?: OrderingItemWhereInput
    none?: OrderingItemWhereInput
  }

  export type OrderingItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderingChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
  }

  export type OrderingChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
  }

  export type OrderingChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    instruction?: SortOrder
  }

  export type OrderingChallengeScalarRelationFilter = {
    is?: OrderingChallengeWhereInput
    isNot?: OrderingChallengeWhereInput
  }

  export type OrderingItemCountOrderByAggregateInput = {
    id?: SortOrder
    ordering_id?: SortOrder
    content?: SortOrder
    correct_order?: SortOrder
    explanation?: SortOrder
  }

  export type OrderingItemAvgOrderByAggregateInput = {
    correct_order?: SortOrder
  }

  export type OrderingItemMaxOrderByAggregateInput = {
    id?: SortOrder
    ordering_id?: SortOrder
    content?: SortOrder
    correct_order?: SortOrder
    explanation?: SortOrder
  }

  export type OrderingItemMinOrderByAggregateInput = {
    id?: SortOrder
    ordering_id?: SortOrder
    content?: SortOrder
    correct_order?: SortOrder
    explanation?: SortOrder
  }

  export type OrderingItemSumOrderByAggregateInput = {
    correct_order?: SortOrder
  }

  export type FillBlankQuestionListRelationFilter = {
    every?: FillBlankQuestionWhereInput
    some?: FillBlankQuestionWhereInput
    none?: FillBlankQuestionWhereInput
  }

  export type FillBlankQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FillBlankChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
  }

  export type FillBlankChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
  }

  export type FillBlankChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
  }

  export type FillBlankChallengeScalarRelationFilter = {
    is?: FillBlankChallengeWhereInput
    isNot?: FillBlankChallengeWhereInput
  }

  export type FillBlankQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    sentence?: SortOrder
    correct_word?: SortOrder
  }

  export type FillBlankQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    sentence?: SortOrder
    correct_word?: SortOrder
  }

  export type FillBlankQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    sentence?: SortOrder
    correct_word?: SortOrder
  }

  export type UserLessonProgressUser_idLesson_idCompoundUniqueInput = {
    user_id: string
    lesson_id: string
  }

  export type UserLessonProgressCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lesson_id?: SortOrder
    completed_at?: SortOrder
  }

  export type UserLessonProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lesson_id?: SortOrder
    completed_at?: SortOrder
  }

  export type UserLessonProgressMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lesson_id?: SortOrder
    completed_at?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ChallengeScoreUser_idChallenge_idCompoundUniqueInput = {
    user_id: string
    challenge_id: string
  }

  export type ChallengeScoreCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    score?: SortOrder
    submitted_at?: SortOrder
  }

  export type ChallengeScoreAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type ChallengeScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    score?: SortOrder
    submitted_at?: SortOrder
  }

  export type ChallengeScoreMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    score?: SortOrder
    submitted_at?: SortOrder
  }

  export type ChallengeScoreSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLessonScoreUserIdLessonIdCompoundUniqueInput = {
    userId: string
    lessonId: string
  }

  export type UserLessonScoreCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLessonScoreAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type UserLessonScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLessonScoreMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLessonScoreSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type UserCourseProgressUser_idProduct_idCompoundUniqueInput = {
    user_id: string
    product_id: string
  }

  export type UserCourseProgressCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    completed_at?: SortOrder
  }

  export type UserCourseProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    completed_at?: SortOrder
  }

  export type UserCourseProgressMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    completed_at?: SortOrder
  }

  export type OTPCreateNestedManyWithoutUserInput = {
    create?: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput> | OTPCreateWithoutUserInput[] | OTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCreateOrConnectWithoutUserInput | OTPCreateOrConnectWithoutUserInput[]
    createMany?: OTPCreateManyUserInputEnvelope
    connect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserLessonProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput> | UserLessonProgressCreateWithoutUserInput[] | UserLessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutUserInput | UserLessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserLessonProgressCreateManyUserInputEnvelope
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
  }

  export type ChallengeScoreCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput> | ChallengeScoreCreateWithoutUserInput[] | ChallengeScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutUserInput | ChallengeScoreCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeScoreCreateManyUserInputEnvelope
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
  }

  export type UserLessonScoreCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLessonScoreCreateWithoutUserInput, UserLessonScoreUncheckedCreateWithoutUserInput> | UserLessonScoreCreateWithoutUserInput[] | UserLessonScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonScoreCreateOrConnectWithoutUserInput | UserLessonScoreCreateOrConnectWithoutUserInput[]
    createMany?: UserLessonScoreCreateManyUserInputEnvelope
    connect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
  }

  export type UserCourseProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput> | UserCourseProgressCreateWithoutUserInput[] | UserCourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutUserInput | UserCourseProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseProgressCreateManyUserInputEnvelope
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
  }

  export type OTPUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput> | OTPCreateWithoutUserInput[] | OTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCreateOrConnectWithoutUserInput | OTPCreateOrConnectWithoutUserInput[]
    createMany?: OTPCreateManyUserInputEnvelope
    connect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserLessonProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput> | UserLessonProgressCreateWithoutUserInput[] | UserLessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutUserInput | UserLessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserLessonProgressCreateManyUserInputEnvelope
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
  }

  export type ChallengeScoreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput> | ChallengeScoreCreateWithoutUserInput[] | ChallengeScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutUserInput | ChallengeScoreCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeScoreCreateManyUserInputEnvelope
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
  }

  export type UserLessonScoreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLessonScoreCreateWithoutUserInput, UserLessonScoreUncheckedCreateWithoutUserInput> | UserLessonScoreCreateWithoutUserInput[] | UserLessonScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonScoreCreateOrConnectWithoutUserInput | UserLessonScoreCreateOrConnectWithoutUserInput[]
    createMany?: UserLessonScoreCreateManyUserInputEnvelope
    connect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
  }

  export type UserCourseProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput> | UserCourseProgressCreateWithoutUserInput[] | UserCourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutUserInput | UserCourseProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseProgressCreateManyUserInputEnvelope
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumGradeFieldUpdateOperationsInput = {
    set?: $Enums.Grade | null
  }

  export type OTPUpdateManyWithoutUserNestedInput = {
    create?: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput> | OTPCreateWithoutUserInput[] | OTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCreateOrConnectWithoutUserInput | OTPCreateOrConnectWithoutUserInput[]
    upsert?: OTPUpsertWithWhereUniqueWithoutUserInput | OTPUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OTPCreateManyUserInputEnvelope
    set?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    disconnect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    delete?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    connect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    update?: OTPUpdateWithWhereUniqueWithoutUserInput | OTPUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OTPUpdateManyWithWhereWithoutUserInput | OTPUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OTPScalarWhereInput | OTPScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserLessonProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput> | UserLessonProgressCreateWithoutUserInput[] | UserLessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutUserInput | UserLessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserLessonProgressUpsertWithWhereUniqueWithoutUserInput | UserLessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLessonProgressCreateManyUserInputEnvelope
    set?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    disconnect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    delete?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    update?: UserLessonProgressUpdateWithWhereUniqueWithoutUserInput | UserLessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLessonProgressUpdateManyWithWhereWithoutUserInput | UserLessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
  }

  export type ChallengeScoreUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput> | ChallengeScoreCreateWithoutUserInput[] | ChallengeScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutUserInput | ChallengeScoreCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeScoreUpsertWithWhereUniqueWithoutUserInput | ChallengeScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeScoreCreateManyUserInputEnvelope
    set?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    disconnect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    delete?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    update?: ChallengeScoreUpdateWithWhereUniqueWithoutUserInput | ChallengeScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeScoreUpdateManyWithWhereWithoutUserInput | ChallengeScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
  }

  export type UserLessonScoreUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLessonScoreCreateWithoutUserInput, UserLessonScoreUncheckedCreateWithoutUserInput> | UserLessonScoreCreateWithoutUserInput[] | UserLessonScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonScoreCreateOrConnectWithoutUserInput | UserLessonScoreCreateOrConnectWithoutUserInput[]
    upsert?: UserLessonScoreUpsertWithWhereUniqueWithoutUserInput | UserLessonScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLessonScoreCreateManyUserInputEnvelope
    set?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    disconnect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    delete?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    connect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    update?: UserLessonScoreUpdateWithWhereUniqueWithoutUserInput | UserLessonScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLessonScoreUpdateManyWithWhereWithoutUserInput | UserLessonScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLessonScoreScalarWhereInput | UserLessonScoreScalarWhereInput[]
  }

  export type UserCourseProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput> | UserCourseProgressCreateWithoutUserInput[] | UserCourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutUserInput | UserCourseProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseProgressUpsertWithWhereUniqueWithoutUserInput | UserCourseProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseProgressCreateManyUserInputEnvelope
    set?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    disconnect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    delete?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    update?: UserCourseProgressUpdateWithWhereUniqueWithoutUserInput | UserCourseProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseProgressUpdateManyWithWhereWithoutUserInput | UserCourseProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
  }

  export type OTPUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput> | OTPCreateWithoutUserInput[] | OTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCreateOrConnectWithoutUserInput | OTPCreateOrConnectWithoutUserInput[]
    upsert?: OTPUpsertWithWhereUniqueWithoutUserInput | OTPUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OTPCreateManyUserInputEnvelope
    set?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    disconnect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    delete?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    connect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    update?: OTPUpdateWithWhereUniqueWithoutUserInput | OTPUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OTPUpdateManyWithWhereWithoutUserInput | OTPUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OTPScalarWhereInput | OTPScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput> | UserLessonProgressCreateWithoutUserInput[] | UserLessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutUserInput | UserLessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserLessonProgressUpsertWithWhereUniqueWithoutUserInput | UserLessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLessonProgressCreateManyUserInputEnvelope
    set?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    disconnect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    delete?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    update?: UserLessonProgressUpdateWithWhereUniqueWithoutUserInput | UserLessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLessonProgressUpdateManyWithWhereWithoutUserInput | UserLessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
  }

  export type ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput> | ChallengeScoreCreateWithoutUserInput[] | ChallengeScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutUserInput | ChallengeScoreCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeScoreUpsertWithWhereUniqueWithoutUserInput | ChallengeScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeScoreCreateManyUserInputEnvelope
    set?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    disconnect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    delete?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    update?: ChallengeScoreUpdateWithWhereUniqueWithoutUserInput | ChallengeScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeScoreUpdateManyWithWhereWithoutUserInput | ChallengeScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
  }

  export type UserLessonScoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLessonScoreCreateWithoutUserInput, UserLessonScoreUncheckedCreateWithoutUserInput> | UserLessonScoreCreateWithoutUserInput[] | UserLessonScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonScoreCreateOrConnectWithoutUserInput | UserLessonScoreCreateOrConnectWithoutUserInput[]
    upsert?: UserLessonScoreUpsertWithWhereUniqueWithoutUserInput | UserLessonScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLessonScoreCreateManyUserInputEnvelope
    set?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    disconnect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    delete?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    connect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    update?: UserLessonScoreUpdateWithWhereUniqueWithoutUserInput | UserLessonScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLessonScoreUpdateManyWithWhereWithoutUserInput | UserLessonScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLessonScoreScalarWhereInput | UserLessonScoreScalarWhereInput[]
  }

  export type UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput> | UserCourseProgressCreateWithoutUserInput[] | UserCourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutUserInput | UserCourseProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseProgressUpsertWithWhereUniqueWithoutUserInput | UserCourseProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseProgressCreateManyUserInputEnvelope
    set?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    disconnect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    delete?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    update?: UserCourseProgressUpdateWithWhereUniqueWithoutUserInput | UserCourseProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseProgressUpdateManyWithWhereWithoutUserInput | UserCourseProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOtpsInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOtpsNestedInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    upsert?: UserUpsertWithoutOtpsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpsInput, UserUpdateWithoutOtpsInput>, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type EnumCategoryStatusFieldUpdateOperationsInput = {
    set?: $Enums.CategoryStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutProductInput = {
    create?: XOR<EnrollmentCreateWithoutProductInput, EnrollmentUncheckedCreateWithoutProductInput> | EnrollmentCreateWithoutProductInput[] | EnrollmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutProductInput | EnrollmentCreateOrConnectWithoutProductInput[]
    createMany?: EnrollmentCreateManyProductInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserCourseProgressCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput> | UserCourseProgressCreateWithoutCourseInput[] | UserCourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutCourseInput | UserCourseProgressCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseProgressCreateManyCourseInputEnvelope
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<EnrollmentCreateWithoutProductInput, EnrollmentUncheckedCreateWithoutProductInput> | EnrollmentCreateWithoutProductInput[] | EnrollmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutProductInput | EnrollmentCreateOrConnectWithoutProductInput[]
    createMany?: EnrollmentCreateManyProductInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput> | UserCourseProgressCreateWithoutCourseInput[] | UserCourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutCourseInput | UserCourseProgressCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseProgressCreateManyCourseInputEnvelope
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
  }

  export type EnumProductLabelFieldUpdateOperationsInput = {
    set?: $Enums.ProductLabel
  }

  export type EnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutProductNestedInput = {
    create?: XOR<EnrollmentCreateWithoutProductInput, EnrollmentUncheckedCreateWithoutProductInput> | EnrollmentCreateWithoutProductInput[] | EnrollmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutProductInput | EnrollmentCreateOrConnectWithoutProductInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutProductInput | EnrollmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: EnrollmentCreateManyProductInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutProductInput | EnrollmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutProductInput | EnrollmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCourseProgressUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput> | UserCourseProgressCreateWithoutCourseInput[] | UserCourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutCourseInput | UserCourseProgressCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput | UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseProgressCreateManyCourseInputEnvelope
    set?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    disconnect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    delete?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    update?: UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput | UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseProgressUpdateManyWithWhereWithoutCourseInput | UserCourseProgressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<EnrollmentCreateWithoutProductInput, EnrollmentUncheckedCreateWithoutProductInput> | EnrollmentCreateWithoutProductInput[] | EnrollmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutProductInput | EnrollmentCreateOrConnectWithoutProductInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutProductInput | EnrollmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: EnrollmentCreateManyProductInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutProductInput | EnrollmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutProductInput | EnrollmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput> | UserCourseProgressCreateWithoutCourseInput[] | UserCourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutCourseInput | UserCourseProgressCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput | UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseProgressCreateManyCourseInputEnvelope
    set?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    disconnect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    delete?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    update?: UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput | UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseProgressUpdateManyWithWhereWithoutCourseInput | UserCourseProgressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutModulesInput = {
    create?: XOR<ProductCreateWithoutModulesInput, ProductUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutModulesInput
    connect?: ProductWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumModuleStatusFieldUpdateOperationsInput = {
    set?: $Enums.ModuleStatus
  }

  export type ProductUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ProductCreateWithoutModulesInput, ProductUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutModulesInput
    upsert?: ProductUpsertWithoutModulesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutModulesInput, ProductUpdateWithoutModulesInput>, ProductUncheckedUpdateWithoutModulesInput>
  }

  export type LessonUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type ModuleCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLessonsInput
    connect?: ModuleWhereUniqueInput
  }

  export type QuizQuestionCreateNestedManyWithoutLessonInput = {
    create?: XOR<QuizQuestionCreateWithoutLessonInput, QuizQuestionUncheckedCreateWithoutLessonInput> | QuizQuestionCreateWithoutLessonInput[] | QuizQuestionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutLessonInput | QuizQuestionCreateOrConnectWithoutLessonInput[]
    createMany?: QuizQuestionCreateManyLessonInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type UserLessonProgressCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput> | UserLessonProgressCreateWithoutLessonInput[] | UserLessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutLessonInput | UserLessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: UserLessonProgressCreateManyLessonInputEnvelope
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
  }

  export type UserLessonScoreCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserLessonScoreCreateWithoutLessonInput, UserLessonScoreUncheckedCreateWithoutLessonInput> | UserLessonScoreCreateWithoutLessonInput[] | UserLessonScoreUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonScoreCreateOrConnectWithoutLessonInput | UserLessonScoreCreateOrConnectWithoutLessonInput[]
    createMany?: UserLessonScoreCreateManyLessonInputEnvelope
    connect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<QuizQuestionCreateWithoutLessonInput, QuizQuestionUncheckedCreateWithoutLessonInput> | QuizQuestionCreateWithoutLessonInput[] | QuizQuestionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutLessonInput | QuizQuestionCreateOrConnectWithoutLessonInput[]
    createMany?: QuizQuestionCreateManyLessonInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type UserLessonProgressUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput> | UserLessonProgressCreateWithoutLessonInput[] | UserLessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutLessonInput | UserLessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: UserLessonProgressCreateManyLessonInputEnvelope
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
  }

  export type UserLessonScoreUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserLessonScoreCreateWithoutLessonInput, UserLessonScoreUncheckedCreateWithoutLessonInput> | UserLessonScoreCreateWithoutLessonInput[] | UserLessonScoreUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonScoreCreateOrConnectWithoutLessonInput | UserLessonScoreCreateOrConnectWithoutLessonInput[]
    createMany?: UserLessonScoreCreateManyLessonInputEnvelope
    connect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
  }

  export type EnumLessonTypeFieldUpdateOperationsInput = {
    set?: $Enums.LessonType
  }

  export type EnumLessonStatusFieldUpdateOperationsInput = {
    set?: $Enums.LessonStatus
  }

  export type ModuleUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLessonsInput
    upsert?: ModuleUpsertWithoutLessonsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutLessonsInput, ModuleUpdateWithoutLessonsInput>, ModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type QuizQuestionUpdateManyWithoutLessonNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutLessonInput, QuizQuestionUncheckedCreateWithoutLessonInput> | QuizQuestionCreateWithoutLessonInput[] | QuizQuestionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutLessonInput | QuizQuestionCreateOrConnectWithoutLessonInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutLessonInput | QuizQuestionUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: QuizQuestionCreateManyLessonInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutLessonInput | QuizQuestionUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutLessonInput | QuizQuestionUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type UserLessonProgressUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput> | UserLessonProgressCreateWithoutLessonInput[] | UserLessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutLessonInput | UserLessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput | UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: UserLessonProgressCreateManyLessonInputEnvelope
    set?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    disconnect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    delete?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    update?: UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput | UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserLessonProgressUpdateManyWithWhereWithoutLessonInput | UserLessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
  }

  export type UserLessonScoreUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserLessonScoreCreateWithoutLessonInput, UserLessonScoreUncheckedCreateWithoutLessonInput> | UserLessonScoreCreateWithoutLessonInput[] | UserLessonScoreUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonScoreCreateOrConnectWithoutLessonInput | UserLessonScoreCreateOrConnectWithoutLessonInput[]
    upsert?: UserLessonScoreUpsertWithWhereUniqueWithoutLessonInput | UserLessonScoreUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: UserLessonScoreCreateManyLessonInputEnvelope
    set?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    disconnect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    delete?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    connect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    update?: UserLessonScoreUpdateWithWhereUniqueWithoutLessonInput | UserLessonScoreUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserLessonScoreUpdateManyWithWhereWithoutLessonInput | UserLessonScoreUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserLessonScoreScalarWhereInput | UserLessonScoreScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutLessonInput, QuizQuestionUncheckedCreateWithoutLessonInput> | QuizQuestionCreateWithoutLessonInput[] | QuizQuestionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutLessonInput | QuizQuestionCreateOrConnectWithoutLessonInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutLessonInput | QuizQuestionUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: QuizQuestionCreateManyLessonInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutLessonInput | QuizQuestionUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutLessonInput | QuizQuestionUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type UserLessonProgressUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput> | UserLessonProgressCreateWithoutLessonInput[] | UserLessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutLessonInput | UserLessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput | UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: UserLessonProgressCreateManyLessonInputEnvelope
    set?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    disconnect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    delete?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    update?: UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput | UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserLessonProgressUpdateManyWithWhereWithoutLessonInput | UserLessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
  }

  export type UserLessonScoreUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserLessonScoreCreateWithoutLessonInput, UserLessonScoreUncheckedCreateWithoutLessonInput> | UserLessonScoreCreateWithoutLessonInput[] | UserLessonScoreUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonScoreCreateOrConnectWithoutLessonInput | UserLessonScoreCreateOrConnectWithoutLessonInput[]
    upsert?: UserLessonScoreUpsertWithWhereUniqueWithoutLessonInput | UserLessonScoreUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: UserLessonScoreCreateManyLessonInputEnvelope
    set?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    disconnect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    delete?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    connect?: UserLessonScoreWhereUniqueInput | UserLessonScoreWhereUniqueInput[]
    update?: UserLessonScoreUpdateWithWhereUniqueWithoutLessonInput | UserLessonScoreUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserLessonScoreUpdateManyWithWhereWithoutLessonInput | UserLessonScoreUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserLessonScoreScalarWhereInput | UserLessonScoreScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<ProductCreateWithoutEnrollmentsInput, ProductUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutEnrollmentsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<ProductCreateWithoutEnrollmentsInput, ProductUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutEnrollmentsInput
    upsert?: ProductUpsertWithoutEnrollmentsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutEnrollmentsInput, ProductUpdateWithoutEnrollmentsInput>, ProductUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    upsert?: UserUpsertWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentsInput, UserUpdateWithoutEnrollmentsInput>, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    upsert?: ProductUpsertWithoutReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReviewsInput, ProductUpdateWithoutReviewsInput>, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type LessonCreateNestedOneWithoutQuestionInput = {
    create?: XOR<LessonCreateWithoutQuestionInput, LessonUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuestionInput
    connect?: LessonWhereUniqueInput
  }

  export type QuizAnswerCreateNestedManyWithoutQuiz_questionInput = {
    create?: XOR<QuizAnswerCreateWithoutQuiz_questionInput, QuizAnswerUncheckedCreateWithoutQuiz_questionInput> | QuizAnswerCreateWithoutQuiz_questionInput[] | QuizAnswerUncheckedCreateWithoutQuiz_questionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuiz_questionInput | QuizAnswerCreateOrConnectWithoutQuiz_questionInput[]
    createMany?: QuizAnswerCreateManyQuiz_questionInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizAnswerUncheckedCreateNestedManyWithoutQuiz_questionInput = {
    create?: XOR<QuizAnswerCreateWithoutQuiz_questionInput, QuizAnswerUncheckedCreateWithoutQuiz_questionInput> | QuizAnswerCreateWithoutQuiz_questionInput[] | QuizAnswerUncheckedCreateWithoutQuiz_questionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuiz_questionInput | QuizAnswerCreateOrConnectWithoutQuiz_questionInput[]
    createMany?: QuizAnswerCreateManyQuiz_questionInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type LessonUpdateOneRequiredWithoutQuestionNestedInput = {
    create?: XOR<LessonCreateWithoutQuestionInput, LessonUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuestionInput
    upsert?: LessonUpsertWithoutQuestionInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutQuestionInput, LessonUpdateWithoutQuestionInput>, LessonUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizAnswerUpdateManyWithoutQuiz_questionNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutQuiz_questionInput, QuizAnswerUncheckedCreateWithoutQuiz_questionInput> | QuizAnswerCreateWithoutQuiz_questionInput[] | QuizAnswerUncheckedCreateWithoutQuiz_questionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuiz_questionInput | QuizAnswerCreateOrConnectWithoutQuiz_questionInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutQuiz_questionInput | QuizAnswerUpsertWithWhereUniqueWithoutQuiz_questionInput[]
    createMany?: QuizAnswerCreateManyQuiz_questionInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutQuiz_questionInput | QuizAnswerUpdateWithWhereUniqueWithoutQuiz_questionInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutQuiz_questionInput | QuizAnswerUpdateManyWithWhereWithoutQuiz_questionInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizAnswerUncheckedUpdateManyWithoutQuiz_questionNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutQuiz_questionInput, QuizAnswerUncheckedCreateWithoutQuiz_questionInput> | QuizAnswerCreateWithoutQuiz_questionInput[] | QuizAnswerUncheckedCreateWithoutQuiz_questionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuiz_questionInput | QuizAnswerCreateOrConnectWithoutQuiz_questionInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutQuiz_questionInput | QuizAnswerUpsertWithWhereUniqueWithoutQuiz_questionInput[]
    createMany?: QuizAnswerCreateManyQuiz_questionInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutQuiz_questionInput | QuizAnswerUpdateWithWhereUniqueWithoutQuiz_questionInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutQuiz_questionInput | QuizAnswerUpdateManyWithWhereWithoutQuiz_questionInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswersInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuizQuestionUpsertWithoutAnswersInput
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<XOR<QuizQuestionUpdateToOneWithWhereWithoutAnswersInput, QuizQuestionUpdateWithoutAnswersInput>, QuizQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type ChallengeQuestionCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeQuestionCreateWithoutChallengeInput, ChallengeQuestionUncheckedCreateWithoutChallengeInput> | ChallengeQuestionCreateWithoutChallengeInput[] | ChallengeQuestionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeQuestionCreateOrConnectWithoutChallengeInput | ChallengeQuestionCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeQuestionCreateManyChallengeInputEnvelope
    connect?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
  }

  export type ChallengeScoreCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeScoreCreateWithoutChallengeInput, ChallengeScoreUncheckedCreateWithoutChallengeInput> | ChallengeScoreCreateWithoutChallengeInput[] | ChallengeScoreUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutChallengeInput | ChallengeScoreCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeScoreCreateManyChallengeInputEnvelope
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
  }

  export type PuzzleChallengeCreateNestedOneWithoutChallengeInput = {
    create?: XOR<PuzzleChallengeCreateWithoutChallengeInput, PuzzleChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: PuzzleChallengeCreateOrConnectWithoutChallengeInput
    connect?: PuzzleChallengeWhereUniqueInput
  }

  export type OrderingChallengeCreateNestedOneWithoutChallengeInput = {
    create?: XOR<OrderingChallengeCreateWithoutChallengeInput, OrderingChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: OrderingChallengeCreateOrConnectWithoutChallengeInput
    connect?: OrderingChallengeWhereUniqueInput
  }

  export type FillBlankChallengeCreateNestedOneWithoutChallengeInput = {
    create?: XOR<FillBlankChallengeCreateWithoutChallengeInput, FillBlankChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: FillBlankChallengeCreateOrConnectWithoutChallengeInput
    connect?: FillBlankChallengeWhereUniqueInput
  }

  export type ChallengeQuestionUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeQuestionCreateWithoutChallengeInput, ChallengeQuestionUncheckedCreateWithoutChallengeInput> | ChallengeQuestionCreateWithoutChallengeInput[] | ChallengeQuestionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeQuestionCreateOrConnectWithoutChallengeInput | ChallengeQuestionCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeQuestionCreateManyChallengeInputEnvelope
    connect?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
  }

  export type ChallengeScoreUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeScoreCreateWithoutChallengeInput, ChallengeScoreUncheckedCreateWithoutChallengeInput> | ChallengeScoreCreateWithoutChallengeInput[] | ChallengeScoreUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutChallengeInput | ChallengeScoreCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeScoreCreateManyChallengeInputEnvelope
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
  }

  export type PuzzleChallengeUncheckedCreateNestedOneWithoutChallengeInput = {
    create?: XOR<PuzzleChallengeCreateWithoutChallengeInput, PuzzleChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: PuzzleChallengeCreateOrConnectWithoutChallengeInput
    connect?: PuzzleChallengeWhereUniqueInput
  }

  export type OrderingChallengeUncheckedCreateNestedOneWithoutChallengeInput = {
    create?: XOR<OrderingChallengeCreateWithoutChallengeInput, OrderingChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: OrderingChallengeCreateOrConnectWithoutChallengeInput
    connect?: OrderingChallengeWhereUniqueInput
  }

  export type FillBlankChallengeUncheckedCreateNestedOneWithoutChallengeInput = {
    create?: XOR<FillBlankChallengeCreateWithoutChallengeInput, FillBlankChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: FillBlankChallengeCreateOrConnectWithoutChallengeInput
    connect?: FillBlankChallengeWhereUniqueInput
  }

  export type EnumChallengeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeType
  }

  export type EnumChallengeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeStatus
  }

  export type ChallengeQuestionUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeQuestionCreateWithoutChallengeInput, ChallengeQuestionUncheckedCreateWithoutChallengeInput> | ChallengeQuestionCreateWithoutChallengeInput[] | ChallengeQuestionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeQuestionCreateOrConnectWithoutChallengeInput | ChallengeQuestionCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeQuestionUpsertWithWhereUniqueWithoutChallengeInput | ChallengeQuestionUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeQuestionCreateManyChallengeInputEnvelope
    set?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
    disconnect?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
    delete?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
    connect?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
    update?: ChallengeQuestionUpdateWithWhereUniqueWithoutChallengeInput | ChallengeQuestionUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeQuestionUpdateManyWithWhereWithoutChallengeInput | ChallengeQuestionUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeQuestionScalarWhereInput | ChallengeQuestionScalarWhereInput[]
  }

  export type ChallengeScoreUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeScoreCreateWithoutChallengeInput, ChallengeScoreUncheckedCreateWithoutChallengeInput> | ChallengeScoreCreateWithoutChallengeInput[] | ChallengeScoreUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutChallengeInput | ChallengeScoreCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeScoreUpsertWithWhereUniqueWithoutChallengeInput | ChallengeScoreUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeScoreCreateManyChallengeInputEnvelope
    set?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    disconnect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    delete?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    update?: ChallengeScoreUpdateWithWhereUniqueWithoutChallengeInput | ChallengeScoreUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeScoreUpdateManyWithWhereWithoutChallengeInput | ChallengeScoreUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
  }

  export type PuzzleChallengeUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<PuzzleChallengeCreateWithoutChallengeInput, PuzzleChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: PuzzleChallengeCreateOrConnectWithoutChallengeInput
    upsert?: PuzzleChallengeUpsertWithoutChallengeInput
    disconnect?: PuzzleChallengeWhereInput | boolean
    delete?: PuzzleChallengeWhereInput | boolean
    connect?: PuzzleChallengeWhereUniqueInput
    update?: XOR<XOR<PuzzleChallengeUpdateToOneWithWhereWithoutChallengeInput, PuzzleChallengeUpdateWithoutChallengeInput>, PuzzleChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type OrderingChallengeUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<OrderingChallengeCreateWithoutChallengeInput, OrderingChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: OrderingChallengeCreateOrConnectWithoutChallengeInput
    upsert?: OrderingChallengeUpsertWithoutChallengeInput
    disconnect?: OrderingChallengeWhereInput | boolean
    delete?: OrderingChallengeWhereInput | boolean
    connect?: OrderingChallengeWhereUniqueInput
    update?: XOR<XOR<OrderingChallengeUpdateToOneWithWhereWithoutChallengeInput, OrderingChallengeUpdateWithoutChallengeInput>, OrderingChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type FillBlankChallengeUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<FillBlankChallengeCreateWithoutChallengeInput, FillBlankChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: FillBlankChallengeCreateOrConnectWithoutChallengeInput
    upsert?: FillBlankChallengeUpsertWithoutChallengeInput
    disconnect?: FillBlankChallengeWhereInput | boolean
    delete?: FillBlankChallengeWhereInput | boolean
    connect?: FillBlankChallengeWhereUniqueInput
    update?: XOR<XOR<FillBlankChallengeUpdateToOneWithWhereWithoutChallengeInput, FillBlankChallengeUpdateWithoutChallengeInput>, FillBlankChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeQuestionUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeQuestionCreateWithoutChallengeInput, ChallengeQuestionUncheckedCreateWithoutChallengeInput> | ChallengeQuestionCreateWithoutChallengeInput[] | ChallengeQuestionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeQuestionCreateOrConnectWithoutChallengeInput | ChallengeQuestionCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeQuestionUpsertWithWhereUniqueWithoutChallengeInput | ChallengeQuestionUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeQuestionCreateManyChallengeInputEnvelope
    set?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
    disconnect?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
    delete?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
    connect?: ChallengeQuestionWhereUniqueInput | ChallengeQuestionWhereUniqueInput[]
    update?: ChallengeQuestionUpdateWithWhereUniqueWithoutChallengeInput | ChallengeQuestionUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeQuestionUpdateManyWithWhereWithoutChallengeInput | ChallengeQuestionUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeQuestionScalarWhereInput | ChallengeQuestionScalarWhereInput[]
  }

  export type ChallengeScoreUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeScoreCreateWithoutChallengeInput, ChallengeScoreUncheckedCreateWithoutChallengeInput> | ChallengeScoreCreateWithoutChallengeInput[] | ChallengeScoreUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutChallengeInput | ChallengeScoreCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeScoreUpsertWithWhereUniqueWithoutChallengeInput | ChallengeScoreUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeScoreCreateManyChallengeInputEnvelope
    set?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    disconnect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    delete?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    update?: ChallengeScoreUpdateWithWhereUniqueWithoutChallengeInput | ChallengeScoreUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeScoreUpdateManyWithWhereWithoutChallengeInput | ChallengeScoreUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
  }

  export type PuzzleChallengeUncheckedUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<PuzzleChallengeCreateWithoutChallengeInput, PuzzleChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: PuzzleChallengeCreateOrConnectWithoutChallengeInput
    upsert?: PuzzleChallengeUpsertWithoutChallengeInput
    disconnect?: PuzzleChallengeWhereInput | boolean
    delete?: PuzzleChallengeWhereInput | boolean
    connect?: PuzzleChallengeWhereUniqueInput
    update?: XOR<XOR<PuzzleChallengeUpdateToOneWithWhereWithoutChallengeInput, PuzzleChallengeUpdateWithoutChallengeInput>, PuzzleChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type OrderingChallengeUncheckedUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<OrderingChallengeCreateWithoutChallengeInput, OrderingChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: OrderingChallengeCreateOrConnectWithoutChallengeInput
    upsert?: OrderingChallengeUpsertWithoutChallengeInput
    disconnect?: OrderingChallengeWhereInput | boolean
    delete?: OrderingChallengeWhereInput | boolean
    connect?: OrderingChallengeWhereUniqueInput
    update?: XOR<XOR<OrderingChallengeUpdateToOneWithWhereWithoutChallengeInput, OrderingChallengeUpdateWithoutChallengeInput>, OrderingChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type FillBlankChallengeUncheckedUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<FillBlankChallengeCreateWithoutChallengeInput, FillBlankChallengeUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: FillBlankChallengeCreateOrConnectWithoutChallengeInput
    upsert?: FillBlankChallengeUpsertWithoutChallengeInput
    disconnect?: FillBlankChallengeWhereInput | boolean
    delete?: FillBlankChallengeWhereInput | boolean
    connect?: FillBlankChallengeWhereUniqueInput
    update?: XOR<XOR<FillBlankChallengeUpdateToOneWithWhereWithoutChallengeInput, FillBlankChallengeUpdateWithoutChallengeInput>, FillBlankChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ChallengeCreateWithoutQuestionsInput, ChallengeUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutQuestionsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeAnswerCreateNestedManyWithoutChallenge_questionInput = {
    create?: XOR<ChallengeAnswerCreateWithoutChallenge_questionInput, ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput> | ChallengeAnswerCreateWithoutChallenge_questionInput[] | ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput[]
    connectOrCreate?: ChallengeAnswerCreateOrConnectWithoutChallenge_questionInput | ChallengeAnswerCreateOrConnectWithoutChallenge_questionInput[]
    createMany?: ChallengeAnswerCreateManyChallenge_questionInputEnvelope
    connect?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
  }

  export type ChallengeAnswerUncheckedCreateNestedManyWithoutChallenge_questionInput = {
    create?: XOR<ChallengeAnswerCreateWithoutChallenge_questionInput, ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput> | ChallengeAnswerCreateWithoutChallenge_questionInput[] | ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput[]
    connectOrCreate?: ChallengeAnswerCreateOrConnectWithoutChallenge_questionInput | ChallengeAnswerCreateOrConnectWithoutChallenge_questionInput[]
    createMany?: ChallengeAnswerCreateManyChallenge_questionInputEnvelope
    connect?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
  }

  export type ChallengeUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<ChallengeCreateWithoutQuestionsInput, ChallengeUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutQuestionsInput
    upsert?: ChallengeUpsertWithoutQuestionsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutQuestionsInput, ChallengeUpdateWithoutQuestionsInput>, ChallengeUncheckedUpdateWithoutQuestionsInput>
  }

  export type ChallengeAnswerUpdateManyWithoutChallenge_questionNestedInput = {
    create?: XOR<ChallengeAnswerCreateWithoutChallenge_questionInput, ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput> | ChallengeAnswerCreateWithoutChallenge_questionInput[] | ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput[]
    connectOrCreate?: ChallengeAnswerCreateOrConnectWithoutChallenge_questionInput | ChallengeAnswerCreateOrConnectWithoutChallenge_questionInput[]
    upsert?: ChallengeAnswerUpsertWithWhereUniqueWithoutChallenge_questionInput | ChallengeAnswerUpsertWithWhereUniqueWithoutChallenge_questionInput[]
    createMany?: ChallengeAnswerCreateManyChallenge_questionInputEnvelope
    set?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
    disconnect?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
    delete?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
    connect?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
    update?: ChallengeAnswerUpdateWithWhereUniqueWithoutChallenge_questionInput | ChallengeAnswerUpdateWithWhereUniqueWithoutChallenge_questionInput[]
    updateMany?: ChallengeAnswerUpdateManyWithWhereWithoutChallenge_questionInput | ChallengeAnswerUpdateManyWithWhereWithoutChallenge_questionInput[]
    deleteMany?: ChallengeAnswerScalarWhereInput | ChallengeAnswerScalarWhereInput[]
  }

  export type ChallengeAnswerUncheckedUpdateManyWithoutChallenge_questionNestedInput = {
    create?: XOR<ChallengeAnswerCreateWithoutChallenge_questionInput, ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput> | ChallengeAnswerCreateWithoutChallenge_questionInput[] | ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput[]
    connectOrCreate?: ChallengeAnswerCreateOrConnectWithoutChallenge_questionInput | ChallengeAnswerCreateOrConnectWithoutChallenge_questionInput[]
    upsert?: ChallengeAnswerUpsertWithWhereUniqueWithoutChallenge_questionInput | ChallengeAnswerUpsertWithWhereUniqueWithoutChallenge_questionInput[]
    createMany?: ChallengeAnswerCreateManyChallenge_questionInputEnvelope
    set?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
    disconnect?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
    delete?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
    connect?: ChallengeAnswerWhereUniqueInput | ChallengeAnswerWhereUniqueInput[]
    update?: ChallengeAnswerUpdateWithWhereUniqueWithoutChallenge_questionInput | ChallengeAnswerUpdateWithWhereUniqueWithoutChallenge_questionInput[]
    updateMany?: ChallengeAnswerUpdateManyWithWhereWithoutChallenge_questionInput | ChallengeAnswerUpdateManyWithWhereWithoutChallenge_questionInput[]
    deleteMany?: ChallengeAnswerScalarWhereInput | ChallengeAnswerScalarWhereInput[]
  }

  export type ChallengeQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<ChallengeQuestionCreateWithoutAnswersInput, ChallengeQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ChallengeQuestionCreateOrConnectWithoutAnswersInput
    connect?: ChallengeQuestionWhereUniqueInput
  }

  export type ChallengeQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<ChallengeQuestionCreateWithoutAnswersInput, ChallengeQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ChallengeQuestionCreateOrConnectWithoutAnswersInput
    upsert?: ChallengeQuestionUpsertWithoutAnswersInput
    connect?: ChallengeQuestionWhereUniqueInput
    update?: XOR<XOR<ChallengeQuestionUpdateToOneWithWhereWithoutAnswersInput, ChallengeQuestionUpdateWithoutAnswersInput>, ChallengeQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type ChallengeCreateNestedOneWithoutPuzzleChallengeInput = {
    create?: XOR<ChallengeCreateWithoutPuzzleChallengeInput, ChallengeUncheckedCreateWithoutPuzzleChallengeInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutPuzzleChallengeInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutPuzzleChallengeNestedInput = {
    create?: XOR<ChallengeCreateWithoutPuzzleChallengeInput, ChallengeUncheckedCreateWithoutPuzzleChallengeInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutPuzzleChallengeInput
    upsert?: ChallengeUpsertWithoutPuzzleChallengeInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutPuzzleChallengeInput, ChallengeUpdateWithoutPuzzleChallengeInput>, ChallengeUncheckedUpdateWithoutPuzzleChallengeInput>
  }

  export type ChallengeCreateNestedOneWithoutOrderingChallengeInput = {
    create?: XOR<ChallengeCreateWithoutOrderingChallengeInput, ChallengeUncheckedCreateWithoutOrderingChallengeInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutOrderingChallengeInput
    connect?: ChallengeWhereUniqueInput
  }

  export type OrderingItemCreateNestedManyWithoutOrderingChallengeInput = {
    create?: XOR<OrderingItemCreateWithoutOrderingChallengeInput, OrderingItemUncheckedCreateWithoutOrderingChallengeInput> | OrderingItemCreateWithoutOrderingChallengeInput[] | OrderingItemUncheckedCreateWithoutOrderingChallengeInput[]
    connectOrCreate?: OrderingItemCreateOrConnectWithoutOrderingChallengeInput | OrderingItemCreateOrConnectWithoutOrderingChallengeInput[]
    createMany?: OrderingItemCreateManyOrderingChallengeInputEnvelope
    connect?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
  }

  export type OrderingItemUncheckedCreateNestedManyWithoutOrderingChallengeInput = {
    create?: XOR<OrderingItemCreateWithoutOrderingChallengeInput, OrderingItemUncheckedCreateWithoutOrderingChallengeInput> | OrderingItemCreateWithoutOrderingChallengeInput[] | OrderingItemUncheckedCreateWithoutOrderingChallengeInput[]
    connectOrCreate?: OrderingItemCreateOrConnectWithoutOrderingChallengeInput | OrderingItemCreateOrConnectWithoutOrderingChallengeInput[]
    createMany?: OrderingItemCreateManyOrderingChallengeInputEnvelope
    connect?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
  }

  export type ChallengeUpdateOneRequiredWithoutOrderingChallengeNestedInput = {
    create?: XOR<ChallengeCreateWithoutOrderingChallengeInput, ChallengeUncheckedCreateWithoutOrderingChallengeInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutOrderingChallengeInput
    upsert?: ChallengeUpsertWithoutOrderingChallengeInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutOrderingChallengeInput, ChallengeUpdateWithoutOrderingChallengeInput>, ChallengeUncheckedUpdateWithoutOrderingChallengeInput>
  }

  export type OrderingItemUpdateManyWithoutOrderingChallengeNestedInput = {
    create?: XOR<OrderingItemCreateWithoutOrderingChallengeInput, OrderingItemUncheckedCreateWithoutOrderingChallengeInput> | OrderingItemCreateWithoutOrderingChallengeInput[] | OrderingItemUncheckedCreateWithoutOrderingChallengeInput[]
    connectOrCreate?: OrderingItemCreateOrConnectWithoutOrderingChallengeInput | OrderingItemCreateOrConnectWithoutOrderingChallengeInput[]
    upsert?: OrderingItemUpsertWithWhereUniqueWithoutOrderingChallengeInput | OrderingItemUpsertWithWhereUniqueWithoutOrderingChallengeInput[]
    createMany?: OrderingItemCreateManyOrderingChallengeInputEnvelope
    set?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
    disconnect?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
    delete?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
    connect?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
    update?: OrderingItemUpdateWithWhereUniqueWithoutOrderingChallengeInput | OrderingItemUpdateWithWhereUniqueWithoutOrderingChallengeInput[]
    updateMany?: OrderingItemUpdateManyWithWhereWithoutOrderingChallengeInput | OrderingItemUpdateManyWithWhereWithoutOrderingChallengeInput[]
    deleteMany?: OrderingItemScalarWhereInput | OrderingItemScalarWhereInput[]
  }

  export type OrderingItemUncheckedUpdateManyWithoutOrderingChallengeNestedInput = {
    create?: XOR<OrderingItemCreateWithoutOrderingChallengeInput, OrderingItemUncheckedCreateWithoutOrderingChallengeInput> | OrderingItemCreateWithoutOrderingChallengeInput[] | OrderingItemUncheckedCreateWithoutOrderingChallengeInput[]
    connectOrCreate?: OrderingItemCreateOrConnectWithoutOrderingChallengeInput | OrderingItemCreateOrConnectWithoutOrderingChallengeInput[]
    upsert?: OrderingItemUpsertWithWhereUniqueWithoutOrderingChallengeInput | OrderingItemUpsertWithWhereUniqueWithoutOrderingChallengeInput[]
    createMany?: OrderingItemCreateManyOrderingChallengeInputEnvelope
    set?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
    disconnect?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
    delete?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
    connect?: OrderingItemWhereUniqueInput | OrderingItemWhereUniqueInput[]
    update?: OrderingItemUpdateWithWhereUniqueWithoutOrderingChallengeInput | OrderingItemUpdateWithWhereUniqueWithoutOrderingChallengeInput[]
    updateMany?: OrderingItemUpdateManyWithWhereWithoutOrderingChallengeInput | OrderingItemUpdateManyWithWhereWithoutOrderingChallengeInput[]
    deleteMany?: OrderingItemScalarWhereInput | OrderingItemScalarWhereInput[]
  }

  export type OrderingChallengeCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderingChallengeCreateWithoutItemsInput, OrderingChallengeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderingChallengeCreateOrConnectWithoutItemsInput
    connect?: OrderingChallengeWhereUniqueInput
  }

  export type OrderingChallengeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderingChallengeCreateWithoutItemsInput, OrderingChallengeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderingChallengeCreateOrConnectWithoutItemsInput
    upsert?: OrderingChallengeUpsertWithoutItemsInput
    connect?: OrderingChallengeWhereUniqueInput
    update?: XOR<XOR<OrderingChallengeUpdateToOneWithWhereWithoutItemsInput, OrderingChallengeUpdateWithoutItemsInput>, OrderingChallengeUncheckedUpdateWithoutItemsInput>
  }

  export type ChallengeCreateNestedOneWithoutFillBlankChallengeInput = {
    create?: XOR<ChallengeCreateWithoutFillBlankChallengeInput, ChallengeUncheckedCreateWithoutFillBlankChallengeInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutFillBlankChallengeInput
    connect?: ChallengeWhereUniqueInput
  }

  export type FillBlankQuestionCreateNestedManyWithoutChallengeInput = {
    create?: XOR<FillBlankQuestionCreateWithoutChallengeInput, FillBlankQuestionUncheckedCreateWithoutChallengeInput> | FillBlankQuestionCreateWithoutChallengeInput[] | FillBlankQuestionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: FillBlankQuestionCreateOrConnectWithoutChallengeInput | FillBlankQuestionCreateOrConnectWithoutChallengeInput[]
    createMany?: FillBlankQuestionCreateManyChallengeInputEnvelope
    connect?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
  }

  export type FillBlankQuestionUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<FillBlankQuestionCreateWithoutChallengeInput, FillBlankQuestionUncheckedCreateWithoutChallengeInput> | FillBlankQuestionCreateWithoutChallengeInput[] | FillBlankQuestionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: FillBlankQuestionCreateOrConnectWithoutChallengeInput | FillBlankQuestionCreateOrConnectWithoutChallengeInput[]
    createMany?: FillBlankQuestionCreateManyChallengeInputEnvelope
    connect?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
  }

  export type ChallengeUpdateOneRequiredWithoutFillBlankChallengeNestedInput = {
    create?: XOR<ChallengeCreateWithoutFillBlankChallengeInput, ChallengeUncheckedCreateWithoutFillBlankChallengeInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutFillBlankChallengeInput
    upsert?: ChallengeUpsertWithoutFillBlankChallengeInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutFillBlankChallengeInput, ChallengeUpdateWithoutFillBlankChallengeInput>, ChallengeUncheckedUpdateWithoutFillBlankChallengeInput>
  }

  export type FillBlankQuestionUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<FillBlankQuestionCreateWithoutChallengeInput, FillBlankQuestionUncheckedCreateWithoutChallengeInput> | FillBlankQuestionCreateWithoutChallengeInput[] | FillBlankQuestionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: FillBlankQuestionCreateOrConnectWithoutChallengeInput | FillBlankQuestionCreateOrConnectWithoutChallengeInput[]
    upsert?: FillBlankQuestionUpsertWithWhereUniqueWithoutChallengeInput | FillBlankQuestionUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: FillBlankQuestionCreateManyChallengeInputEnvelope
    set?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
    disconnect?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
    delete?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
    connect?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
    update?: FillBlankQuestionUpdateWithWhereUniqueWithoutChallengeInput | FillBlankQuestionUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: FillBlankQuestionUpdateManyWithWhereWithoutChallengeInput | FillBlankQuestionUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: FillBlankQuestionScalarWhereInput | FillBlankQuestionScalarWhereInput[]
  }

  export type FillBlankQuestionUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<FillBlankQuestionCreateWithoutChallengeInput, FillBlankQuestionUncheckedCreateWithoutChallengeInput> | FillBlankQuestionCreateWithoutChallengeInput[] | FillBlankQuestionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: FillBlankQuestionCreateOrConnectWithoutChallengeInput | FillBlankQuestionCreateOrConnectWithoutChallengeInput[]
    upsert?: FillBlankQuestionUpsertWithWhereUniqueWithoutChallengeInput | FillBlankQuestionUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: FillBlankQuestionCreateManyChallengeInputEnvelope
    set?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
    disconnect?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
    delete?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
    connect?: FillBlankQuestionWhereUniqueInput | FillBlankQuestionWhereUniqueInput[]
    update?: FillBlankQuestionUpdateWithWhereUniqueWithoutChallengeInput | FillBlankQuestionUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: FillBlankQuestionUpdateManyWithWhereWithoutChallengeInput | FillBlankQuestionUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: FillBlankQuestionScalarWhereInput | FillBlankQuestionScalarWhereInput[]
  }

  export type FillBlankChallengeCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<FillBlankChallengeCreateWithoutQuestionsInput, FillBlankChallengeUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: FillBlankChallengeCreateOrConnectWithoutQuestionsInput
    connect?: FillBlankChallengeWhereUniqueInput
  }

  export type FillBlankChallengeUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<FillBlankChallengeCreateWithoutQuestionsInput, FillBlankChallengeUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: FillBlankChallengeCreateOrConnectWithoutQuestionsInput
    upsert?: FillBlankChallengeUpsertWithoutQuestionsInput
    connect?: FillBlankChallengeWhereUniqueInput
    update?: XOR<XOR<FillBlankChallengeUpdateToOneWithWhereWithoutQuestionsInput, FillBlankChallengeUpdateWithoutQuestionsInput>, FillBlankChallengeUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserCreateNestedOneWithoutUserLessonProgressInput = {
    create?: XOR<UserCreateWithoutUserLessonProgressInput, UserUncheckedCreateWithoutUserLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLessonProgressInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<LessonCreateWithoutUserProgressInput, LessonUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutUserProgressInput
    connect?: LessonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserLessonProgressNestedInput = {
    create?: XOR<UserCreateWithoutUserLessonProgressInput, UserUncheckedCreateWithoutUserLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLessonProgressInput
    upsert?: UserUpsertWithoutUserLessonProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserLessonProgressInput, UserUpdateWithoutUserLessonProgressInput>, UserUncheckedUpdateWithoutUserLessonProgressInput>
  }

  export type LessonUpdateOneRequiredWithoutUserProgressNestedInput = {
    create?: XOR<LessonCreateWithoutUserProgressInput, LessonUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutUserProgressInput
    upsert?: LessonUpsertWithoutUserProgressInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutUserProgressInput, LessonUpdateWithoutUserProgressInput>, LessonUncheckedUpdateWithoutUserProgressInput>
  }

  export type UserCreateNestedOneWithoutChallengeScoreInput = {
    create?: XOR<UserCreateWithoutChallengeScoreInput, UserUncheckedCreateWithoutChallengeScoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeScoreInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutChallengeScoreInput = {
    create?: XOR<ChallengeCreateWithoutChallengeScoreInput, ChallengeUncheckedCreateWithoutChallengeScoreInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutChallengeScoreInput
    connect?: ChallengeWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutChallengeScoreNestedInput = {
    create?: XOR<UserCreateWithoutChallengeScoreInput, UserUncheckedCreateWithoutChallengeScoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeScoreInput
    upsert?: UserUpsertWithoutChallengeScoreInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengeScoreInput, UserUpdateWithoutChallengeScoreInput>, UserUncheckedUpdateWithoutChallengeScoreInput>
  }

  export type ChallengeUpdateOneRequiredWithoutChallengeScoreNestedInput = {
    create?: XOR<ChallengeCreateWithoutChallengeScoreInput, ChallengeUncheckedCreateWithoutChallengeScoreInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutChallengeScoreInput
    upsert?: ChallengeUpsertWithoutChallengeScoreInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutChallengeScoreInput, ChallengeUpdateWithoutChallengeScoreInput>, ChallengeUncheckedUpdateWithoutChallengeScoreInput>
  }

  export type UserCreateNestedOneWithoutUserLessonScoreInput = {
    create?: XOR<UserCreateWithoutUserLessonScoreInput, UserUncheckedCreateWithoutUserLessonScoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLessonScoreInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutUserLessonScoreInput = {
    create?: XOR<LessonCreateWithoutUserLessonScoreInput, LessonUncheckedCreateWithoutUserLessonScoreInput>
    connectOrCreate?: LessonCreateOrConnectWithoutUserLessonScoreInput
    connect?: LessonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserLessonScoreNestedInput = {
    create?: XOR<UserCreateWithoutUserLessonScoreInput, UserUncheckedCreateWithoutUserLessonScoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLessonScoreInput
    upsert?: UserUpsertWithoutUserLessonScoreInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserLessonScoreInput, UserUpdateWithoutUserLessonScoreInput>, UserUncheckedUpdateWithoutUserLessonScoreInput>
  }

  export type LessonUpdateOneRequiredWithoutUserLessonScoreNestedInput = {
    create?: XOR<LessonCreateWithoutUserLessonScoreInput, LessonUncheckedCreateWithoutUserLessonScoreInput>
    connectOrCreate?: LessonCreateOrConnectWithoutUserLessonScoreInput
    upsert?: LessonUpsertWithoutUserLessonScoreInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutUserLessonScoreInput, LessonUpdateWithoutUserLessonScoreInput>, LessonUncheckedUpdateWithoutUserLessonScoreInput>
  }

  export type UserCreateNestedOneWithoutUserCourseProgressInput = {
    create?: XOR<UserCreateWithoutUserCourseProgressInput, UserUncheckedCreateWithoutUserCourseProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCourseProgressInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutUserCourseProgressInput = {
    create?: XOR<ProductCreateWithoutUserCourseProgressInput, ProductUncheckedCreateWithoutUserCourseProgressInput>
    connectOrCreate?: ProductCreateOrConnectWithoutUserCourseProgressInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserCourseProgressNestedInput = {
    create?: XOR<UserCreateWithoutUserCourseProgressInput, UserUncheckedCreateWithoutUserCourseProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCourseProgressInput
    upsert?: UserUpsertWithoutUserCourseProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserCourseProgressInput, UserUpdateWithoutUserCourseProgressInput>, UserUncheckedUpdateWithoutUserCourseProgressInput>
  }

  export type ProductUpdateOneRequiredWithoutUserCourseProgressNestedInput = {
    create?: XOR<ProductCreateWithoutUserCourseProgressInput, ProductUncheckedCreateWithoutUserCourseProgressInput>
    connectOrCreate?: ProductCreateOrConnectWithoutUserCourseProgressInput
    upsert?: ProductUpsertWithoutUserCourseProgressInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutUserCourseProgressInput, ProductUpdateWithoutUserCourseProgressInput>, ProductUncheckedUpdateWithoutUserCourseProgressInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGradeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Grade | EnumGradeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Grade[] | ListEnumGradeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Grade[] | ListEnumGradeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGradeNullableFilter<$PrismaModel> | $Enums.Grade | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGradeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Grade | EnumGradeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Grade[] | ListEnumGradeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Grade[] | ListEnumGradeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGradeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Grade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGradeNullableFilter<$PrismaModel>
    _max?: NestedEnumGradeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCategoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryStatus | EnumCategoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryStatus[] | ListEnumCategoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryStatus[] | ListEnumCategoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryStatusFilter<$PrismaModel> | $Enums.CategoryStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumCategoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryStatus | EnumCategoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryStatus[] | ListEnumCategoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryStatus[] | ListEnumCategoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.CategoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryStatusFilter<$PrismaModel>
    _max?: NestedEnumCategoryStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumProductLabelFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductLabel | EnumProductLabelFieldRefInput<$PrismaModel>
    in?: $Enums.ProductLabel[] | ListEnumProductLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductLabel[] | ListEnumProductLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumProductLabelFilter<$PrismaModel> | $Enums.ProductLabel
  }

  export type NestedEnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type NestedEnumProductLabelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductLabel | EnumProductLabelFieldRefInput<$PrismaModel>
    in?: $Enums.ProductLabel[] | ListEnumProductLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductLabel[] | ListEnumProductLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumProductLabelWithAggregatesFilter<$PrismaModel> | $Enums.ProductLabel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductLabelFilter<$PrismaModel>
    _max?: NestedEnumProductLabelFilter<$PrismaModel>
  }

  export type NestedEnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type NestedEnumModuleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModuleStatus | EnumModuleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModuleStatus[] | ListEnumModuleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModuleStatus[] | ListEnumModuleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModuleStatusFilter<$PrismaModel> | $Enums.ModuleStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumModuleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModuleStatus | EnumModuleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModuleStatus[] | ListEnumModuleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModuleStatus[] | ListEnumModuleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModuleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModuleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModuleStatusFilter<$PrismaModel>
    _max?: NestedEnumModuleStatusFilter<$PrismaModel>
  }

  export type NestedEnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type NestedEnumLessonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusFilter<$PrismaModel> | $Enums.LessonStatus
  }

  export type NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type NestedEnumLessonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusWithAggregatesFilter<$PrismaModel> | $Enums.LessonStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonStatusFilter<$PrismaModel>
    _max?: NestedEnumLessonStatusFilter<$PrismaModel>
  }

  export type NestedEnumChallengeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeFilter<$PrismaModel> | $Enums.ChallengeType
  }

  export type NestedEnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus
  }

  export type NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeTypeFilter<$PrismaModel>
    _max?: NestedEnumChallengeTypeFilter<$PrismaModel>
  }

  export type NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type OTPCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    code: string
    isUsed?: boolean
  }

  export type OTPUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    code: string
    isUsed?: boolean
  }

  export type OTPCreateOrConnectWithoutUserInput = {
    where: OTPWhereUniqueInput
    create: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput>
  }

  export type OTPCreateManyUserInputEnvelope = {
    data: OTPCreateManyUserInput | OTPCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    product: ProductCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutUserInput = {
    id?: string
    product_id: string
    created_at?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentCreateManyUserInputEnvelope = {
    data: EnrollmentCreateManyUserInput | EnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    status?: boolean
    created_at?: Date | string
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    product_id: string
    rating: number
    comment?: string | null
    status?: boolean
    created_at?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLessonProgressCreateWithoutUserInput = {
    id?: string
    completed_at?: Date | string | null
    lesson: LessonCreateNestedOneWithoutUserProgressInput
  }

  export type UserLessonProgressUncheckedCreateWithoutUserInput = {
    id?: string
    lesson_id: string
    completed_at?: Date | string | null
  }

  export type UserLessonProgressCreateOrConnectWithoutUserInput = {
    where: UserLessonProgressWhereUniqueInput
    create: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput>
  }

  export type UserLessonProgressCreateManyUserInputEnvelope = {
    data: UserLessonProgressCreateManyUserInput | UserLessonProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeScoreCreateWithoutUserInput = {
    id?: string
    score: number
    submitted_at?: Date | string
    challenge: ChallengeCreateNestedOneWithoutChallengeScoreInput
  }

  export type ChallengeScoreUncheckedCreateWithoutUserInput = {
    id?: string
    challenge_id: string
    score: number
    submitted_at?: Date | string
  }

  export type ChallengeScoreCreateOrConnectWithoutUserInput = {
    where: ChallengeScoreWhereUniqueInput
    create: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput>
  }

  export type ChallengeScoreCreateManyUserInputEnvelope = {
    data: ChallengeScoreCreateManyUserInput | ChallengeScoreCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLessonScoreCreateWithoutUserInput = {
    id?: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutUserLessonScoreInput
  }

  export type UserLessonScoreUncheckedCreateWithoutUserInput = {
    id?: string
    lessonId: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLessonScoreCreateOrConnectWithoutUserInput = {
    where: UserLessonScoreWhereUniqueInput
    create: XOR<UserLessonScoreCreateWithoutUserInput, UserLessonScoreUncheckedCreateWithoutUserInput>
  }

  export type UserLessonScoreCreateManyUserInputEnvelope = {
    data: UserLessonScoreCreateManyUserInput | UserLessonScoreCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseProgressCreateWithoutUserInput = {
    id?: string
    completed_at?: Date | string | null
    course: ProductCreateNestedOneWithoutUserCourseProgressInput
  }

  export type UserCourseProgressUncheckedCreateWithoutUserInput = {
    id?: string
    product_id: string
    completed_at?: Date | string | null
  }

  export type UserCourseProgressCreateOrConnectWithoutUserInput = {
    where: UserCourseProgressWhereUniqueInput
    create: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput>
  }

  export type UserCourseProgressCreateManyUserInputEnvelope = {
    data: UserCourseProgressCreateManyUserInput | UserCourseProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OTPUpsertWithWhereUniqueWithoutUserInput = {
    where: OTPWhereUniqueInput
    update: XOR<OTPUpdateWithoutUserInput, OTPUncheckedUpdateWithoutUserInput>
    create: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput>
  }

  export type OTPUpdateWithWhereUniqueWithoutUserInput = {
    where: OTPWhereUniqueInput
    data: XOR<OTPUpdateWithoutUserInput, OTPUncheckedUpdateWithoutUserInput>
  }

  export type OTPUpdateManyWithWhereWithoutUserInput = {
    where: OTPScalarWhereInput
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyWithoutUserInput>
  }

  export type OTPScalarWhereInput = {
    AND?: OTPScalarWhereInput | OTPScalarWhereInput[]
    OR?: OTPScalarWhereInput[]
    NOT?: OTPScalarWhereInput | OTPScalarWhereInput[]
    id?: UuidFilter<"OTP"> | string
    createdAt?: DateTimeFilter<"OTP"> | Date | string
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    code?: StringFilter<"OTP"> | string
    isUsed?: BoolFilter<"OTP"> | boolean
    userId?: UuidFilter<"OTP"> | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: UuidFilter<"Enrollment"> | string
    user_id?: UuidFilter<"Enrollment"> | string
    product_id?: UuidFilter<"Enrollment"> | string
    created_at?: DateTimeFilter<"Enrollment"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: UuidFilter<"Review"> | string
    user_id?: UuidFilter<"Review"> | string
    product_id?: UuidFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    status?: BoolFilter<"Review"> | boolean
    created_at?: DateTimeFilter<"Review"> | Date | string
  }

  export type UserLessonProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLessonProgressWhereUniqueInput
    update: XOR<UserLessonProgressUpdateWithoutUserInput, UserLessonProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput>
  }

  export type UserLessonProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLessonProgressWhereUniqueInput
    data: XOR<UserLessonProgressUpdateWithoutUserInput, UserLessonProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserLessonProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserLessonProgressScalarWhereInput
    data: XOR<UserLessonProgressUpdateManyMutationInput, UserLessonProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLessonProgressScalarWhereInput = {
    AND?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
    OR?: UserLessonProgressScalarWhereInput[]
    NOT?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
    id?: UuidFilter<"UserLessonProgress"> | string
    user_id?: UuidFilter<"UserLessonProgress"> | string
    lesson_id?: UuidFilter<"UserLessonProgress"> | string
    completed_at?: DateTimeNullableFilter<"UserLessonProgress"> | Date | string | null
  }

  export type ChallengeScoreUpsertWithWhereUniqueWithoutUserInput = {
    where: ChallengeScoreWhereUniqueInput
    update: XOR<ChallengeScoreUpdateWithoutUserInput, ChallengeScoreUncheckedUpdateWithoutUserInput>
    create: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput>
  }

  export type ChallengeScoreUpdateWithWhereUniqueWithoutUserInput = {
    where: ChallengeScoreWhereUniqueInput
    data: XOR<ChallengeScoreUpdateWithoutUserInput, ChallengeScoreUncheckedUpdateWithoutUserInput>
  }

  export type ChallengeScoreUpdateManyWithWhereWithoutUserInput = {
    where: ChallengeScoreScalarWhereInput
    data: XOR<ChallengeScoreUpdateManyMutationInput, ChallengeScoreUncheckedUpdateManyWithoutUserInput>
  }

  export type ChallengeScoreScalarWhereInput = {
    AND?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
    OR?: ChallengeScoreScalarWhereInput[]
    NOT?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
    id?: UuidFilter<"ChallengeScore"> | string
    user_id?: UuidFilter<"ChallengeScore"> | string
    challenge_id?: UuidFilter<"ChallengeScore"> | string
    score?: FloatFilter<"ChallengeScore"> | number
    submitted_at?: DateTimeFilter<"ChallengeScore"> | Date | string
  }

  export type UserLessonScoreUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLessonScoreWhereUniqueInput
    update: XOR<UserLessonScoreUpdateWithoutUserInput, UserLessonScoreUncheckedUpdateWithoutUserInput>
    create: XOR<UserLessonScoreCreateWithoutUserInput, UserLessonScoreUncheckedCreateWithoutUserInput>
  }

  export type UserLessonScoreUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLessonScoreWhereUniqueInput
    data: XOR<UserLessonScoreUpdateWithoutUserInput, UserLessonScoreUncheckedUpdateWithoutUserInput>
  }

  export type UserLessonScoreUpdateManyWithWhereWithoutUserInput = {
    where: UserLessonScoreScalarWhereInput
    data: XOR<UserLessonScoreUpdateManyMutationInput, UserLessonScoreUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLessonScoreScalarWhereInput = {
    AND?: UserLessonScoreScalarWhereInput | UserLessonScoreScalarWhereInput[]
    OR?: UserLessonScoreScalarWhereInput[]
    NOT?: UserLessonScoreScalarWhereInput | UserLessonScoreScalarWhereInput[]
    id?: UuidFilter<"UserLessonScore"> | string
    userId?: UuidFilter<"UserLessonScore"> | string
    lessonId?: UuidFilter<"UserLessonScore"> | string
    score?: FloatFilter<"UserLessonScore"> | number
    createdAt?: DateTimeFilter<"UserLessonScore"> | Date | string
    updatedAt?: DateTimeFilter<"UserLessonScore"> | Date | string
  }

  export type UserCourseProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCourseProgressWhereUniqueInput
    update: XOR<UserCourseProgressUpdateWithoutUserInput, UserCourseProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput>
  }

  export type UserCourseProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCourseProgressWhereUniqueInput
    data: XOR<UserCourseProgressUpdateWithoutUserInput, UserCourseProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserCourseProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserCourseProgressScalarWhereInput
    data: XOR<UserCourseProgressUpdateManyMutationInput, UserCourseProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCourseProgressScalarWhereInput = {
    AND?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
    OR?: UserCourseProgressScalarWhereInput[]
    NOT?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
    id?: UuidFilter<"UserCourseProgress"> | string
    user_id?: UuidFilter<"UserCourseProgress"> | string
    product_id?: UuidFilter<"UserCourseProgress"> | string
    completed_at?: DateTimeNullableFilter<"UserCourseProgress"> | Date | string | null
  }

  export type UserCreateWithoutOtpsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
  }

  export type UserUpsertWithoutOtpsInput = {
    update: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutCourseInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: UuidFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    short_description?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category_id?: UuidFilter<"Product"> | string
    thumbnail?: StringFilter<"Product"> | string
    label?: EnumProductLabelFilter<"Product"> | $Enums.ProductLabel
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    requirements?: StringFilter<"Product"> | string
    learning_outcomes?: StringFilter<"Product"> | string
    preview_video?: StringNullableFilter<"Product"> | string | null
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Product"> | Date | string | null
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    status?: $Enums.CategoryStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    status?: $Enums.CategoryStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ModuleCreateWithoutCourseInput = {
    id?: string
    title: string
    short_description: string
    order?: number
    status?: $Enums.ModuleStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    lessons?: LessonCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    short_description: string
    order?: number
    status?: $Enums.ModuleStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleCreateManyCourseInputEnvelope = {
    data: ModuleCreateManyCourseInput | ModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutProductInput = {
    id?: string
    user_id: string
    created_at?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutProductInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutProductInput, EnrollmentUncheckedCreateWithoutProductInput>
  }

  export type EnrollmentCreateManyProductInputEnvelope = {
    data: EnrollmentCreateManyProductInput | EnrollmentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProductInput = {
    id?: string
    rating: number
    comment?: string | null
    status?: boolean
    created_at?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: string
    user_id: string
    rating: number
    comment?: string | null
    status?: boolean
    created_at?: Date | string
  }

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewCreateManyProductInputEnvelope = {
    data: ReviewCreateManyProductInput | ReviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseProgressCreateWithoutCourseInput = {
    id?: string
    completed_at?: Date | string | null
    user: UserCreateNestedOneWithoutUserCourseProgressInput
  }

  export type UserCourseProgressUncheckedCreateWithoutCourseInput = {
    id?: string
    user_id: string
    completed_at?: Date | string | null
  }

  export type UserCourseProgressCreateOrConnectWithoutCourseInput = {
    where: UserCourseProgressWhereUniqueInput
    create: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseProgressCreateManyCourseInputEnvelope = {
    data: UserCourseProgressCreateManyCourseInput | UserCourseProgressCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryStatusFieldUpdateOperationsInput | $Enums.CategoryStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryStatusFieldUpdateOperationsInput | $Enums.CategoryStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
  }

  export type ModuleUpdateManyWithWhereWithoutCourseInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: UuidFilter<"Module"> | string
    course_id?: UuidFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    short_description?: StringFilter<"Module"> | string
    order?: IntFilter<"Module"> | number
    status?: EnumModuleStatusFilter<"Module"> | $Enums.ModuleStatus
    created_at?: DateTimeFilter<"Module"> | Date | string
    updated_at?: DateTimeFilter<"Module"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Module"> | Date | string | null
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutProductInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutProductInput, EnrollmentUncheckedUpdateWithoutProductInput>
    create: XOR<EnrollmentCreateWithoutProductInput, EnrollmentUncheckedCreateWithoutProductInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutProductInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutProductInput, EnrollmentUncheckedUpdateWithoutProductInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutProductInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutProductInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProductInput>
  }

  export type UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput = {
    where: UserCourseProgressWhereUniqueInput
    update: XOR<UserCourseProgressUpdateWithoutCourseInput, UserCourseProgressUncheckedUpdateWithoutCourseInput>
    create: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput = {
    where: UserCourseProgressWhereUniqueInput
    data: XOR<UserCourseProgressUpdateWithoutCourseInput, UserCourseProgressUncheckedUpdateWithoutCourseInput>
  }

  export type UserCourseProgressUpdateManyWithWhereWithoutCourseInput = {
    where: UserCourseProgressScalarWhereInput
    data: XOR<UserCourseProgressUpdateManyMutationInput, UserCourseProgressUncheckedUpdateManyWithoutCourseInput>
  }

  export type ProductCreateWithoutModulesInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enrollments?: EnrollmentCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutCourseInput
  }

  export type ProductUncheckedCreateWithoutModulesInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    category_id: string
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
  }

  export type ProductCreateOrConnectWithoutModulesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutModulesInput, ProductUncheckedCreateWithoutModulesInput>
  }

  export type LessonCreateWithoutModuleInput = {
    id?: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    question?: QuizQuestionCreateNestedManyWithoutLessonInput
    userProgress?: UserLessonProgressCreateNestedManyWithoutLessonInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutModuleInput = {
    id?: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    question?: QuizQuestionUncheckedCreateNestedManyWithoutLessonInput
    userProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutLessonInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutModuleInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonCreateManyModuleInputEnvelope = {
    data: LessonCreateManyModuleInput | LessonCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutModulesInput = {
    update: XOR<ProductUpdateWithoutModulesInput, ProductUncheckedUpdateWithoutModulesInput>
    create: XOR<ProductCreateWithoutModulesInput, ProductUncheckedCreateWithoutModulesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutModulesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutModulesInput, ProductUncheckedUpdateWithoutModulesInput>
  }

  export type ProductUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
  }

  export type ProductUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
  }

  export type LessonUpdateManyWithWhereWithoutModuleInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutModuleInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: UuidFilter<"Lesson"> | string
    module_id?: UuidFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    description?: StringFilter<"Lesson"> | string
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    is_previewable?: BoolFilter<"Lesson"> | boolean
    status?: EnumLessonStatusFilter<"Lesson"> | $Enums.LessonStatus
    order?: IntFilter<"Lesson"> | number
    attachment?: StringNullableFilter<"Lesson"> | string | null
    created_at?: DateTimeFilter<"Lesson"> | Date | string
    updated_at?: DateTimeFilter<"Lesson"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Lesson"> | Date | string | null
  }

  export type ModuleCreateWithoutLessonsInput = {
    id?: string
    title: string
    short_description: string
    order?: number
    status?: $Enums.ModuleStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    course: ProductCreateNestedOneWithoutModulesInput
  }

  export type ModuleUncheckedCreateWithoutLessonsInput = {
    id?: string
    course_id: string
    title: string
    short_description: string
    order?: number
    status?: $Enums.ModuleStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ModuleCreateOrConnectWithoutLessonsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
  }

  export type QuizQuestionCreateWithoutLessonInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    answers?: QuizAnswerCreateNestedManyWithoutQuiz_questionInput
  }

  export type QuizQuestionUncheckedCreateWithoutLessonInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuiz_questionInput
  }

  export type QuizQuestionCreateOrConnectWithoutLessonInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutLessonInput, QuizQuestionUncheckedCreateWithoutLessonInput>
  }

  export type QuizQuestionCreateManyLessonInputEnvelope = {
    data: QuizQuestionCreateManyLessonInput | QuizQuestionCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type UserLessonProgressCreateWithoutLessonInput = {
    id?: string
    completed_at?: Date | string | null
    user: UserCreateNestedOneWithoutUserLessonProgressInput
  }

  export type UserLessonProgressUncheckedCreateWithoutLessonInput = {
    id?: string
    user_id: string
    completed_at?: Date | string | null
  }

  export type UserLessonProgressCreateOrConnectWithoutLessonInput = {
    where: UserLessonProgressWhereUniqueInput
    create: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type UserLessonProgressCreateManyLessonInputEnvelope = {
    data: UserLessonProgressCreateManyLessonInput | UserLessonProgressCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type UserLessonScoreCreateWithoutLessonInput = {
    id?: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserLessonScoreInput
  }

  export type UserLessonScoreUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLessonScoreCreateOrConnectWithoutLessonInput = {
    where: UserLessonScoreWhereUniqueInput
    create: XOR<UserLessonScoreCreateWithoutLessonInput, UserLessonScoreUncheckedCreateWithoutLessonInput>
  }

  export type UserLessonScoreCreateManyLessonInputEnvelope = {
    data: UserLessonScoreCreateManyLessonInput | UserLessonScoreCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithoutLessonsInput = {
    update: XOR<ModuleUpdateWithoutLessonsInput, ModuleUncheckedUpdateWithoutLessonsInput>
    create: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutLessonsInput, ModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type ModuleUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumModuleStatusFieldUpdateOperationsInput | $Enums.ModuleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: ProductUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumModuleStatusFieldUpdateOperationsInput | $Enums.ModuleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutLessonInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutLessonInput, QuizQuestionUncheckedUpdateWithoutLessonInput>
    create: XOR<QuizQuestionCreateWithoutLessonInput, QuizQuestionUncheckedCreateWithoutLessonInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutLessonInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutLessonInput, QuizQuestionUncheckedUpdateWithoutLessonInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutLessonInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutLessonInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    OR?: QuizQuestionScalarWhereInput[]
    NOT?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    id?: UuidFilter<"QuizQuestion"> | string
    lesson_id?: UuidFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    created_at?: DateTimeFilter<"QuizQuestion"> | Date | string
    updated_at?: DateTimeFilter<"QuizQuestion"> | Date | string
    deleted_at?: DateTimeNullableFilter<"QuizQuestion"> | Date | string | null
  }

  export type UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput = {
    where: UserLessonProgressWhereUniqueInput
    update: XOR<UserLessonProgressUpdateWithoutLessonInput, UserLessonProgressUncheckedUpdateWithoutLessonInput>
    create: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput = {
    where: UserLessonProgressWhereUniqueInput
    data: XOR<UserLessonProgressUpdateWithoutLessonInput, UserLessonProgressUncheckedUpdateWithoutLessonInput>
  }

  export type UserLessonProgressUpdateManyWithWhereWithoutLessonInput = {
    where: UserLessonProgressScalarWhereInput
    data: XOR<UserLessonProgressUpdateManyMutationInput, UserLessonProgressUncheckedUpdateManyWithoutLessonInput>
  }

  export type UserLessonScoreUpsertWithWhereUniqueWithoutLessonInput = {
    where: UserLessonScoreWhereUniqueInput
    update: XOR<UserLessonScoreUpdateWithoutLessonInput, UserLessonScoreUncheckedUpdateWithoutLessonInput>
    create: XOR<UserLessonScoreCreateWithoutLessonInput, UserLessonScoreUncheckedCreateWithoutLessonInput>
  }

  export type UserLessonScoreUpdateWithWhereUniqueWithoutLessonInput = {
    where: UserLessonScoreWhereUniqueInput
    data: XOR<UserLessonScoreUpdateWithoutLessonInput, UserLessonScoreUncheckedUpdateWithoutLessonInput>
  }

  export type UserLessonScoreUpdateManyWithWhereWithoutLessonInput = {
    where: UserLessonScoreScalarWhereInput
    data: XOR<UserLessonScoreUpdateManyMutationInput, UserLessonScoreUncheckedUpdateManyWithoutLessonInput>
  }

  export type ProductCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutCourseInput
  }

  export type ProductUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    category_id: string
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
  }

  export type ProductCreateOrConnectWithoutEnrollmentsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutEnrollmentsInput, ProductUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserCreateWithoutEnrollmentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
  }

  export type ProductUpsertWithoutEnrollmentsInput = {
    update: XOR<ProductUpdateWithoutEnrollmentsInput, ProductUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<ProductCreateWithoutEnrollmentsInput, ProductUncheckedCreateWithoutEnrollmentsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutEnrollmentsInput, ProductUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ProductUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
  }

  export type ProductUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserUpsertWithoutEnrollmentsInput = {
    update: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ProductCreateWithoutReviewsInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutCourseInput
  }

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    category_id: string
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProductInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
  }

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
  }

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LessonCreateWithoutQuestionInput = {
    id?: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    module: ModuleCreateNestedOneWithoutLessonsInput
    userProgress?: UserLessonProgressCreateNestedManyWithoutLessonInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutQuestionInput = {
    id?: string
    module_id: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    userProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutLessonInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutQuestionInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutQuestionInput, LessonUncheckedCreateWithoutQuestionInput>
  }

  export type QuizAnswerCreateWithoutQuiz_questionInput = {
    id?: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuizAnswerUncheckedCreateWithoutQuiz_questionInput = {
    id?: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuizAnswerCreateOrConnectWithoutQuiz_questionInput = {
    where: QuizAnswerWhereUniqueInput
    create: XOR<QuizAnswerCreateWithoutQuiz_questionInput, QuizAnswerUncheckedCreateWithoutQuiz_questionInput>
  }

  export type QuizAnswerCreateManyQuiz_questionInputEnvelope = {
    data: QuizAnswerCreateManyQuiz_questionInput | QuizAnswerCreateManyQuiz_questionInput[]
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithoutQuestionInput = {
    update: XOR<LessonUpdateWithoutQuestionInput, LessonUncheckedUpdateWithoutQuestionInput>
    create: XOR<LessonCreateWithoutQuestionInput, LessonUncheckedCreateWithoutQuestionInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutQuestionInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutQuestionInput, LessonUncheckedUpdateWithoutQuestionInput>
  }

  export type LessonUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    userProgress?: UserLessonProgressUpdateManyWithoutLessonNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    module_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProgress?: UserLessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type QuizAnswerUpsertWithWhereUniqueWithoutQuiz_questionInput = {
    where: QuizAnswerWhereUniqueInput
    update: XOR<QuizAnswerUpdateWithoutQuiz_questionInput, QuizAnswerUncheckedUpdateWithoutQuiz_questionInput>
    create: XOR<QuizAnswerCreateWithoutQuiz_questionInput, QuizAnswerUncheckedCreateWithoutQuiz_questionInput>
  }

  export type QuizAnswerUpdateWithWhereUniqueWithoutQuiz_questionInput = {
    where: QuizAnswerWhereUniqueInput
    data: XOR<QuizAnswerUpdateWithoutQuiz_questionInput, QuizAnswerUncheckedUpdateWithoutQuiz_questionInput>
  }

  export type QuizAnswerUpdateManyWithWhereWithoutQuiz_questionInput = {
    where: QuizAnswerScalarWhereInput
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyWithoutQuiz_questionInput>
  }

  export type QuizAnswerScalarWhereInput = {
    AND?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
    OR?: QuizAnswerScalarWhereInput[]
    NOT?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
    id?: UuidFilter<"QuizAnswer"> | string
    quiz_question_id?: UuidFilter<"QuizAnswer"> | string
    answer?: StringFilter<"QuizAnswer"> | string
    is_correct?: BoolFilter<"QuizAnswer"> | boolean
    created_at?: DateTimeFilter<"QuizAnswer"> | Date | string
    updated_at?: DateTimeFilter<"QuizAnswer"> | Date | string
    deleted_at?: DateTimeNullableFilter<"QuizAnswer"> | Date | string | null
  }

  export type QuizQuestionCreateWithoutAnswersInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    lesson: LessonCreateNestedOneWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    lesson_id: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuizQuestionCreateOrConnectWithoutAnswersInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type QuizQuestionUpsertWithoutAnswersInput = {
    update: XOR<QuizQuestionUpdateWithoutAnswersInput, QuizQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    where?: QuizQuestionWhereInput
  }

  export type QuizQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuizQuestionWhereInput
    data: XOR<QuizQuestionUpdateWithoutAnswersInput, QuizQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    lesson_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeQuestionCreateWithoutChallengeInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    answers?: ChallengeAnswerCreateNestedManyWithoutChallenge_questionInput
  }

  export type ChallengeQuestionUncheckedCreateWithoutChallengeInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    answers?: ChallengeAnswerUncheckedCreateNestedManyWithoutChallenge_questionInput
  }

  export type ChallengeQuestionCreateOrConnectWithoutChallengeInput = {
    where: ChallengeQuestionWhereUniqueInput
    create: XOR<ChallengeQuestionCreateWithoutChallengeInput, ChallengeQuestionUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeQuestionCreateManyChallengeInputEnvelope = {
    data: ChallengeQuestionCreateManyChallengeInput | ChallengeQuestionCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeScoreCreateWithoutChallengeInput = {
    id?: string
    score: number
    submitted_at?: Date | string
    user: UserCreateNestedOneWithoutChallengeScoreInput
  }

  export type ChallengeScoreUncheckedCreateWithoutChallengeInput = {
    id?: string
    user_id: string
    score: number
    submitted_at?: Date | string
  }

  export type ChallengeScoreCreateOrConnectWithoutChallengeInput = {
    where: ChallengeScoreWhereUniqueInput
    create: XOR<ChallengeScoreCreateWithoutChallengeInput, ChallengeScoreUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeScoreCreateManyChallengeInputEnvelope = {
    data: ChallengeScoreCreateManyChallengeInput | ChallengeScoreCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type PuzzleChallengeCreateWithoutChallengeInput = {
    id?: string
    instruction: string
    image: string
  }

  export type PuzzleChallengeUncheckedCreateWithoutChallengeInput = {
    id?: string
    instruction: string
    image: string
  }

  export type PuzzleChallengeCreateOrConnectWithoutChallengeInput = {
    where: PuzzleChallengeWhereUniqueInput
    create: XOR<PuzzleChallengeCreateWithoutChallengeInput, PuzzleChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type OrderingChallengeCreateWithoutChallengeInput = {
    id?: string
    instruction: string
    items?: OrderingItemCreateNestedManyWithoutOrderingChallengeInput
  }

  export type OrderingChallengeUncheckedCreateWithoutChallengeInput = {
    id?: string
    instruction: string
    items?: OrderingItemUncheckedCreateNestedManyWithoutOrderingChallengeInput
  }

  export type OrderingChallengeCreateOrConnectWithoutChallengeInput = {
    where: OrderingChallengeWhereUniqueInput
    create: XOR<OrderingChallengeCreateWithoutChallengeInput, OrderingChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type FillBlankChallengeCreateWithoutChallengeInput = {
    id?: string
    questions?: FillBlankQuestionCreateNestedManyWithoutChallengeInput
  }

  export type FillBlankChallengeUncheckedCreateWithoutChallengeInput = {
    id?: string
    questions?: FillBlankQuestionUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type FillBlankChallengeCreateOrConnectWithoutChallengeInput = {
    where: FillBlankChallengeWhereUniqueInput
    create: XOR<FillBlankChallengeCreateWithoutChallengeInput, FillBlankChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeQuestionUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeQuestionWhereUniqueInput
    update: XOR<ChallengeQuestionUpdateWithoutChallengeInput, ChallengeQuestionUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeQuestionCreateWithoutChallengeInput, ChallengeQuestionUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeQuestionUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeQuestionWhereUniqueInput
    data: XOR<ChallengeQuestionUpdateWithoutChallengeInput, ChallengeQuestionUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeQuestionUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeQuestionScalarWhereInput
    data: XOR<ChallengeQuestionUpdateManyMutationInput, ChallengeQuestionUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeQuestionScalarWhereInput = {
    AND?: ChallengeQuestionScalarWhereInput | ChallengeQuestionScalarWhereInput[]
    OR?: ChallengeQuestionScalarWhereInput[]
    NOT?: ChallengeQuestionScalarWhereInput | ChallengeQuestionScalarWhereInput[]
    id?: UuidFilter<"ChallengeQuestion"> | string
    challenge_id?: UuidFilter<"ChallengeQuestion"> | string
    question?: StringFilter<"ChallengeQuestion"> | string
    explanation?: StringNullableFilter<"ChallengeQuestion"> | string | null
    created_at?: DateTimeFilter<"ChallengeQuestion"> | Date | string
    updated_at?: DateTimeFilter<"ChallengeQuestion"> | Date | string
  }

  export type ChallengeScoreUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeScoreWhereUniqueInput
    update: XOR<ChallengeScoreUpdateWithoutChallengeInput, ChallengeScoreUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeScoreCreateWithoutChallengeInput, ChallengeScoreUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeScoreUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeScoreWhereUniqueInput
    data: XOR<ChallengeScoreUpdateWithoutChallengeInput, ChallengeScoreUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeScoreUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeScoreScalarWhereInput
    data: XOR<ChallengeScoreUpdateManyMutationInput, ChallengeScoreUncheckedUpdateManyWithoutChallengeInput>
  }

  export type PuzzleChallengeUpsertWithoutChallengeInput = {
    update: XOR<PuzzleChallengeUpdateWithoutChallengeInput, PuzzleChallengeUncheckedUpdateWithoutChallengeInput>
    create: XOR<PuzzleChallengeCreateWithoutChallengeInput, PuzzleChallengeUncheckedCreateWithoutChallengeInput>
    where?: PuzzleChallengeWhereInput
  }

  export type PuzzleChallengeUpdateToOneWithWhereWithoutChallengeInput = {
    where?: PuzzleChallengeWhereInput
    data: XOR<PuzzleChallengeUpdateWithoutChallengeInput, PuzzleChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type PuzzleChallengeUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type PuzzleChallengeUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type OrderingChallengeUpsertWithoutChallengeInput = {
    update: XOR<OrderingChallengeUpdateWithoutChallengeInput, OrderingChallengeUncheckedUpdateWithoutChallengeInput>
    create: XOR<OrderingChallengeCreateWithoutChallengeInput, OrderingChallengeUncheckedCreateWithoutChallengeInput>
    where?: OrderingChallengeWhereInput
  }

  export type OrderingChallengeUpdateToOneWithWhereWithoutChallengeInput = {
    where?: OrderingChallengeWhereInput
    data: XOR<OrderingChallengeUpdateWithoutChallengeInput, OrderingChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type OrderingChallengeUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    items?: OrderingItemUpdateManyWithoutOrderingChallengeNestedInput
  }

  export type OrderingChallengeUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    items?: OrderingItemUncheckedUpdateManyWithoutOrderingChallengeNestedInput
  }

  export type FillBlankChallengeUpsertWithoutChallengeInput = {
    update: XOR<FillBlankChallengeUpdateWithoutChallengeInput, FillBlankChallengeUncheckedUpdateWithoutChallengeInput>
    create: XOR<FillBlankChallengeCreateWithoutChallengeInput, FillBlankChallengeUncheckedCreateWithoutChallengeInput>
    where?: FillBlankChallengeWhereInput
  }

  export type FillBlankChallengeUpdateToOneWithWhereWithoutChallengeInput = {
    where?: FillBlankChallengeWhereInput
    data: XOR<FillBlankChallengeUpdateWithoutChallengeInput, FillBlankChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type FillBlankChallengeUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: FillBlankQuestionUpdateManyWithoutChallengeNestedInput
  }

  export type FillBlankChallengeUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: FillBlankQuestionUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutQuestionsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    challengeScore?: ChallengeScoreCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeCreateNestedOneWithoutChallengeInput
    orderingChallenge?: OrderingChallengeCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeUncheckedCreateNestedOneWithoutChallengeInput
    orderingChallenge?: OrderingChallengeUncheckedCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeUncheckedCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutQuestionsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutQuestionsInput, ChallengeUncheckedCreateWithoutQuestionsInput>
  }

  export type ChallengeAnswerCreateWithoutChallenge_questionInput = {
    id?: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput = {
    id?: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeAnswerCreateOrConnectWithoutChallenge_questionInput = {
    where: ChallengeAnswerWhereUniqueInput
    create: XOR<ChallengeAnswerCreateWithoutChallenge_questionInput, ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput>
  }

  export type ChallengeAnswerCreateManyChallenge_questionInputEnvelope = {
    data: ChallengeAnswerCreateManyChallenge_questionInput | ChallengeAnswerCreateManyChallenge_questionInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeUpsertWithoutQuestionsInput = {
    update: XOR<ChallengeUpdateWithoutQuestionsInput, ChallengeUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ChallengeCreateWithoutQuestionsInput, ChallengeUncheckedCreateWithoutQuestionsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutQuestionsInput, ChallengeUncheckedUpdateWithoutQuestionsInput>
  }

  export type ChallengeUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challengeScore?: ChallengeScoreUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUpdateOneWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUpdateOneWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUncheckedUpdateOneWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUncheckedUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUncheckedUpdateOneWithoutChallengeNestedInput
  }

  export type ChallengeAnswerUpsertWithWhereUniqueWithoutChallenge_questionInput = {
    where: ChallengeAnswerWhereUniqueInput
    update: XOR<ChallengeAnswerUpdateWithoutChallenge_questionInput, ChallengeAnswerUncheckedUpdateWithoutChallenge_questionInput>
    create: XOR<ChallengeAnswerCreateWithoutChallenge_questionInput, ChallengeAnswerUncheckedCreateWithoutChallenge_questionInput>
  }

  export type ChallengeAnswerUpdateWithWhereUniqueWithoutChallenge_questionInput = {
    where: ChallengeAnswerWhereUniqueInput
    data: XOR<ChallengeAnswerUpdateWithoutChallenge_questionInput, ChallengeAnswerUncheckedUpdateWithoutChallenge_questionInput>
  }

  export type ChallengeAnswerUpdateManyWithWhereWithoutChallenge_questionInput = {
    where: ChallengeAnswerScalarWhereInput
    data: XOR<ChallengeAnswerUpdateManyMutationInput, ChallengeAnswerUncheckedUpdateManyWithoutChallenge_questionInput>
  }

  export type ChallengeAnswerScalarWhereInput = {
    AND?: ChallengeAnswerScalarWhereInput | ChallengeAnswerScalarWhereInput[]
    OR?: ChallengeAnswerScalarWhereInput[]
    NOT?: ChallengeAnswerScalarWhereInput | ChallengeAnswerScalarWhereInput[]
    id?: UuidFilter<"ChallengeAnswer"> | string
    challenge_question_id?: UuidFilter<"ChallengeAnswer"> | string
    answer?: StringFilter<"ChallengeAnswer"> | string
    is_correct?: BoolFilter<"ChallengeAnswer"> | boolean
    created_at?: DateTimeFilter<"ChallengeAnswer"> | Date | string
    updated_at?: DateTimeFilter<"ChallengeAnswer"> | Date | string
  }

  export type ChallengeQuestionCreateWithoutAnswersInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    challenge: ChallengeCreateNestedOneWithoutQuestionsInput
  }

  export type ChallengeQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    challenge_id: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeQuestionCreateOrConnectWithoutAnswersInput = {
    where: ChallengeQuestionWhereUniqueInput
    create: XOR<ChallengeQuestionCreateWithoutAnswersInput, ChallengeQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type ChallengeQuestionUpsertWithoutAnswersInput = {
    update: XOR<ChallengeQuestionUpdateWithoutAnswersInput, ChallengeQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<ChallengeQuestionCreateWithoutAnswersInput, ChallengeQuestionUncheckedCreateWithoutAnswersInput>
    where?: ChallengeQuestionWhereInput
  }

  export type ChallengeQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: ChallengeQuestionWhereInput
    data: XOR<ChallengeQuestionUpdateWithoutAnswersInput, ChallengeQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type ChallengeQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type ChallengeQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeCreateWithoutPuzzleChallengeInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionCreateNestedManyWithoutChallengeInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutChallengeInput
    orderingChallenge?: OrderingChallengeCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutPuzzleChallengeInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionUncheckedCreateNestedManyWithoutChallengeInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutChallengeInput
    orderingChallenge?: OrderingChallengeUncheckedCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeUncheckedCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutPuzzleChallengeInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutPuzzleChallengeInput, ChallengeUncheckedCreateWithoutPuzzleChallengeInput>
  }

  export type ChallengeUpsertWithoutPuzzleChallengeInput = {
    update: XOR<ChallengeUpdateWithoutPuzzleChallengeInput, ChallengeUncheckedUpdateWithoutPuzzleChallengeInput>
    create: XOR<ChallengeCreateWithoutPuzzleChallengeInput, ChallengeUncheckedCreateWithoutPuzzleChallengeInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutPuzzleChallengeInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutPuzzleChallengeInput, ChallengeUncheckedUpdateWithoutPuzzleChallengeInput>
  }

  export type ChallengeUpdateWithoutPuzzleChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUpdateManyWithoutChallengeNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUpdateOneWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutPuzzleChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUncheckedUpdateManyWithoutChallengeNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUncheckedUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUncheckedUpdateOneWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutOrderingChallengeInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionCreateNestedManyWithoutChallengeInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutOrderingChallengeInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionUncheckedCreateNestedManyWithoutChallengeInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeUncheckedCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeUncheckedCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutOrderingChallengeInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutOrderingChallengeInput, ChallengeUncheckedCreateWithoutOrderingChallengeInput>
  }

  export type OrderingItemCreateWithoutOrderingChallengeInput = {
    id?: string
    content: string
    correct_order: number
    explanation?: string | null
  }

  export type OrderingItemUncheckedCreateWithoutOrderingChallengeInput = {
    id?: string
    content: string
    correct_order: number
    explanation?: string | null
  }

  export type OrderingItemCreateOrConnectWithoutOrderingChallengeInput = {
    where: OrderingItemWhereUniqueInput
    create: XOR<OrderingItemCreateWithoutOrderingChallengeInput, OrderingItemUncheckedCreateWithoutOrderingChallengeInput>
  }

  export type OrderingItemCreateManyOrderingChallengeInputEnvelope = {
    data: OrderingItemCreateManyOrderingChallengeInput | OrderingItemCreateManyOrderingChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeUpsertWithoutOrderingChallengeInput = {
    update: XOR<ChallengeUpdateWithoutOrderingChallengeInput, ChallengeUncheckedUpdateWithoutOrderingChallengeInput>
    create: XOR<ChallengeCreateWithoutOrderingChallengeInput, ChallengeUncheckedCreateWithoutOrderingChallengeInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutOrderingChallengeInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutOrderingChallengeInput, ChallengeUncheckedUpdateWithoutOrderingChallengeInput>
  }

  export type ChallengeUpdateWithoutOrderingChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUpdateManyWithoutChallengeNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUpdateOneWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutOrderingChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUncheckedUpdateManyWithoutChallengeNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUncheckedUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUncheckedUpdateOneWithoutChallengeNestedInput
  }

  export type OrderingItemUpsertWithWhereUniqueWithoutOrderingChallengeInput = {
    where: OrderingItemWhereUniqueInput
    update: XOR<OrderingItemUpdateWithoutOrderingChallengeInput, OrderingItemUncheckedUpdateWithoutOrderingChallengeInput>
    create: XOR<OrderingItemCreateWithoutOrderingChallengeInput, OrderingItemUncheckedCreateWithoutOrderingChallengeInput>
  }

  export type OrderingItemUpdateWithWhereUniqueWithoutOrderingChallengeInput = {
    where: OrderingItemWhereUniqueInput
    data: XOR<OrderingItemUpdateWithoutOrderingChallengeInput, OrderingItemUncheckedUpdateWithoutOrderingChallengeInput>
  }

  export type OrderingItemUpdateManyWithWhereWithoutOrderingChallengeInput = {
    where: OrderingItemScalarWhereInput
    data: XOR<OrderingItemUpdateManyMutationInput, OrderingItemUncheckedUpdateManyWithoutOrderingChallengeInput>
  }

  export type OrderingItemScalarWhereInput = {
    AND?: OrderingItemScalarWhereInput | OrderingItemScalarWhereInput[]
    OR?: OrderingItemScalarWhereInput[]
    NOT?: OrderingItemScalarWhereInput | OrderingItemScalarWhereInput[]
    id?: UuidFilter<"OrderingItem"> | string
    ordering_id?: UuidFilter<"OrderingItem"> | string
    content?: StringFilter<"OrderingItem"> | string
    correct_order?: IntFilter<"OrderingItem"> | number
    explanation?: StringNullableFilter<"OrderingItem"> | string | null
  }

  export type OrderingChallengeCreateWithoutItemsInput = {
    id?: string
    instruction: string
    challenge: ChallengeCreateNestedOneWithoutOrderingChallengeInput
  }

  export type OrderingChallengeUncheckedCreateWithoutItemsInput = {
    id?: string
    challenge_id: string
    instruction: string
  }

  export type OrderingChallengeCreateOrConnectWithoutItemsInput = {
    where: OrderingChallengeWhereUniqueInput
    create: XOR<OrderingChallengeCreateWithoutItemsInput, OrderingChallengeUncheckedCreateWithoutItemsInput>
  }

  export type OrderingChallengeUpsertWithoutItemsInput = {
    update: XOR<OrderingChallengeUpdateWithoutItemsInput, OrderingChallengeUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderingChallengeCreateWithoutItemsInput, OrderingChallengeUncheckedCreateWithoutItemsInput>
    where?: OrderingChallengeWhereInput
  }

  export type OrderingChallengeUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderingChallengeWhereInput
    data: XOR<OrderingChallengeUpdateWithoutItemsInput, OrderingChallengeUncheckedUpdateWithoutItemsInput>
  }

  export type OrderingChallengeUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutOrderingChallengeNestedInput
  }

  export type OrderingChallengeUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeCreateWithoutFillBlankChallengeInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionCreateNestedManyWithoutChallengeInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeCreateNestedOneWithoutChallengeInput
    orderingChallenge?: OrderingChallengeCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutFillBlankChallengeInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionUncheckedCreateNestedManyWithoutChallengeInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeUncheckedCreateNestedOneWithoutChallengeInput
    orderingChallenge?: OrderingChallengeUncheckedCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutFillBlankChallengeInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutFillBlankChallengeInput, ChallengeUncheckedCreateWithoutFillBlankChallengeInput>
  }

  export type FillBlankQuestionCreateWithoutChallengeInput = {
    id?: string
    sentence: string
    correct_word: string
  }

  export type FillBlankQuestionUncheckedCreateWithoutChallengeInput = {
    id?: string
    sentence: string
    correct_word: string
  }

  export type FillBlankQuestionCreateOrConnectWithoutChallengeInput = {
    where: FillBlankQuestionWhereUniqueInput
    create: XOR<FillBlankQuestionCreateWithoutChallengeInput, FillBlankQuestionUncheckedCreateWithoutChallengeInput>
  }

  export type FillBlankQuestionCreateManyChallengeInputEnvelope = {
    data: FillBlankQuestionCreateManyChallengeInput | FillBlankQuestionCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeUpsertWithoutFillBlankChallengeInput = {
    update: XOR<ChallengeUpdateWithoutFillBlankChallengeInput, ChallengeUncheckedUpdateWithoutFillBlankChallengeInput>
    create: XOR<ChallengeCreateWithoutFillBlankChallengeInput, ChallengeUncheckedCreateWithoutFillBlankChallengeInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutFillBlankChallengeInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutFillBlankChallengeInput, ChallengeUncheckedUpdateWithoutFillBlankChallengeInput>
  }

  export type ChallengeUpdateWithoutFillBlankChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUpdateManyWithoutChallengeNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUpdateOneWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUpdateOneWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutFillBlankChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUncheckedUpdateManyWithoutChallengeNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUncheckedUpdateOneWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUncheckedUpdateOneWithoutChallengeNestedInput
  }

  export type FillBlankQuestionUpsertWithWhereUniqueWithoutChallengeInput = {
    where: FillBlankQuestionWhereUniqueInput
    update: XOR<FillBlankQuestionUpdateWithoutChallengeInput, FillBlankQuestionUncheckedUpdateWithoutChallengeInput>
    create: XOR<FillBlankQuestionCreateWithoutChallengeInput, FillBlankQuestionUncheckedCreateWithoutChallengeInput>
  }

  export type FillBlankQuestionUpdateWithWhereUniqueWithoutChallengeInput = {
    where: FillBlankQuestionWhereUniqueInput
    data: XOR<FillBlankQuestionUpdateWithoutChallengeInput, FillBlankQuestionUncheckedUpdateWithoutChallengeInput>
  }

  export type FillBlankQuestionUpdateManyWithWhereWithoutChallengeInput = {
    where: FillBlankQuestionScalarWhereInput
    data: XOR<FillBlankQuestionUpdateManyMutationInput, FillBlankQuestionUncheckedUpdateManyWithoutChallengeInput>
  }

  export type FillBlankQuestionScalarWhereInput = {
    AND?: FillBlankQuestionScalarWhereInput | FillBlankQuestionScalarWhereInput[]
    OR?: FillBlankQuestionScalarWhereInput[]
    NOT?: FillBlankQuestionScalarWhereInput | FillBlankQuestionScalarWhereInput[]
    id?: UuidFilter<"FillBlankQuestion"> | string
    challenge_id?: UuidFilter<"FillBlankQuestion"> | string
    sentence?: StringFilter<"FillBlankQuestion"> | string
    correct_word?: StringFilter<"FillBlankQuestion"> | string
  }

  export type FillBlankChallengeCreateWithoutQuestionsInput = {
    id?: string
    challenge: ChallengeCreateNestedOneWithoutFillBlankChallengeInput
  }

  export type FillBlankChallengeUncheckedCreateWithoutQuestionsInput = {
    id?: string
    challenge_id: string
  }

  export type FillBlankChallengeCreateOrConnectWithoutQuestionsInput = {
    where: FillBlankChallengeWhereUniqueInput
    create: XOR<FillBlankChallengeCreateWithoutQuestionsInput, FillBlankChallengeUncheckedCreateWithoutQuestionsInput>
  }

  export type FillBlankChallengeUpsertWithoutQuestionsInput = {
    update: XOR<FillBlankChallengeUpdateWithoutQuestionsInput, FillBlankChallengeUncheckedUpdateWithoutQuestionsInput>
    create: XOR<FillBlankChallengeCreateWithoutQuestionsInput, FillBlankChallengeUncheckedCreateWithoutQuestionsInput>
    where?: FillBlankChallengeWhereInput
  }

  export type FillBlankChallengeUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: FillBlankChallengeWhereInput
    data: XOR<FillBlankChallengeUpdateWithoutQuestionsInput, FillBlankChallengeUncheckedUpdateWithoutQuestionsInput>
  }

  export type FillBlankChallengeUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutFillBlankChallengeNestedInput
  }

  export type FillBlankChallengeUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutUserLessonProgressInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserLessonProgressInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserLessonProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserLessonProgressInput, UserUncheckedCreateWithoutUserLessonProgressInput>
  }

  export type LessonCreateWithoutUserProgressInput = {
    id?: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    module: ModuleCreateNestedOneWithoutLessonsInput
    question?: QuizQuestionCreateNestedManyWithoutLessonInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutUserProgressInput = {
    id?: string
    module_id: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    question?: QuizQuestionUncheckedCreateNestedManyWithoutLessonInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutUserProgressInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutUserProgressInput, LessonUncheckedCreateWithoutUserProgressInput>
  }

  export type UserUpsertWithoutUserLessonProgressInput = {
    update: XOR<UserUpdateWithoutUserLessonProgressInput, UserUncheckedUpdateWithoutUserLessonProgressInput>
    create: XOR<UserCreateWithoutUserLessonProgressInput, UserUncheckedCreateWithoutUserLessonProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserLessonProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserLessonProgressInput, UserUncheckedUpdateWithoutUserLessonProgressInput>
  }

  export type UserUpdateWithoutUserLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonUpsertWithoutUserProgressInput = {
    update: XOR<LessonUpdateWithoutUserProgressInput, LessonUncheckedUpdateWithoutUserProgressInput>
    create: XOR<LessonCreateWithoutUserProgressInput, LessonUncheckedCreateWithoutUserProgressInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutUserProgressInput, LessonUncheckedUpdateWithoutUserProgressInput>
  }

  export type LessonUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    question?: QuizQuestionUpdateManyWithoutLessonNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    module_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuizQuestionUncheckedUpdateManyWithoutLessonNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserCreateWithoutChallengeScoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChallengeScoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChallengeScoreInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengeScoreInput, UserUncheckedCreateWithoutChallengeScoreInput>
  }

  export type ChallengeCreateWithoutChallengeScoreInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeCreateNestedOneWithoutChallengeInput
    orderingChallenge?: OrderingChallengeCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutChallengeScoreInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    type: $Enums.ChallengeType
    order?: number
    status?: $Enums.ChallengeStatus
    created_at?: Date | string
    updated_at?: Date | string
    questions?: ChallengeQuestionUncheckedCreateNestedManyWithoutChallengeInput
    puzzleChallenge?: PuzzleChallengeUncheckedCreateNestedOneWithoutChallengeInput
    orderingChallenge?: OrderingChallengeUncheckedCreateNestedOneWithoutChallengeInput
    fillBlankChallenge?: FillBlankChallengeUncheckedCreateNestedOneWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutChallengeScoreInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutChallengeScoreInput, ChallengeUncheckedCreateWithoutChallengeScoreInput>
  }

  export type UserUpsertWithoutChallengeScoreInput = {
    update: XOR<UserUpdateWithoutChallengeScoreInput, UserUncheckedUpdateWithoutChallengeScoreInput>
    create: XOR<UserCreateWithoutChallengeScoreInput, UserUncheckedCreateWithoutChallengeScoreInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengeScoreInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengeScoreInput, UserUncheckedUpdateWithoutChallengeScoreInput>
  }

  export type UserUpdateWithoutChallengeScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengeScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChallengeUpsertWithoutChallengeScoreInput = {
    update: XOR<ChallengeUpdateWithoutChallengeScoreInput, ChallengeUncheckedUpdateWithoutChallengeScoreInput>
    create: XOR<ChallengeCreateWithoutChallengeScoreInput, ChallengeUncheckedCreateWithoutChallengeScoreInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutChallengeScoreInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutChallengeScoreInput, ChallengeUncheckedUpdateWithoutChallengeScoreInput>
  }

  export type ChallengeUpdateWithoutChallengeScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUpdateOneWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUpdateOneWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutChallengeScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ChallengeQuestionUncheckedUpdateManyWithoutChallengeNestedInput
    puzzleChallenge?: PuzzleChallengeUncheckedUpdateOneWithoutChallengeNestedInput
    orderingChallenge?: OrderingChallengeUncheckedUpdateOneWithoutChallengeNestedInput
    fillBlankChallenge?: FillBlankChallengeUncheckedUpdateOneWithoutChallengeNestedInput
  }

  export type UserCreateWithoutUserLessonScoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserLessonScoreInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    userCourseProgress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserLessonScoreInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserLessonScoreInput, UserUncheckedCreateWithoutUserLessonScoreInput>
  }

  export type LessonCreateWithoutUserLessonScoreInput = {
    id?: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    module: ModuleCreateNestedOneWithoutLessonsInput
    question?: QuizQuestionCreateNestedManyWithoutLessonInput
    userProgress?: UserLessonProgressCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutUserLessonScoreInput = {
    id?: string
    module_id: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    question?: QuizQuestionUncheckedCreateNestedManyWithoutLessonInput
    userProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutUserLessonScoreInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutUserLessonScoreInput, LessonUncheckedCreateWithoutUserLessonScoreInput>
  }

  export type UserUpsertWithoutUserLessonScoreInput = {
    update: XOR<UserUpdateWithoutUserLessonScoreInput, UserUncheckedUpdateWithoutUserLessonScoreInput>
    create: XOR<UserCreateWithoutUserLessonScoreInput, UserUncheckedCreateWithoutUserLessonScoreInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserLessonScoreInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserLessonScoreInput, UserUncheckedUpdateWithoutUserLessonScoreInput>
  }

  export type UserUpdateWithoutUserLessonScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserLessonScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonUpsertWithoutUserLessonScoreInput = {
    update: XOR<LessonUpdateWithoutUserLessonScoreInput, LessonUncheckedUpdateWithoutUserLessonScoreInput>
    create: XOR<LessonCreateWithoutUserLessonScoreInput, LessonUncheckedCreateWithoutUserLessonScoreInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutUserLessonScoreInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutUserLessonScoreInput, LessonUncheckedUpdateWithoutUserLessonScoreInput>
  }

  export type LessonUpdateWithoutUserLessonScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    question?: QuizQuestionUpdateManyWithoutLessonNestedInput
    userProgress?: UserLessonProgressUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutUserLessonScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    module_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuizQuestionUncheckedUpdateManyWithoutLessonNestedInput
    userProgress?: UserLessonProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserCreateWithoutUserCourseProgressInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserCourseProgressInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    fullName: string
    password: string
    avatar?: string | null
    isVerified?: boolean
    role?: string
    age?: number | null
    grade?: $Enums.Grade | null
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    challengeScore?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    userLessonScore?: UserLessonScoreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserCourseProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCourseProgressInput, UserUncheckedCreateWithoutUserCourseProgressInput>
  }

  export type ProductCreateWithoutUserCourseProgressInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUserCourseProgressInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    category_id: string
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUserCourseProgressInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserCourseProgressInput, ProductUncheckedCreateWithoutUserCourseProgressInput>
  }

  export type UserUpsertWithoutUserCourseProgressInput = {
    update: XOR<UserUpdateWithoutUserCourseProgressInput, UserUncheckedUpdateWithoutUserCourseProgressInput>
    create: XOR<UserCreateWithoutUserCourseProgressInput, UserUncheckedCreateWithoutUserCourseProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserCourseProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserCourseProgressInput, UserUncheckedUpdateWithoutUserCourseProgressInput>
  }

  export type UserUpdateWithoutUserCourseProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCourseProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableEnumGradeFieldUpdateOperationsInput | $Enums.Grade | null
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    challengeScore?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutUserCourseProgressInput = {
    update: XOR<ProductUpdateWithoutUserCourseProgressInput, ProductUncheckedUpdateWithoutUserCourseProgressInput>
    create: XOR<ProductCreateWithoutUserCourseProgressInput, ProductUncheckedCreateWithoutUserCourseProgressInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutUserCourseProgressInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutUserCourseProgressInput, ProductUncheckedUpdateWithoutUserCourseProgressInput>
  }

  export type ProductUpdateWithoutUserCourseProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserCourseProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OTPCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    code: string
    isUsed?: boolean
  }

  export type EnrollmentCreateManyUserInput = {
    id?: string
    product_id: string
    created_at?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    product_id: string
    rating: number
    comment?: string | null
    status?: boolean
    created_at?: Date | string
  }

  export type UserLessonProgressCreateManyUserInput = {
    id?: string
    lesson_id: string
    completed_at?: Date | string | null
  }

  export type ChallengeScoreCreateManyUserInput = {
    id?: string
    challenge_id: string
    score: number
    submitted_at?: Date | string
  }

  export type UserLessonScoreCreateManyUserInput = {
    id?: string
    lessonId: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseProgressCreateManyUserInput = {
    id?: string
    product_id: string
    completed_at?: Date | string | null
  }

  export type OTPUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OTPUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OTPUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EnrollmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserLessonProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lesson_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLessonProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lesson_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeScoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutChallengeScoreNestedInput
  }

  export type ChallengeScoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challenge_id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonScoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutUserLessonScoreNestedInput
  }

  export type UserLessonScoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonScoreUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: ProductUpdateOneRequiredWithoutUserCourseProgressNestedInput
  }

  export type UserCourseProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCourseProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    title: string
    slug: string
    short_description: string
    description?: string | null
    thumbnail: string
    label?: $Enums.ProductLabel
    status?: $Enums.ProductStatus
    requirements: string
    learning_outcomes: string
    preview_video?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    userCourseProgress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    label?: EnumProductLabelFieldUpdateOperationsInput | $Enums.ProductLabel
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    requirements?: StringFieldUpdateOperationsInput | string
    learning_outcomes?: StringFieldUpdateOperationsInput | string
    preview_video?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModuleCreateManyCourseInput = {
    id?: string
    title: string
    short_description: string
    order?: number
    status?: $Enums.ModuleStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type EnrollmentCreateManyProductInput = {
    id?: string
    user_id: string
    created_at?: Date | string
  }

  export type ReviewCreateManyProductInput = {
    id?: string
    user_id: string
    rating: number
    comment?: string | null
    status?: boolean
    created_at?: Date | string
  }

  export type UserCourseProgressCreateManyCourseInput = {
    id?: string
    user_id: string
    completed_at?: Date | string | null
  }

  export type ModuleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumModuleStatusFieldUpdateOperationsInput | $Enums.ModuleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumModuleStatusFieldUpdateOperationsInput | $Enums.ModuleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    short_description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumModuleStatusFieldUpdateOperationsInput | $Enums.ModuleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseProgressUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserCourseProgressNestedInput
  }

  export type UserCourseProgressUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCourseProgressUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonCreateManyModuleInput = {
    id?: string
    title: string
    description: string
    type: $Enums.LessonType
    is_previewable?: boolean
    status?: $Enums.LessonStatus
    order?: number
    attachment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type LessonUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuizQuestionUpdateManyWithoutLessonNestedInput
    userProgress?: UserLessonProgressUpdateManyWithoutLessonNestedInput
    userLessonScore?: UserLessonScoreUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuizQuestionUncheckedUpdateManyWithoutLessonNestedInput
    userProgress?: UserLessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    userLessonScore?: UserLessonScoreUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    is_previewable?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    order?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionCreateManyLessonInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type UserLessonProgressCreateManyLessonInput = {
    id?: string
    user_id: string
    completed_at?: Date | string | null
  }

  export type UserLessonScoreCreateManyLessonInput = {
    id?: string
    userId: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: QuizAnswerUpdateManyWithoutQuiz_questionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuiz_questionNestedInput
  }

  export type QuizQuestionUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLessonProgressUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserLessonProgressNestedInput
  }

  export type UserLessonProgressUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLessonProgressUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLessonScoreUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserLessonScoreNestedInput
  }

  export type UserLessonScoreUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonScoreUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAnswerCreateManyQuiz_questionInput = {
    id?: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuizAnswerUpdateWithoutQuiz_questionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerUncheckedUpdateWithoutQuiz_questionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAnswerUncheckedUpdateManyWithoutQuiz_questionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeQuestionCreateManyChallengeInput = {
    id?: string
    question: string
    explanation?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeScoreCreateManyChallengeInput = {
    id?: string
    user_id: string
    score: number
    submitted_at?: Date | string
  }

  export type ChallengeQuestionUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: ChallengeAnswerUpdateManyWithoutChallenge_questionNestedInput
  }

  export type ChallengeQuestionUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: ChallengeAnswerUncheckedUpdateManyWithoutChallenge_questionNestedInput
  }

  export type ChallengeQuestionUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChallengeScoreNestedInput
  }

  export type ChallengeScoreUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAnswerCreateManyChallenge_questionInput = {
    id?: string
    answer: string
    is_correct?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeAnswerUpdateWithoutChallenge_questionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAnswerUncheckedUpdateWithoutChallenge_questionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAnswerUncheckedUpdateManyWithoutChallenge_questionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderingItemCreateManyOrderingChallengeInput = {
    id?: string
    content: string
    correct_order: number
    explanation?: string | null
  }

  export type OrderingItemUpdateWithoutOrderingChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    correct_order?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderingItemUncheckedUpdateWithoutOrderingChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    correct_order?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderingItemUncheckedUpdateManyWithoutOrderingChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    correct_order?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FillBlankQuestionCreateManyChallengeInput = {
    id?: string
    sentence: string
    correct_word: string
  }

  export type FillBlankQuestionUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentence?: StringFieldUpdateOperationsInput | string
    correct_word?: StringFieldUpdateOperationsInput | string
  }

  export type FillBlankQuestionUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentence?: StringFieldUpdateOperationsInput | string
    correct_word?: StringFieldUpdateOperationsInput | string
  }

  export type FillBlankQuestionUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentence?: StringFieldUpdateOperationsInput | string
    correct_word?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}